{"pageProps":{"allPosts":[{"title":"Vue3.0核心源码解读| 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21T23:00:00.322Z","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读| 一文看懂Vue3.0的优化","date":"2020-12-19T14:00:00.322Z","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17T18:00:00.322Z","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06T12:00:00.322Z","slug":"2020-10-06-react17-coming","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27T12:00:00.322Z","slug":"2020-09-27-react-grid-layout","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20T12:00:00.322Z","slug":"2020-09-20-ECMAScript2020","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22T12:00:00.322Z","slug":"2020-08-22-ECMAScript2019","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12T12:00:00.322Z","slug":"2020-08-12-ECMAScript2018","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01T12:00:00.322Z","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18T12:00:00.322Z","slug":"2020-07-18-ECMAScript2017","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11T12:00:00.322Z","slug":"2020-07-11-ECMAScript2016","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18T12:00:00.322Z","slug":"2019-12-18-immutable-react","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24T12:00:00.322Z","slug":"2019-10-24-JavaScript-prototype","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23T12:00:00.322Z","slug":"2019-10-23-setState-sync-or-async","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22T12:00:00.322Z","slug":"2019-09-22-javascript-this-pointer","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12T12:00:00.322Z","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12T12:00:00.322Z","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15T12:00:00.322Z","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15T12:00:00.322Z","slug":"2018-08-15-vue-server-side-render","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09T12:00:00.322Z","slug":"2018-08-09-mysql-common-commands","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07T12:00:00.322Z","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06T12:00:00.322Z","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04T12:00:00.322Z","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02T12:00:00.322Z","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31T05:35:07.322Z","slug":"2018-07-31-about-life-and-survival","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12T12:00:00.322Z","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09T12:00:00.322Z","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20T12:00:00.322Z","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05T12:00:00.322Z","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01T12:00:00.322Z","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28T12:00:00.322Z","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15T12:00:00.322Z","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28T12:00:00.322Z","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22T12:00:00.322Z","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09T12:00:00.322Z","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15T12:00:00.322Z","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25T12:00:00.322Z","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15T12:00:00.322Z","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14T12:00:00.322Z","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31T12:00:00.322Z","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25T12:00:00.322Z","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10T12:00:00.322Z","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20T12:00:00.322Z","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01T12:00:00.322Z","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"ECMAScript2020新特性总结及使用场景","slug":"2020-09-20-ECMAScript2020"},"nextPost":{"title":"React 17来了","slug":"2020-10-06-react17-coming"}},"post":{"title":"React-grid-layout 一个支持拖拽的栅格布局库","description":"React-grid-layout 一个可以支持拖拽、改变大小的栅格布局库，完美支持React","keyword":"ReactGridLayout,react,栅格,拖拽","date":"2020-09-27T12:00:00.322Z","slug":"2020-09-27-react-grid-layout","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<h2>演示版</h2>\n<ol>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/0-showcase.html\">Showcase</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/1-basic.html\">Basic</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/2-no-dragging.html\">No Dragging/Resizing (Layout Only)</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/3-messy.html\">Messy Layout Autocorrect</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/4-grid-property.html\">Layout Defined on Children</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/5-static-elements.html\">Static Elements</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/6-dynamic-add-remove.html\">Adding/Removing Elements</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/7-localstorage.html\">Saving Layout to LocalStorage</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/8-localstorage-responsive.html\">Saving a Responsive Layout to LocalStorage</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/9-min-max-wh.html\">Minimum and Maximum Width/Height</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/10-dynamic-min-max-wh.html\">Dynamic Minimum and Maximum Width/Height</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/11-no-vertical-compact.html\">No Vertical Compacting (Free Movement)</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/12-prevent-collision.html\">Prevent Collision</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/13-error-case.html\">Error Case</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/14-toolbox.html\">Toolbox</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/15-drag-from-outside.html\">Drag From Outside</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/16-bounded.html\">Bounded Layout</a></li>\n<li><a href=\"https://strml.github.io/react-grid-layout/examples/17-resizable-handles.html\">Resizable Handles</a></li>\n</ol>\n<h2>特征</h2>\n<ul>\n<li>100％React-没有 jQuery</li>\n<li>与服务器渲染的应用程序兼容</li>\n<li>可拖动的小部件</li>\n<li>可调整大小的小部件</li>\n<li>静态小部件</li>\n<li>可配置包装：水平，垂直或不固定</li>\n<li>边界检查以进行拖动和调整大小</li>\n<li>可以在不重建网格的情况下添加或删除小部件</li>\n<li>布局可以序列化和还原</li>\n<li>响应断点</li>\n<li>每个响应断点单独的布局</li>\n<li>使用 CSS 变换放置的网格项目</li>\n</ul>\n<h2>安装</h2>\n<p>使用<a href=\"https://www.npmjs.com/\">npm</a>安装 React-Grid-Layout<a href=\"https://www.npmjs.org/package/react-grid-layout\">软件包</a>：</p>\n<pre class=\"hljs\"><code>npm install react-grid-layout\n</code></pre>\n<p>在您的应用程序中添加以下样式表：</p>\n<pre class=\"hljs\"><code>/node_modules/react-grid-layout/css/styles.css\n/node_modules/react-resizable/css/styles.css\n</code></pre>\n<h2>使用</h2>\n<p>像使用任何其他组件一样使用 ReactGridLayout。下面的示例将生成一个包含以下三个项目的网格：：</p>\n<ul>\n<li>用户将无法拖动或调整项目的大小<code>a</code></li>\n<li>项将限制为 2 个网格块的最小宽度和 4 个网格块的最大宽度<code>b</code></li>\n<li>用户将能够自由拖动和调整项目的大小<code>c</code></li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> GridLayout <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-grid-layout&quot;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyFirstGrid</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// layout is an array of objects, see the demo for more complete usage</span>\n    <span class=\"hljs-keyword\">const</span> layout = [\n      { <span class=\"hljs-attr\">i</span>: <span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">w</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">h</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">static</span>: <span class=\"hljs-literal\">true</span> },\n      { <span class=\"hljs-attr\">i</span>: <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">w</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">h</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">minW</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">maxW</span>: <span class=\"hljs-number\">4</span> },\n      { <span class=\"hljs-attr\">i</span>: <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">w</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">h</span>: <span class=\"hljs-number\">2</span> }\n    ];\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GridLayout</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;layout&quot;</span>\n        <span class=\"hljs-attr\">layout</span>=<span class=\"hljs-string\">{layout}</span>\n        <span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">{12}</span>\n        <span class=\"hljs-attr\">rowHeight</span>=<span class=\"hljs-string\">{30}</span>\n        <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{1200}</span>\n      &gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;a&quot;</span>&gt;</span>a<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;b&quot;</span>&gt;</span>b<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;c&quot;</span>&gt;</span>c<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GridLayout</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>您还可以选择直接在子项上设置布局属性：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> GridLayout <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-grid-layout&quot;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyFirstGrid</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GridLayout</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;layout&quot;</span> <span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">{12}</span> <span class=\"hljs-attr\">rowHeight</span>=<span class=\"hljs-string\">{30}</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{1200}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;a&quot;</span> <span class=\"hljs-attr\">data-grid</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">x:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">y:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">w:</span> <span class=\"hljs-attr\">1</span>, <span class=\"hljs-attr\">h:</span> <span class=\"hljs-attr\">2</span>, <span class=\"hljs-attr\">static:</span> <span class=\"hljs-attr\">true</span> }}&gt;</span>\n          a\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;b&quot;</span> <span class=\"hljs-attr\">data-grid</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">x:</span> <span class=\"hljs-attr\">1</span>, <span class=\"hljs-attr\">y:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">w:</span> <span class=\"hljs-attr\">3</span>, <span class=\"hljs-attr\">h:</span> <span class=\"hljs-attr\">2</span>, <span class=\"hljs-attr\">minW:</span> <span class=\"hljs-attr\">2</span>, <span class=\"hljs-attr\">maxW:</span> <span class=\"hljs-attr\">4</span> }}&gt;</span>\n          b\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;c&quot;</span> <span class=\"hljs-attr\">data-grid</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">x:</span> <span class=\"hljs-attr\">4</span>, <span class=\"hljs-attr\">y:</span> <span class=\"hljs-attr\">0</span>, <span class=\"hljs-attr\">w:</span> <span class=\"hljs-attr\">1</span>, <span class=\"hljs-attr\">h:</span> <span class=\"hljs-attr\">2</span> }}&gt;</span>\n          c\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GridLayout</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<h3>在没有 Browserify / Webpack 的情况下使用</h3>\n<p>在一个模块可用<code>&lt;script&gt;</code>标签包含<a href=\"https://github.com/STRML/react-grid-layout/blob/master/dist/react-grid-layout.min.js\">在这里</a>。它使用 UMD 填充程序并排除<code>React</code>，因此必须通过 RequireJS 或在<code>&lt;script&gt;</code>中使用<code>React</code>、<code>window.React</code>。</p>\n<h3>响应式用法</h3>\n<p>要使 RGL 响应，请使用<code>&lt;ResponsiveReactGridLayout&gt;</code>元素：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { Responsive <span class=\"hljs-keyword\">as</span> ResponsiveGridLayout } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-grid-layout&quot;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyResponsiveGrid</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// {lg: layout1, md: layout2, ...}</span>\n    <span class=\"hljs-keyword\">const</span> layouts = getLayoutsFromSomewhere();\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ResponsiveGridLayout</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;layout&quot;</span>\n        <span class=\"hljs-attr\">layouts</span>=<span class=\"hljs-string\">{layouts}</span>\n        <span class=\"hljs-attr\">breakpoints</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">lg:</span> <span class=\"hljs-attr\">1200</span>, <span class=\"hljs-attr\">md:</span> <span class=\"hljs-attr\">996</span>, <span class=\"hljs-attr\">sm:</span> <span class=\"hljs-attr\">768</span>, <span class=\"hljs-attr\">xs:</span> <span class=\"hljs-attr\">480</span>, <span class=\"hljs-attr\">xxs:</span> <span class=\"hljs-attr\">0</span> }}\n        <span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">lg:</span> <span class=\"hljs-attr\">12</span>, <span class=\"hljs-attr\">md:</span> <span class=\"hljs-attr\">10</span>, <span class=\"hljs-attr\">sm:</span> <span class=\"hljs-attr\">6</span>, <span class=\"hljs-attr\">xs:</span> <span class=\"hljs-attr\">4</span>, <span class=\"hljs-attr\">xxs:</span> <span class=\"hljs-attr\">2</span> }}\n      &gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;1&quot;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;3&quot;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ResponsiveGridLayout</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>在响应模式下，您应该通过<code>layouts</code>属性提供至少一个断点。\n使用时<code>layouts</code>，最好提供尽可能多的断点，尤其是最大的断点。如果提供了最大的值，RGL 将尝试对其余的值进行插值。\n您还需要提供<code>width</code>，<code>&lt;ResponsiveReactGridLayout&gt;</code>建议您<code>WidthProvider</code>按照以下说明使用 HOC 。\n可以通过<code>data-grid</code>属性在各个项目上提供默认映射，以便在布局插值中将它们考虑在内。</p>\n<h3>提供网格宽度</h3>\n<p>双方<code>&lt;ResponsiveReactGridLayout&gt;</code>并<code>&lt;ReactGridLayout&gt;</code>采取<code>width</code>来计算拖动事件位置。在简单的情况下，HOC<code>WidthProvider</code>可用于在初始化和窗口调整大小事件时自动确定宽度。\n<code>&lt;ResponsiveReactGridLayout&gt;``&lt;ReactGridLayout&gt;``width``WidthProvider</code>;</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { Responsive, WidthProvider } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-grid-layout&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> ResponsiveGridLayout = WidthProvider(Responsive);\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyResponsiveGrid</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// {lg: layout1, md: layout2, ...}</span>\n    <span class=\"hljs-keyword\">var</span> layouts = getLayoutsFromSomewhere();\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ResponsiveGridLayout</span>\n        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;layout&quot;</span>\n        <span class=\"hljs-attr\">layouts</span>=<span class=\"hljs-string\">{layouts}</span>\n        <span class=\"hljs-attr\">breakpoints</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">lg:</span> <span class=\"hljs-attr\">1200</span>, <span class=\"hljs-attr\">md:</span> <span class=\"hljs-attr\">996</span>, <span class=\"hljs-attr\">sm:</span> <span class=\"hljs-attr\">768</span>, <span class=\"hljs-attr\">xs:</span> <span class=\"hljs-attr\">480</span>, <span class=\"hljs-attr\">xxs:</span> <span class=\"hljs-attr\">0</span> }}\n        <span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">lg:</span> <span class=\"hljs-attr\">12</span>, <span class=\"hljs-attr\">md:</span> <span class=\"hljs-attr\">10</span>, <span class=\"hljs-attr\">sm:</span> <span class=\"hljs-attr\">6</span>, <span class=\"hljs-attr\">xs:</span> <span class=\"hljs-attr\">4</span>, <span class=\"hljs-attr\">xxs:</span> <span class=\"hljs-attr\">2</span> }}\n      &gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;1&quot;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;3&quot;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ResponsiveGridLayout</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p><code>WidthProvider</code>如果需要更复杂的逻辑，这使您可以轻松地替换为自己的提供方 HOC。\n<code>WidthProvider</code>接受一个属性：<code>measureBeforeMount</code>。如果为<code>true</code>，<code>WidthProvider</code>将在安装儿童之前测量容器的宽度。如果您想完全消除应用程序/组件安装上的任何调整大小的动画，请使用此选项。\n有更复杂的布局吗？<code>WidthProvider</code> <a href=\"https://github.com/STRML/react-grid-layout/blob/master/lib/components/WidthProvider.jsx\">非常简单</a>，仅侦听窗口<code>'resize'</code>事件。如果您需要更多功能和灵活性，请尝试使用 <a href=\"https://github.com/ctrlplusb/react-sizeme\">SizeMe React HOC</a>作为 WidthProvider 的替代方法。</p>\n<h3>网格布局属性</h3>\n<p>RGL 支持以下属性（请参阅源代码中的最后一个字）：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Basic props</span>\n<span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-comment\">// This allows setting the initial width on the server side.</span>\n<span class=\"hljs-comment\">// This is required unless using the HOC &lt;WidthProvider&gt; or similar</span>\n<span class=\"hljs-comment\">// 这允许在服务器端设置初始宽度。</span>\n<span class=\"hljs-comment\">// 这是必需的，除非使用HOC &lt;WidthProvider&gt;或类似的</span>\n<span class=\"hljs-attr\">width</span>: number,\n\n<span class=\"hljs-comment\">// If true, the container height swells and contracts to fit contents</span>\n<span class=\"hljs-comment\">// 如果为真，容器高度膨胀和收缩，以适应内容</span>\n<span class=\"hljs-attr\">autoSize</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n\n<span class=\"hljs-comment\">// Number of columns in this layout.</span>\n<span class=\"hljs-comment\">// 此布局中的列数。</span>\n<span class=\"hljs-attr\">cols</span>: ?number = <span class=\"hljs-number\">12</span>,\n\n<span class=\"hljs-comment\">// A CSS selector for tags that will not be draggable.</span>\n<span class=\"hljs-comment\">// For example: draggableCancel:&#x27;.MyNonDraggableAreaClassName&#x27;</span>\n<span class=\"hljs-comment\">// If you forget the leading . it will not work.</span>\n<span class=\"hljs-comment\">// 不可拖动标签的CSS选择器。</span>\n<span class=\"hljs-comment\">// 例如：draggableCancel：&#x27;.MyNonDraggableAreaClassName&#x27;</span>\n<span class=\"hljs-comment\">// 如果忘记了leading。这个属性不起作用。</span>\n<span class=\"hljs-attr\">draggableCancel</span>: ?string = <span class=\"hljs-string\">&#x27;&#x27;</span>,\n\n<span class=\"hljs-comment\">// A CSS selector for tags that will act as the draggable handle.</span>\n<span class=\"hljs-comment\">// For example: draggableHandle:&#x27;.MyDragHandleClassName&#x27;</span>\n<span class=\"hljs-comment\">// If you forget the leading . it will not work.</span>\n<span class=\"hljs-comment\">// 标记的CSS选择器，将用作可拖动句柄。</span>\n<span class=\"hljs-comment\">// 例如：draggableHandle：&#x27;.MyDragHandleClassName&#x27;</span>\n<span class=\"hljs-comment\">// 如果忘记了leading。这个属性不起作用。</span>\n<span class=\"hljs-attr\">draggableHandle</span>: ?string = <span class=\"hljs-string\">&#x27;&#x27;</span>,\n\n<span class=\"hljs-comment\">// If true, the layout will compact vertically</span>\n<span class=\"hljs-comment\">//如果为true，则布局将沿垂直方向</span>\n<span class=\"hljs-attr\">verticalCompact</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n\n<span class=\"hljs-comment\">// Compaction type.</span>\n<span class=\"hljs-comment\">// 压缩类型</span>\n<span class=\"hljs-attr\">compactType</span>: ?(<span class=\"hljs-string\">&#x27;vertical&#x27;</span> | <span class=\"hljs-string\">&#x27;horizontal&#x27;</span>) = <span class=\"hljs-string\">&#x27;vertical&#x27;</span>;\n\n<span class=\"hljs-comment\">// Layout is an array of object with the format:</span>\n<span class=\"hljs-comment\">// {x: number, y: number, w: number, h: number}</span>\n<span class=\"hljs-comment\">// The index into the layout must match the key used on each item component.</span>\n<span class=\"hljs-comment\">// If you choose to use custom keys, you can specify that key in the layout</span>\n<span class=\"hljs-comment\">// array objects like so:</span>\n<span class=\"hljs-comment\">// {i: string, x: number, y: number, w: number, h: number}</span>\n<span class=\"hljs-comment\">// 布局是一个对象数组，其格式为：</span>\n<span class=\"hljs-comment\">// {x：数字，y：数字，w：数字，h：数字}</span>\n<span class=\"hljs-comment\">// 布局索引必须与每个项目组件上使用的键匹配。</span>\n<span class=\"hljs-comment\">// 如果选择使用自定义键，则可以在布局</span>\n<span class=\"hljs-comment\">// 数组对象中指定该键，例如：// {i：字符串，x：数字，y：数字，w：数字，h：数字}</span>\n<span class=\"hljs-comment\">// 如果未提供，则在子级上使用数据网格属性</span>\nlayout: ?array = <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// If not provided, use data-grid props on children</span>\n\n<span class=\"hljs-comment\">// Margin between items [x, y] in px.</span>\n<span class=\"hljs-comment\">// 像素中[x，y]之间的边距。</span>\n<span class=\"hljs-attr\">margin</span>: ?[number, number] = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>],\n\n<span class=\"hljs-comment\">// Padding inside the container [x, y] in px</span>\n<span class=\"hljs-attr\">containerPadding</span>: ?[number, number] = margin,\n\n<span class=\"hljs-comment\">// Rows have a static height, but you can change this based on breakpoints</span>\n<span class=\"hljs-comment\">// if you like.</span>\n<span class=\"hljs-comment\">// 行具有静态高度，但您可以根据需要更改断点</span>\n<span class=\"hljs-attr\">rowHeight</span>: ?number = <span class=\"hljs-number\">150</span>,\n\n<span class=\"hljs-comment\">// Configuration of a dropping element. Dropping element is a &quot;virtual&quot; element</span>\n<span class=\"hljs-comment\">// which appears when you drag over some element from outside.</span>\n<span class=\"hljs-comment\">// It can be changed by passing specific parameters:</span>\n<span class=\"hljs-comment\">//  i - id of an element</span>\n<span class=\"hljs-comment\">//  w - width of an element</span>\n<span class=\"hljs-comment\">//  h - height of an element</span>\n<span class=\"hljs-comment\">// 放置元素的配置。放置元素是一个“虚拟”元素，当您从外部拖动某个元素时出现。</span>\n<span class=\"hljs-comment\">// 可以通过传递特定的参数来更改它：</span>\ndroppingItem?: { <span class=\"hljs-attr\">i</span>: string, <span class=\"hljs-attr\">w</span>: number, <span class=\"hljs-attr\">h</span>: number }\n\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Flags</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-attr\">isDraggable</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-attr\">isResizable</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-attr\">isBounded</span>: ?boolean = <span class=\"hljs-literal\">false</span>,\n<span class=\"hljs-comment\">// Uses CSS3 translate() instead of position top/left.</span>\n<span class=\"hljs-comment\">// This makes about 6x faster paint performance</span>\n<span class=\"hljs-comment\">// 使用CSS3 translate（）代替位置top / left。</span>\n<span class=\"hljs-comment\">// 可以使绘画性能提高大约6倍</span>\n<span class=\"hljs-attr\">useCSSTransforms</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-comment\">// If parent DOM node of ResponsiveReactGridLayout or ReactGridLayout has &quot;transform: scale(n)&quot; css property,</span>\n<span class=\"hljs-comment\">// we should set scale coefficient to avoid render artefacts while dragging.</span>\n<span class=\"hljs-comment\">// 如果ResponsiveReactGridLayout或ReactGridLayout的父DOM节点具有“ transform：scale（n）” css属性，</span>\n<span class=\"hljs-comment\">// 我们应该设置比例系数以避免拖动时的渲染假象。</span>\n<span class=\"hljs-attr\">transformScale</span>: ?number = <span class=\"hljs-number\">1</span>,\n\n<span class=\"hljs-comment\">// If true, grid items won&#x27;t change position when being</span>\n<span class=\"hljs-comment\">// dragged over.</span>\n<span class=\"hljs-comment\">// 如果为true，则将网格项拖动到覆盖其他网格时不会改变位置</span>\n<span class=\"hljs-attr\">preventCollision</span>: ?boolean = <span class=\"hljs-literal\">false</span>;\n\n<span class=\"hljs-comment\">// If true, droppable elements (with `draggable={true}` attribute)</span>\n<span class=\"hljs-comment\">// can be dropped on the grid. It triggers &quot;onDrop&quot; callback</span>\n<span class=\"hljs-comment\">// with position and event object as parameters.</span>\n<span class=\"hljs-comment\">// It can be useful for dropping an element in a specific position</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> In case of using Firefox you should add</span>\n<span class=\"hljs-comment\">// `onDragStart={e =&gt; e.dataTransfer.setData(&#x27;text/plain&#x27;, &#x27;&#x27;)}` attribute</span>\n<span class=\"hljs-comment\">// along with `draggable={true}` otherwise this feature will work incorrect.</span>\n<span class=\"hljs-comment\">// onDragStart attribute is required for Firefox for a dragging initialization</span>\n<span class=\"hljs-comment\">// @see https://bugzilla.mozilla.org/show_bug.cgi?id=568313</span>\n<span class=\"hljs-comment\">//如果为true，则可放置元素（具有`draggable = {true}`属性）可以放在网格上。它使用位置和事件对象作为参数触发 “ onDrop”回调。对于将元素放在特定位置很有用</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">//注意：如果使用Firefox，则应添加</span>\n<span class=\"hljs-comment\">// onDragStart = {e =&gt; e.dataTransfer.setData（&#x27;text / plain&#x27;，&#x27; &#x27;）}`属性</span>\n<span class=\"hljs-comment\">// 和`draggable = {true}`一起使用，否则此功能将无法正常使用。</span>\n<span class=\"hljs-comment\">// Firefox需要onDragStart属性来进行拖动初始化</span>\n<span class=\"hljs-comment\">// @see https://bugzilla.mozilla.org/show_bug.cgi?id=568313</span>\nisDroppable: ?boolean = <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-comment\">// Defines which resize handles should be rendered</span>\n<span class=\"hljs-comment\">// Allows for any combination of:</span>\n<span class=\"hljs-comment\">// &#x27;s&#x27; - South handle (bottom-center)</span>\n<span class=\"hljs-comment\">// &#x27;w&#x27; - West handle (left-center)</span>\n<span class=\"hljs-comment\">// &#x27;e&#x27; - East handle (right-center)</span>\n<span class=\"hljs-comment\">// &#x27;n&#x27; - North handle (top-center)</span>\n<span class=\"hljs-comment\">// &#x27;sw&#x27; - Southwest handle (bottom-left)</span>\n<span class=\"hljs-comment\">// &#x27;nw&#x27; - Northwest handle (top-left)</span>\n<span class=\"hljs-comment\">// &#x27;se&#x27; - Southeast handle (bottom-right)</span>\n<span class=\"hljs-comment\">// &#x27;ne&#x27; - Northeast handle (top-right)</span>\n<span class=\"hljs-comment\">// 定义应呈现的调整大小手柄，允许以下任意组合：</span>\n<span class=\"hljs-attr\">resizeHandles</span>: ?<span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-string\">&#x27;s&#x27;</span> | <span class=\"hljs-string\">&#x27;w&#x27;</span> | <span class=\"hljs-string\">&#x27;e&#x27;</span> | <span class=\"hljs-string\">&#x27;n&#x27;</span> | <span class=\"hljs-string\">&#x27;sw&#x27;</span> | <span class=\"hljs-string\">&#x27;nw&#x27;</span> | <span class=\"hljs-string\">&#x27;se&#x27;</span> | <span class=\"hljs-string\">&#x27;ne&#x27;</span>&gt; = [<span class=\"hljs-string\">&#x27;se&#x27;</span>]\n<span class=\"hljs-comment\">// Custom component for resize handles</span>\n<span class=\"hljs-comment\">// 用于调整大小的自定义组件处理</span>\nresizeHandle?: ReactElement&lt;any&gt; | (<span class=\"hljs-function\">(<span class=\"hljs-params\">resizeHandleAxis: ResizeHandleAxis</span>) =&gt;</span> ReactElement&lt;any&gt;)\n\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-comment\">// Callback so you can save the layout.</span>\n<span class=\"hljs-comment\">// Calls back with (currentLayout) after every drag or resize stop.</span>\n<span class=\"hljs-comment\">// 保存布局的回调。</span>\n<span class=\"hljs-comment\">// 每次停止拖动或调整大小后，使用（currentLayout）进行回调。</span>\n<span class=\"hljs-attr\">onLayoutChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">layout: Layout</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>,\n\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// All callbacks below have signature (layout, oldItem, newItem, placeholder, e, element).</span>\n<span class=\"hljs-comment\">// &#x27;start&#x27; and &#x27;stop&#x27; callbacks pass `undefined` for &#x27;placeholder&#x27;.</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// 下面的所有回调都具有签名（layout，oldItem，newItem，placeholder，e，element）。</span>\n<span class=\"hljs-comment\">// “开始”和“停止”回调传递“占位符”的“未定义”。</span>\ntype ItemCallback = <span class=\"hljs-function\">(<span class=\"hljs-params\">layout: Layout, oldItem: LayoutItem, newItem: LayoutItem,\n                     placeholder: LayoutItem, e: MouseEvent, element: HTMLElement</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n\n<span class=\"hljs-comment\">// Calls when drag starts.</span>\n<span class=\"hljs-comment\">// 拖动开始时调用</span>\nonDragStart: ItemCallback,\n<span class=\"hljs-comment\">// Calls on each drag movement.</span>\n<span class=\"hljs-comment\">// 每次拖动动作都调用。</span>\n<span class=\"hljs-attr\">onDrag</span>: ItemCallback,\n<span class=\"hljs-comment\">// Calls when drag is complete.</span>\n<span class=\"hljs-comment\">// 拖动完成后调用。</span>\n<span class=\"hljs-attr\">onDragStop</span>: ItemCallback,\n<span class=\"hljs-comment\">// Calls when resize starts.</span>\n<span class=\"hljs-comment\">// 发生尺寸调整移动时调用。</span>\n<span class=\"hljs-attr\">onResizeStart</span>: ItemCallback,\n<span class=\"hljs-comment\">// Calls when resize movement happens.</span>\n<span class=\"hljs-comment\">// 发生尺寸调整移动时调用。</span>\n<span class=\"hljs-attr\">onResize</span>: ItemCallback,\n<span class=\"hljs-comment\">// Calls when resize is complete.</span>\n<span class=\"hljs-comment\">// 调整大小后调用。</span>\n<span class=\"hljs-attr\">onResizeStop</span>: ItemCallback,\n<span class=\"hljs-comment\">// Calls when an element has been dropped into the grid from outside.</span>\n<span class=\"hljs-comment\">// 当元素从外部放入网格时调用。</span>\n<span class=\"hljs-attr\">onDrop</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">layout: Layout, item: ?LayoutItem, e: Event</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>\n\n<span class=\"hljs-comment\">// Ref for getting a reference for the grid&#x27;s wrapping div.</span>\n<span class=\"hljs-comment\">// You can use this instead of a regular ref and the deprecated `ReactDOM.findDOMNode()`` function.</span>\n<span class=\"hljs-comment\">// Ref，以获得有关网格包装div的参考。</span>\n<span class=\"hljs-comment\">// 您可以使用它代替常规引用和不推荐使用的`ReactDOM.findDOMNode（）``函数。</span>\n<span class=\"hljs-attr\">innerRef</span>: ?React.Ref&lt;<span class=\"hljs-string\">&quot;div&quot;</span>&gt;\n</code></pre>\n<h3>响应式网格布局属性</h3>\n<p>可以使用响应式网格布局。它支持上述所有属性，除了<code>layout</code>。新的属性和更改是：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}</span>\n<span class=\"hljs-comment\">// Breakpoint names are arbitrary but must match in the cols and layouts objects.</span>\n<span class=\"hljs-comment\">// {name：pxVal}，例如{lg：1200，md：996，sm：768，xs：480}</span>\n<span class=\"hljs-comment\">// 断点名称是任意的，但必须在cols和layouts对象中匹配。</span>\n<span class=\"hljs-attr\">breakpoints</span>: ?<span class=\"hljs-built_in\">Object</span> = {<span class=\"hljs-attr\">lg</span>: <span class=\"hljs-number\">1200</span>, <span class=\"hljs-attr\">md</span>: <span class=\"hljs-number\">996</span>, <span class=\"hljs-attr\">sm</span>: <span class=\"hljs-number\">768</span>, <span class=\"hljs-attr\">xs</span>: <span class=\"hljs-number\">480</span>, <span class=\"hljs-attr\">xxs</span>: <span class=\"hljs-number\">0</span>},\n\n<span class=\"hljs-comment\">// # of cols. This is a breakpoint -&gt; cols map, e.g. {lg: 12, md: 10, ...}</span>\n<span class=\"hljs-comment\">// 列数。这是一个断点- &gt;的cols映射，例如{LG：12，MD：10，...}</span>\n<span class=\"hljs-attr\">cols</span>: ?<span class=\"hljs-built_in\">Object</span> = {<span class=\"hljs-attr\">lg</span>: <span class=\"hljs-number\">12</span>, <span class=\"hljs-attr\">md</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">sm</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">xs</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">xxs</span>: <span class=\"hljs-number\">2</span>},\n\n\n<span class=\"hljs-comment\">// margin (in pixels). Can be specified either as horizontal and vertical margin, e.g. `[10, 10]` or as a breakpoint -&gt; margin map, e.g. `{lg: [10, 10], md: [10, 10], ...}.</span>\n<span class=\"hljs-comment\">// 边距（以像素为单位）。可以指定为水平和垂直边距，例如`[10，10]`或断点-&gt;边距图，例如`{lg：[10，10]，md：[10，10]，...} 。</span>\n<span class=\"hljs-attr\">margin</span>: [number, number] | {[breakpoint: $Keys&lt;breakpoints&gt;]: [number, number]}\n\n\n<span class=\"hljs-comment\">// containerPadding (in pixels). Can be specified either as horizontal and vertical padding, e.g. `[10, 10]` or as a breakpoint -&gt; containerPadding map, e.g. `{lg: [10, 10], md: [10, 10], ...}.</span>\n<span class=\"hljs-comment\">// containerPadding（以像素为单位）。可以指定为水平和垂直填充，例如`[10，10]`，也可以指定为断点-&gt; containerPadding映射，例如`{lg：[10，10]，md：[10，10]，...} 。</span>\n<span class=\"hljs-attr\">containerPadding</span>: [number, number] | {[breakpoint: $Keys&lt;breakpoints&gt;]: [number, number]}\n\n\n<span class=\"hljs-comment\">// layouts is an object mapping breakpoints to layouts.</span>\n<span class=\"hljs-comment\">// e.g. {lg: Layout, md: Layout, ...}</span>\n<span class=\"hljs-comment\">// layouts是将断点映射到布局的对象。</span>\n<span class=\"hljs-comment\">// 例如{lg：布局，md：布局，...}</span>\n<span class=\"hljs-attr\">layouts</span>: {[key: $Keys&lt;breakpoints&gt;]: Layout}\n\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-comment\">// Calls back with breakpoint and new # cols</span>\n<span class=\"hljs-comment\">//使用断点和新的＃cols</span>\n<span class=\"hljs-attr\">onBreakpointChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">newBreakpoint: string, newCols: number</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>,\n\n<span class=\"hljs-comment\">// Callback so you can save the layout.</span>\n<span class=\"hljs-comment\">// AllLayouts are keyed by breakpoint.</span>\n<span class=\"hljs-comment\">// 回调，以便您保存布局。</span>\n<span class=\"hljs-comment\">// AllLayouts由断点锁定。</span>\n<span class=\"hljs-attr\">onLayoutChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">currentLayout: Layout, allLayouts: {[key: $Keys&lt;breakpoints&gt;]: Layout}</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>,\n\n<span class=\"hljs-comment\">// Callback when the width changes, so you can modify the layout as needed.</span>\n<span class=\"hljs-comment\">// 宽度变化时回调，因此您可以根据需要修改布局。</span>\n<span class=\"hljs-attr\">onWidthChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">containerWidth: number, margin: [number, number], cols: number, containerPadding: [number, number]</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>;\n</code></pre>\n<h3>网格项目属性</h3>\n<p>RGL 在网格项目或布局项目上支持以下属性。初始化网格时，构建一个布局数组（如上述第一个示例中所示），或将此对象作为<code>data-grid</code>属性附加到每个子元素中（如第二个示例中所示）。\n请注意，如果提供的网格项目不完整（缺少之一<code>x, y, w, or h</code>），则会引发错误，因此您可以更正布局。\n如果没有为网格项目提供属性，则将生成一个宽度和高度为的属性<code>1</code>。\n您可以为每个尺寸设置最小值和最大值。这是为了调整大小；如果禁用了调整大小，那么它当然不会起作用。如果最小和最大重叠不正确，或者初始尺寸超出范围，则会引发错误。\n<code>&lt;GridItem&gt;</code>直接定义的任何属性都将优先于全局设置的选项。例如，如果布局具有属性<code>isDraggable: false</code>，但是网格项目具有 prop <code>isDraggable: true</code>，则即使标记了项目，该项目也可以拖动<code>static: true</code>。</p>\n<pre class=\"hljs\"><code>{\n\n  <span class=\"hljs-comment\">// A string corresponding to the component key</span>\n  <span class=\"hljs-comment\">// 对应于组件键</span>\n  <span class=\"hljs-attr\">i</span>: string,\n\n  <span class=\"hljs-comment\">// These are all in grid units, not pixels</span>\n  <span class=\"hljs-comment\">// 这些全部以网格为单位，而不是像素</span>\n  <span class=\"hljs-attr\">x</span>: number,\n  <span class=\"hljs-attr\">y</span>: number,\n  <span class=\"hljs-attr\">w</span>: number,\n  <span class=\"hljs-attr\">h</span>: number,\n  <span class=\"hljs-attr\">minW</span>: ?number = <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">maxW</span>: ?number = <span class=\"hljs-literal\">Infinity</span>,\n  <span class=\"hljs-attr\">minH</span>: ?number = <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">maxH</span>: ?number = <span class=\"hljs-literal\">Infinity</span>,\n\n  <span class=\"hljs-comment\">// If true, equal to `isDraggable: false, isResizable: false`.</span>\n  <span class=\"hljs-comment\">// 如果为true，则等于`isDraggable：false，isResizable：false`。</span>\n  <span class=\"hljs-attr\">static</span>: ?boolean = <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-comment\">// If false, will not be draggable. Overrides `static`.</span>\n  <span class=\"hljs-comment\">// 如果为false，将不可拖动。覆盖“静态”。</span>\n  <span class=\"hljs-attr\">isDraggable</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-comment\">// If false, will not be resizable. Overrides `static`.</span>\n  <span class=\"hljs-comment\">// 如果为false，将无法调整大小。覆盖“静态”。</span>\n  <span class=\"hljs-attr\">isResizable</span>: ?boolean = <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-comment\">// By default, a handle is only shown on the bottom-right (southeast) corner.</span>\n  <span class=\"hljs-comment\">// Note that resizing from the top or left is generally not intuitive.</span>\n  <span class=\"hljs-comment\">// 默认情况下，手柄仅显示在右下角（东南）。</span>\n  <span class=\"hljs-comment\">// 请注意，从顶部或左侧调整大小通常不直观。</span>\n  resizeHandles?: ?<span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-string\">&#x27;s&#x27;</span> | <span class=\"hljs-string\">&#x27;w&#x27;</span> | <span class=\"hljs-string\">&#x27;e&#x27;</span> | <span class=\"hljs-string\">&#x27;n&#x27;</span> | <span class=\"hljs-string\">&#x27;sw&#x27;</span> | <span class=\"hljs-string\">&#x27;nw&#x27;</span> | <span class=\"hljs-string\">&#x27;se&#x27;</span> | <span class=\"hljs-string\">&#x27;ne&#x27;</span>&gt; = [<span class=\"hljs-string\">&#x27;se&#x27;</span>]\n  <span class=\"hljs-comment\">// If true and draggable, item will be moved only within grid.</span>\n  <span class=\"hljs-comment\">// 如果为true和可拖动，则仅在网格内移动项目。</span>\n  <span class=\"hljs-attr\">isBounded</span>: ?boolean = <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<h3></h3>\n<h3>性能</h3>\n<p><code>&lt;ReactGridLayout&gt;</code>具有<a href=\"https://github.com/STRML/react-grid-layout/blob/master/lib/ReactGridLayout.jsx\">优化的<code>shouldComponentUpdate</code>实现</a>，但是它依赖于用户保存<code>children</code>数组：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// lib/ReactGridLayout.jsx</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps: Props, nextState: State</span>)</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> this is almost always unequal. Therefore the only way to get better performance</span>\n    <span class=\"hljs-comment\">// from SCU is if the user intentionally memoizes children. If they do, and they can</span>\n    <span class=\"hljs-comment\">// handle changes properly, performance will increase.</span>\n    <span class=\"hljs-comment\">// 注意：这几乎总是不平等的。因此从SCU获得更好的性能的唯一方法是</span>\n    <span class=\"hljs-comment\">// 如果用户故意记住children，如果他们这样做，并且他们可以正确地处理更改，则性能将会提高。</span>\n    <span class=\"hljs-built_in\">this</span>.props.children !== nextProps.children ||\n    !fastRGLPropsEqual(<span class=\"hljs-built_in\">this</span>.props, nextProps, isEqual) ||\n    !isEqual(<span class=\"hljs-built_in\">this</span>.state.activeDrag, nextState.activeDrag)\n  );\n}\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>如果在子组件中使用 memoize，则可以利用它，获得更好的执行效果。例如：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyGrid</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> children = React.useMemo(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(props.count).fill(<span class=\"hljs-literal\">undefined</span>).map(<span class=\"hljs-function\">(<span class=\"hljs-params\">val, idx</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{idx}</span> <span class=\"hljs-attr\">data-grid</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">x:</span> <span class=\"hljs-attr\">idx</span>, <span class=\"hljs-attr\">y:</span> <span class=\"hljs-attr\">1</span>, <span class=\"hljs-attr\">w:</span> <span class=\"hljs-attr\">1</span>, <span class=\"hljs-attr\">h:</span> <span class=\"hljs-attr\">1</span> }} /&gt;</span></span>;\n    });\n  }, [props.count]);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ReactGridLayout</span> <span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">{12}</span>&gt;</span>{children}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ReactGridLayout</span>&gt;</span></span>;\n}\n</code></pre>\n","ogImage":{"url":"/assets/blog/cover/2020-09-27-react-grid-layout.gif"},"coverImage":"/assets/blog/cover/2020-09-27-react-grid-layout.gif"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":7,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":4,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]}}},"__N_SSG":true}