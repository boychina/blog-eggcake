{"pageProps":{"allPosts":[{"title":"Vue3.0核心源码解读| 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21T23:00:00.322Z","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读| 一文看懂Vue3.0的优化","date":"2020-12-19T14:00:00.322Z","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17T18:00:00.322Z","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06T12:00:00.322Z","slug":"2020-10-06-react17-coming","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27T12:00:00.322Z","slug":"2020-09-27-react-grid-layout","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20T12:00:00.322Z","slug":"2020-09-20-ECMAScript2020","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22T12:00:00.322Z","slug":"2020-08-22-ECMAScript2019","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12T12:00:00.322Z","slug":"2020-08-12-ECMAScript2018","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01T12:00:00.322Z","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18T12:00:00.322Z","slug":"2020-07-18-ECMAScript2017","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11T12:00:00.322Z","slug":"2020-07-11-ECMAScript2016","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18T12:00:00.322Z","slug":"2019-12-18-immutable-react","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24T12:00:00.322Z","slug":"2019-10-24-JavaScript-prototype","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23T12:00:00.322Z","slug":"2019-10-23-setState-sync-or-async","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22T12:00:00.322Z","slug":"2019-09-22-javascript-this-pointer","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12T12:00:00.322Z","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12T12:00:00.322Z","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15T12:00:00.322Z","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15T12:00:00.322Z","slug":"2018-08-15-vue-server-side-render","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09T12:00:00.322Z","slug":"2018-08-09-mysql-common-commands","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07T12:00:00.322Z","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06T12:00:00.322Z","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04T12:00:00.322Z","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02T12:00:00.322Z","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31T05:35:07.322Z","slug":"2018-07-31-about-life-and-survival","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12T12:00:00.322Z","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09T12:00:00.322Z","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20T12:00:00.322Z","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05T12:00:00.322Z","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01T12:00:00.322Z","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28T12:00:00.322Z","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15T12:00:00.322Z","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28T12:00:00.322Z","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22T12:00:00.322Z","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09T12:00:00.322Z","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15T12:00:00.322Z","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25T12:00:00.322Z","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15T12:00:00.322Z","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14T12:00:00.322Z","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31T12:00:00.322Z","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25T12:00:00.322Z","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10T12:00:00.322Z","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20T12:00:00.322Z","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01T12:00:00.322Z","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"JavsScript 原型","slug":"2019-10-24-JavaScript-prototype"},"nextPost":{"title":"ECMAScript2016新特性总结及使用场景","slug":"2020-07-11-ECMAScript2016"}},"post":{"title":"Immutable 详解及 React 中实践","description":"认识Immutable对象，了解其在React中的使用，以及相关实践","keyword":"immutable,react","date":"2019-12-18T12:00:00.322Z","slug":"2019-12-18-immutable-react","author":{"name":"淡烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>Shared mutable state is the root of all evil （共享的可变状态是万恶之源） -- Pete Hunt</p>\n</blockquote>\n<p>有人说 Immutable 可以给 React 应用带来数十倍的提升，也有人说 Immutable 的引入是近期 JavaScript 中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。\nJavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如<code>foo = {a: 1}; bar = foo; bar.a = 2</code>你会发现此时<code>foo.a</code>也被改成了<code>2</code>。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy （浅拷贝）或 deepCopy （深拷贝）来比米娜被修改，但这样做造成了CPU和内存的浪费。\nImmutable 可以很好地解决这些问题。</p>\n<h2>1. 什么是 Immutable Data</h2>\n<p>Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure （持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing （结构共享），即如果对象书中一个节点发生变化，只修改这个节点和受影响的父节点，其他节点则进行共享。请看下面的动画：\n<img src=\"/assets/blog/context/2019-12-18-immutable-react/TB1zzi_KXXXXXctXFXXbrb8OVXX-613-575.gif\" alt=\"image.gif\">\n目前流行的 Immutable 库有两个：</p>\n<h3>1.1 immutable.js</h3>\n<p>Facebook 工程师 Lee Byron 花费3年时间打造，与React同期出现，但没有被默认放到React工具集里（React提供了简化的Helper）。它内部实现了一套完整的Persistent Data Structure，还有很多易用的数据类型。像<code>Collection</code>,<code>List</code>, <code>Map</code>, <code>Set</code>, <code>Record</code>, <code>Seq</code>。有非常全面的<code>map</code>, <code>filter</code>, <code>groupBy</code>, <code>reduce</code>, <code>find</code>函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。\n其中有3重最重要的数据结构说明一下：（Java程序员应该最熟悉了）</p>\n<ul>\n<li>Map ： 键值对集合，对应于 Object， ES6 也有专门的 Map对象</li>\n<li>List ： 有序可重复的列表，对应于 Array</li>\n<li>Set ： 无序且不可重复的列表</li>\n</ul>\n<h3>1.2 seamless-immutable</h3>\n<p>与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完成的 Persistent Data Structure， 而是使用<code>Object.defineProperty</code>（因此只有在IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API基于与 Array 和 Object 保持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。\n下面上代码来感受一下两者的不同：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 原来的写法</span>\n<span class=\"hljs-keyword\">let</span> foo = { <span class=\"hljs-attr\">a</span>: { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> } };\nlef bar = boo;\nbar.a.b = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-built_in\">console</span>.log(foo.a.b); <span class=\"hljs-comment\">// 打印 2</span>\n<span class=\"hljs-built_in\">console</span>.log(foo === bar); <span class=\"hljs-comment\">// 打印 true</span>\n<span class=\"hljs-comment\">// 使用 immutable.js 后</span>\n<span class=\"hljs-keyword\">import</span> Immutable <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable&#x27;</span>;\nfoo = Immutable.fromJS({ <span class=\"hljs-attr\">a</span>: { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> } });\nbar = foo.setIn( [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>], <span class=\"hljs-number\">2</span> ); <span class=\"hljs-comment\">// 使用 SetIn 赋值</span>\n<span class=\"hljs-built_in\">console</span>.log(foo.getIn([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>])); <span class=\"hljs-comment\">// 使用 getIn 取值， 打印 1</span>\n<span class=\"hljs-built_in\">console</span>.log(foo === bar); <span class=\"hljs-comment\">// 打印 false</span>\n<span class=\"hljs-comment\">// 使用 seamless-immutable.js 后</span>\n<span class=\"hljs-keyword\">import</span> SImmutable <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;seamless-immutable&#x27;</span>;\nfoo = SImmutable({ <span class=\"hljs-attr\">a</span>: { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span> } });\nboo = foo.merge({ <span class=\"hljs-attr\">a</span>: { <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> } }); <span class=\"hljs-comment\">// 使用 merge 赋值</span>\n<span class=\"hljs-built_in\">console</span>.log(foo.a.b); <span class=\"hljs-comment\">// 像原生 Object 一样取值，打印 1</span>\n<span class=\"hljs-built_in\">console</span>.log(foo === bar); <span class=\"hljs-comment\">// 打印 false</span>\n</code></pre>\n<h2>2. Immutable 优点</h2>\n<h3>2.1 Immutable 降低了 Mutable 带来的复杂度</h3>\n<p>可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。比如下面一段代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">touchAndLog</span>(<span class=\"hljs-params\">touchFn</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> data = { <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span> };\n    touchFn(data);\n    <span class=\"hljs-built_in\">console</span>.log(data.key); <span class=\"hljs-comment\">// 这里打印的数据会根据touchFn的处理发生变化</span>\n}\n</code></pre>\n<p>在不查看 <code>touchFn</code> 的代码的情况下，因为不确定它对 <code>data</code> 做了什么，你是不可能知道会打印什么。但如果 <code>data</code>是 Immutable 的呢， 你可以很肯定的知道打印的是 <code>value</code>。</p>\n<h3>2.2 节省内存</h3>\n<p>Immutable.js 使用了 Structure Sharing 会尽量复用内存。没有被引用的对象会被垃圾回收。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-built_in\">Map</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-built_in\">Map</span>({\n    <span class=\"hljs-attr\">select</span>: <span class=\"hljs-string\">&#x27;users&#x27;</span>,\n    <span class=\"hljs-attr\">filter</span>: <span class=\"hljs-built_in\">Map</span>({\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Cam&#x27;</span>\n    })\n})\n<span class=\"hljs-keyword\">let</span> b = a.set(<span class=\"hljs-string\">&#x27;select&#x27;</span>, <span class=\"hljs-string\">&#x27;people&#x27;</span>);\na === b; <span class=\"hljs-comment\">// false</span>\na.get(<span class=\"hljs-string\">&#x27;filter&#x27;</span>) === b.get(<span class=\"hljs-string\">&#x27;filter&#x27;</span>); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>上面 a 和 b 共享了没有变化的 <code>filter</code> 节点。</p>\n<h3>2.3 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟</h3>\n<p>因为每次数据都是不一样的，只要把这些数据放到一个数组里存储起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。\n后面我会提供Flux 做 Undo 的示例。</p>\n<h3>2.4 并发安全</h3>\n<p>传统的并发非常难做，因为要处理各种数据不一致的问题，因此·聪明人·发明了各种锁来解决。但使用了Immutable 之后，数据天生是不可变的，并发锁就不需要了。\n然而现在并没有什么卵用，因为 JavaScript 还是单项城运行的。但未来可能会加入，提前解决未来的问题不是挺好的吗？</p>\n<h3>2.5 拥抱函数式编程</h3>\n<p>Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。\n像 ClojureScript ， Elm 等函数式编程语言中的数据类型天生都是Immutable 的，这是因为什么ClojureScript 基于 React 的框架 -- Om 性能比 React 还要好的原因。</p>\n<h2>3. 使用 Immutable 的缺点</h2>\n<ol>\n<li>需要学习新的 API</li>\n</ol>\n<p>No Comments</p>\n<ol start=\"2\">\n<li>增加了资源文件大小</li>\n</ol>\n<p>No Comments</p>\n<ol start=\"3\">\n<li>容易对原生对象混淆</li>\n</ol>\n<p>这点事我们使用 Immutable.js 过程中遇到最大的问题。写代码要做思维上的转变。\n虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。\nImmutable 中的 Map 和 List 虽然对应原生 Object 和 Array，但操作非常不同，比如你要用 <code>map.get('key')</code> 而不是<code>map.key</code>, <code>arr.get(0)</code>而不是 <code>array[0]</code>。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。\n当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。\n下面给出一些办法来避免类似问题发生：</p>\n<ul>\n<li>使用 Flow 或 TypeScript 这类有静态类型检查的工具</li>\n<li>约定变量命名规则：如所有 Immutable 类型对象以 开头。</li>\n<li>使用 <code>Immutable.fromJS</code> 而不是 <code>Immutable.Map</code> 或 <code>Immutable.List</code>来创建对象，这样可以避免 Immutable 和原生对象间混用。</li>\n</ul>\n<h2>4. 更多认识</h2>\n<h3>4.1 Immutable.js</h3>\n<p>两个 immutable 对象可以使用 <code>===</code> 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回 <code>false</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">let</span> map1 = Immutable.Map({ <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">1</span> });\n<span class=\"hljs-keyword\">let</span> map2 = Immutable.Map({ <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">1</span> });\nmap1 === map2; <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p>为了直接比较对象的值，immutable.js 提供了 <code>Immutable.is</code> 来做 “值比较”， 结果如下：</p>\n<pre class=\"hljs\"><code>Immutable.is(map1, map2); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p><code>Immutable.is</code> 比较的是两个对象的 <code>hashCode</code> 或 <code>valueOf</code> （对于JavaScript对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象 <code>hashCode</code> 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\n后面会使用 <code>Immutable.is</code> 来减少 React 重复渲染，提高性能。\n另外，还有 mori、cortex 等，因为类似就不再介绍。</p>\n<h3>4.2 与 Object.freeze、const 区别</h3>\n<p><code>Object.freeze</code> 和 ES6 中新加入的 <code>const</code> 都可以达到防止对象被篡改的功能，但它们是shallowCopy 的。对象层级一深就要特殊处理了。</p>\n<h3>4.3 Cursor 的概念</h3>\n<p>这个 Cursor 和数据库中的游标是完全不同的概念。\n由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Immutable <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> Cursor <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable/contrib/cursor&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> data = Immutable.froomJS({ <span class=\"hljs-attr\">a</span>: { <span class=\"hljs-attr\">b</span>: { <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">1</span> } } });\n<span class=\"hljs-comment\">// 让 cursor 指向 { c: 1}</span>\n<span class=\"hljs-keyword\">let</span> cursor = Cursor.from(data, [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>], <span class=\"hljs-function\"><span class=\"hljs-params\">newData</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// 当 cursor 或其子 cursor 执行 update 时调用</span>\n    <span class=\"hljs-built_in\">console</span>.log(newData);\n});\ncursor.get(<span class=\"hljs-string\">&#x27;c&#x27;</span>); <span class=\"hljs-comment\">// 1</span>\ncursor = cursor.update(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">1</span>);\ncursor.get(<span class=\"hljs-string\">&#x27;c&#x27;</span>); <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<h2>5. 实践</h2>\n<h3>5.1 与 React 搭配使用，Pure Render</h3>\n<p>熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 <code>shouldComponentUpdate()</code> ，但它默认返回 <code>true</code>，即始终会执行 <code>render()</code>方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。\n当然我们也可以在 <code>shouldComponentUpdate()</code> 中使用 deepCopy 和 deepCompare 来避免吴彪要的 <code>render()</code>, 但 deepCopy 和 deepCompare 一般都是非常耗性能的。\nImmutable 则提供了简洁高效的判断数据是否变化的方法， 只需 <code>===</code> 和 <code>is</code> 比较就能知道是否需要执行<code>render()</code>， 而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 <code>shouldComponentUpdate</code> 是这样的：</p>\n<pre class=\"hljs\"><code>immport { is }  <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable&#x27;</span>;\nshouldComponentUpdate (nextProps = {}, nextState = {}) {\n    <span class=\"hljs-keyword\">const</span> thisProps = <span class=\"hljs-built_in\">this</span>.props || {}, thisState = <span class=\"hljs-built_in\">this</span>.state || {};\n    \n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Object</span>.keys(thisProps).length !== <span class=\"hljs-built_in\">Object</span>.keys(nextProps).length ||\n        <span class=\"hljs-built_in\">Object</span>.keys(thisProps).length !== <span class=\"hljs-built_in\">Object</span>.keys(nextProps).length\n    ){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> nextProps) {\n        <span class=\"hljs-keyword\">if</span> (thisProps[key] !== nextProps[key] || !is(thisProps[key], nextProps[key])) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n    }\n    \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> nextProps) {\n        <span class=\"hljs-keyword\">if</span> (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n<p>使用 Immutable 后， 如下图，当红色节点的 state 变化后，不会再渲染树种的所有节点，而是只渲图中绿色的部分：\n<img src=\"/assets/blog/context/2019-12-18-immutable-react/005a24678dc39c202dbf3d1df96da13e_hd.jpg\" alt=\"image.png\">\n你也可以借助 <code>React.addons.PureRenderMixin</code> 或支持 class 语法的 pure-render-decorator 来实现。</p>\n<h4>5.1.1 setState 的一个技巧</h4>\n<p>React 建议把 <code>this.state</code> 当作 Immutable 的，因此修改前需要做一个 deepCopy，显得麻烦：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;_&#x27;</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> Component = React.createClass({\n    <span class=\"hljs-function\"><span class=\"hljs-title\">getInitialState</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">data</span>: { <span class=\"hljs-attr\">times</span>: <span class=\"hljs-number\">0</span> }\n        }\n    },\n    <span class=\"hljs-function\"><span class=\"hljs-title\">handleAdd</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">let</span> data = _.cloneDeep(<span class=\"hljs-built_in\">this</span>.state.data);\n        data.times = data.times + <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-built_in\">this</span>.setState({ <span class=\"hljs-attr\">data</span>: data });\n        <span class=\"hljs-comment\">// 如果上面不做 cloneDeep， 下面打印的结果会是已经加 1 后的值。</span>\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.state.data.times);\n    }\n})\n</code></pre>\n<p>使用 Immutable 后：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-title\">getInitialState</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">data</span>: <span class=\"hljs-built_in\">Map</span>({ <span class=\"hljs-attr\">times</span>: <span class=\"hljs-number\">0</span> })\n    }\n},\n<span class=\"hljs-function\"><span class=\"hljs-title\">handleAdd</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.setState({ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-built_in\">this</span>.state.data.update(<span class=\"hljs-string\">&#x27;times&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v + <span class=\"hljs-number\">1</span>) });\n    <span class=\"hljs-comment\">// 这时的 times 并不会改变</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.state.data.get(<span class=\"hljs-string\">&#x27;times&#x27;</span>));\n}\n</code></pre>\n<p>上面的 <code>handleAdd</code> 可以简写成：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-title\">handleAdd</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">{data}</span>) =&gt;</span> ({\n        <span class=\"hljs-attr\">data</span>: data.updata(<span class=\"hljs-string\">&#x27;times&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v + <span class=\"hljs-number\">1</span>)\n    }))\n}\n</code></pre>\n<h3>5.2 与 Flux 搭配使用</h3>\n<p>由于 Flux 并没有限定 Store 中数据的类型，使用 Immutable 非常简单。\n现在是实现一个类似带有添加和撤销功能的Store：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-built_in\">Map</span>, OrderedMap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;immutable&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> todos = OrderedMap();\n<span class=\"hljs-keyword\">let</span> history = []; <span class=\"hljs-comment\">// 普通数组，存放每次操作后产生的数据</span>\n<span class=\"hljs-keyword\">let</span> TodoStore = createStore({\n    <span class=\"hljs-function\"><span class=\"hljs-title\">getAll</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">return</span> todos;\n    }\n});\nDispatcher.register(<span class=\"hljs-function\"><span class=\"hljs-params\">action</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (action.actionType === <span class=\"hljs-string\">&#x27;create&#x27;</span>) {\n        <span class=\"hljs-keyword\">let</span> id = createGUID();\n        history.push(todos); <span class=\"hljs-comment\">// 记录当前操作前的数据，便于撤销</span>\n        todos = todos.set(id, <span class=\"hljs-built_in\">Map</span>({\n            <span class=\"hljs-attr\">id</span>: id,\n            <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-literal\">false</span>,\n            <span class=\"hljs-attr\">text</span>: action.text.trim() <span class=\"hljs-comment\">// 注: trim() 方法是去掉字符串前后空格的方法</span>\n        }));\n        TodoStore.emitChange();\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (action.actionType === <span class=\"hljs-string\">&#x27;undo&#x27;</span>) {\n        <span class=\"hljs-comment\">// 这里是撤销功能实现，</span>\n        <span class=\"hljs-comment\">// 只需要从 history 数组中取一次 todos 即可</span>\n        <span class=\"hljs-keyword\">if</span> (history.length &gt; <span class=\"hljs-number\">0</span>) {\n            todos = history.pop();\n        }\n        TodoStore.emitChange();\n    }\n})\n</code></pre>\n<h3>5.3 与 Redux 搭配使用</h3>\n<p>Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store， 数据操作通过 Reducer 中实现；同时它提供了更简洁和清晰的单项数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。\n由于 Redux 中内置的 <code>combineReducers</code> 和 reducer 中的 <code>initialState</code> 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。\n幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 <code>combineReducers</code> 或使用 redux-immutablejs 来提供支持。\n上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。</p>\n<h2>6. 总结</h2>\n<p>Immutable 可以给应用带来极大的性能提升，但是否使用还是要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外接口中。\n如果 JS 原生 Immutable 类型会不会太美，被称为 React API 终结者的 Sebastion Markbage 有一个这样的提案，能否通过现在还不确定。不过可以肯定的是 Immutable 会被越来越多的项目使用。\n（完）\n参考来源：<a href=\"https://zhuanlan.zhihu.com/p/20295971\">https://zhuanlan.zhihu.com/p/20295971</a></p>\n","ogImage":{"url":"/assets/blog/cover/2019-12-18-immutable-react.gif"},"coverImage":"/assets/blog/cover/2019-12-18-immutable-react.gif"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":7,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":4,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]}}},"__N_SSG":true}