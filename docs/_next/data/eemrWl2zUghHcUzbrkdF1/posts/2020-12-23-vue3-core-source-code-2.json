{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","slug":"2020-12-21-vue3-core-source-code-1"},"nextPost":{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","slug":"2020-12-24-vue3-core-source-code-3"}},"post":{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","description":"组件渲染：vnode 到真实 DOM 是如何转变的？","keyword":"vue,vue3.0,源码","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>上一篇文章我们梳理了组件选渲染的过程，本质上就是把各种类的 vnode 渲染成真实 DOM。我们也知道了组件就是由模板、组件描述对象和数据构成的，数据的变化会影响组件的变化。组件的渲染过程中创建了一个带副作用的渲染函数，当数据变化的时候就会执行这个渲染函数来触发组件的更新。那么接下来，我们就具体分析一下组件的更新过程。</p>\n<h2>1 副作用函数更新组件过程</h2>\n<p>我们先回顾一下带副作用的渲染函数 setupRenderEffect 的实现，但是这次我们要重点关注更新组件部分的逻辑：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> setupRenderEffect = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  instance,\n  initialVNode,\n  container,\n  anchor,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 创建响应式的副作用渲染函数</span>\n  instance.update = effect(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">componentEffect</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (!instance.isMounted) {\n      <span class=\"hljs-comment\">// 渲染组件</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 更新组件</span>\n      <span class=\"hljs-keyword\">let</span> { next, vnode } = instance;\n      <span class=\"hljs-comment\">// next 表示新的组件 vnode</span>\n      <span class=\"hljs-keyword\">if</span> (next) {\n        <span class=\"hljs-comment\">// 更新组件 vnode 节点信息</span>\n        updateComponentPreRender(instance, next, optimized);\n      } <span class=\"hljs-keyword\">else</span> {\n        next = vnode;\n      }\n      <span class=\"hljs-comment\">// 渲染新的子树 vnode</span>\n      <span class=\"hljs-keyword\">const</span> nextTree = renderComponentRoot(instance);\n      <span class=\"hljs-comment\">// 缓存旧的子树 vnode</span>\n      <span class=\"hljs-keyword\">const</span> prevTree = instance.subTree;\n      <span class=\"hljs-comment\">// 更新子树 vnode</span>\n      instance.subTree = nextTree;\n      <span class=\"hljs-comment\">// 组件更新核心逻辑，根据新旧子树 vnode 做 patch</span>\n      patch(\n        prevTree,\n        nextTree,\n        <span class=\"hljs-comment\">// 如果在 teleport 组件中父节点可能已经改变，所以容器直接找旧树 DOM 元素的父节点</span>\n        hostParentNode(prevTree.el),\n        <span class=\"hljs-comment\">// 参考节点在 fragment 的情况可能改变，所以直接找旧树 DOM 元素的下一个节点</span>\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG\n      );\n      <span class=\"hljs-comment\">// 缓存更新后的 DOM 节点</span>\n      next.el = nextTree.el;\n    }\n  }, prodEffectOptions);\n};\n</code></pre>\n<p>可以看到，更新组件主要做三件事情：更新组件 vnode 节点、渲染新的子树 vnode、根据新旧子树 vnode 执行 patch 逻辑。</p>\n<p>首先是更新组件 vnode 节点，这里会有一个条件判断，判断组件实例中是否有新的组件 vnode（用 next 表示），有则更新组件 vnode，没有 next 指向之前的组件 vnode。为什么需要判断，这其实涉及一个组件更新策略的逻辑，我们稍后会讲。</p>\n<p>接着是渲染新的子树 vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树 vnode 也会发生相应的变化。</p>\n<p>最后就是核心的 patch 逻辑，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM，接下来我们就来分析这个过程。</p>\n<h2>2 核心逻辑：patch 流程</h2>\n<p>我们先来看 patch 流程的实现代码：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> patch = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  container,\n  anchor = <span class=\"hljs-literal\">null</span>,\n  parentComponent = <span class=\"hljs-literal\">null</span>,\n  parentSuspense = <span class=\"hljs-literal\">null</span>,\n  isSVG = <span class=\"hljs-literal\">false</span>,\n  optimized = <span class=\"hljs-literal\">false</span>\n</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点</span>\n  <span class=\"hljs-keyword\">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1);\n    unmount(n1, parentComponent, parentSuspense, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-comment\">// n1 设置为 null 保证后续都走 mount 逻辑</span>\n    n1 = <span class=\"hljs-literal\">null</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> { type, shapeFlag } = n2;\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> Text:\n      <span class=\"hljs-comment\">// 处理文本节点</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> Comment:\n      <span class=\"hljs-comment\">// 处理注释节点</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> Static:\n      <span class=\"hljs-comment\">// 处理静态节点</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> Fragment:\n      <span class=\"hljs-comment\">// 处理 Fragment 元素</span>\n      <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* ELEMENT */</span>) {\n        <span class=\"hljs-comment\">// 处理普通 DOM 元素</span>\n        processElement(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        );\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">6</span> <span class=\"hljs-comment\">/* COMPONENT */</span>) {\n        <span class=\"hljs-comment\">// 处理组件</span>\n        processComponent(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        );\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">64</span> <span class=\"hljs-comment\">/* TELEPORT */</span>) {\n        <span class=\"hljs-comment\">// 处理 TELEPORT</span>\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">128</span> <span class=\"hljs-comment\">/* SUSPENSE */</span>) {\n        <span class=\"hljs-comment\">// 处理 SUSPENSE</span>\n      }\n  }\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isSameVNodeType</span>(<span class=\"hljs-params\">n1, n2</span>) </span>{\n  <span class=\"hljs-comment\">// n1 和 n2 节点的 type 和 key 都相同，才是相同节点</span>\n  <span class=\"hljs-keyword\">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key;\n}\n</code></pre>\n<p>在这个过程中，首先判断新旧节点是否是相同的 vnode 类型，如果不同，比如一个 div 更新成一个 ul，那么最简单的操作就是删除旧的 div 节点，再去挂载新的 ul 节点。</p>\n<p>如果是相同的 vnode 类型，就需要走 diff 更新流程了，接着会根据不同的 vnode 类型执行不同的处理逻辑，这里我们仍然只分析普通元素类型和组件类型的处理过程。</p>\n<h3>2.1 处理组件</h3>\n<p>如何处理组件的呢？举个例子，我们在父组件 App 中里引入了 Hello 组件：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>This is an app.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">hello</span> <span class=\"hljs-attr\">:msg</span>=<span class=\"hljs-string\">&quot;msg&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">hello</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&#x27;Vue&#x27;</span>\n      }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n      <span class=\"hljs-function\"><span class=\"hljs-title\">toggle</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">this</span>.msg ==== <span class=\"hljs-string\">&#x27;Vue&#x27;</span>? <span class=\"hljs-string\">&#x27;World&#x27;</span>: <span class=\"hljs-string\">&#x27;Vue&#x27;</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>Hello 组件中是 <code>&lt;div&gt;</code> 包裹着一个 <code>&lt;p&gt;</code> 标签， 如下所示：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;hello&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello, {{msg}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">String</span>\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>点击 App 组件中的按钮执行 toggle 函数，就会修改 data 中的 msg，并且会触发 App 组件的重新渲染。</p>\n<p>结合前面对渲染函数的流程分析，这里 App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，应该先走 processElement 逻辑。组件的更新最终还是要转换成内部真实 DOM 的更新，而实际上普通元素的处理流程才是真正做 DOM 的更新，由于稍后我们会详细分析普通元素的处理流程，所以我们先跳过这里，继续往下看。</p>\n<p>和渲染过程类似，更新过程也是一个树的深度优先遍历过程，更新完当前节点后，就会遍历更新它的子节点，因此在遍历的过程中会遇到 hello 这个组件 vnode 节点，就会执行到 processComponent 处理逻辑中，我们再来看一下它的实现，我们重点关注一下组件更新的相关逻辑：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> processComponent = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  container,\n  anchor,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (n1 == <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-comment\">// 挂载组件</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 更新子组件</span>\n    updateComponent(n1, n2, parentComponent, optimized);\n  }\n};\n<span class=\"hljs-keyword\">const</span> updateComponent = <span class=\"hljs-function\">(<span class=\"hljs-params\">n1, n2, parentComponent, optimized</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> instance = (n2.component = n1.component);\n  <span class=\"hljs-comment\">// 根据新旧子组件 vnode 判断是否需要更新子组件</span>\n  <span class=\"hljs-keyword\">if</span> (shouldUpdateComponent(n1, n2, parentComponent, optimized)) {\n    <span class=\"hljs-comment\">// 新的子组件 vnode 赋值给 instance.next</span>\n    instance.next = n2;\n    <span class=\"hljs-comment\">// 子组件也可能因为数据变化被添加到更新队列里了，移除它们防止对一个子组件重复更新</span>\n    invalidateJob(instance.update);\n    <span class=\"hljs-comment\">// 执行子组件的副作用渲染函数</span>\n    instance.update();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 不需要更新，只复制属性</span>\n    n2.component = n1.component;\n    n2.el = n1.el;\n  }\n};\n</code></pre>\n<p>可以看到，processComponent 主要通过执行 updateComponent 函数来更新子组件，updateComponent 函数在更新子组件的时候，会先执行 shouldUpdateComponent 函数，根据新旧子组件 vnode 来判断是否需要更新子组件。这里你只需要知道，在 shouldUpdateComponent 函数的内部，主要是通过检测和对比组件 vnode 中的 props、chidren、dirs、transiton 等属性，来决定子组件是否需要更新。</p>\n<p>这是很好理解的，因为在一个组件的子组件是否需要更新，我们主要依据子组件 vnode 是否存在一些会影响组件更新的属性变化进行判断，如果存在就会更新子组件。</p>\n<p>虽然 Vue.js 的更新粒度是组件级别的，组件的数据变化只会影响当前组件的更新，但是在组件更新的过程中，也会对子组件做一定的检查，判断子组件是否也要更新，并通过某种机制避免子组件重复更新。</p>\n<p>我们接着看 updateComponent 函数，如果 shouldUpdateComponent 返回 true ，那么在它的最后，先执行 invalidateJob（instance.update）避免子组件由于自身数据变化导致的重复更新，然后又执行了子组件的副作用渲染函数 instance.update 来主动触发子组件的更新。</p>\n<p>再回到副作用渲染函数中，有了前面的讲解，我们再看组件更新的这部分代码，就能很好地理解它的逻辑了：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 更新组件</span>\n<span class=\"hljs-keyword\">let</span> { next, vnode } = instance;\n<span class=\"hljs-comment\">// next 表示新的组件 vnode</span>\n<span class=\"hljs-keyword\">if</span> (next) {\n  <span class=\"hljs-comment\">// 更新组件 vnode 节点信息</span>\n  updateComponentPreRender(instance, next, optimized);\n} <span class=\"hljs-keyword\">else</span> {\n  next = vnode;\n}\n<span class=\"hljs-keyword\">const</span> updateComponentPreRender = <span class=\"hljs-function\">(<span class=\"hljs-params\">instance, nextVNode, optimized</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 新组件 vnode 的 component 属性指向组件实例</span>\n  nextVNode.component = instance;\n  <span class=\"hljs-comment\">// 旧组件 vnode 的 props 属性</span>\n  <span class=\"hljs-keyword\">const</span> prevProps = instance.vnode.props;\n  <span class=\"hljs-comment\">// 组件实例的 vnode 属性指向新的组件 vnode</span>\n  instance.vnode = nextVNode;\n  <span class=\"hljs-comment\">// 清空 next 属性，为了下一次重新渲染准备</span>\n  instance.next = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-comment\">// 更新 props</span>\n  updateProps(instance, nextVNode.props, prevProps, optimized);\n  <span class=\"hljs-comment\">// 更新 插槽</span>\n  updateSlots(instance, nextVNode.children);\n};\n</code></pre>\n<p>结合上面的代码，我们在更新组件的 DOM 前，需要先更新组件 vnode 节点信息，包括更改组件实例的 vnode 指针、更新 props 和更新插槽等一系列操作，因为组件在稍后执行 renderComponentRoot 时会重新渲染新的子树 vnode ，它依赖了更新后的组件 vnode 中的 props 和 slots 等数据。</p>\n<p>所以我们现在知道了一个组件重新渲染可能会有两种场景，一种是组件本身的数据变化，这种情况下 next 是 null；另一种是父组件在更新的过程中，遇到子组件节点，先判断子组件是否需要更新，如果需要则主动执行子组件的重新渲染方法，这种情况下 next 就是新的子组件 vnode。</p>\n<p>你可能还会有疑问，这个子组件对应的新的组件 vnode 是什么时候创建的呢？答案很简单，它是在父组件重新渲染的过程中，通过 renderComponentRoot 渲染子树 vnode 的时候生成，因为子树 vnode 是个树形结构，通过遍历它的子节点就可以访问到其对应的组件 vnode。再拿我们前面举的例子说，当 App 组件重新渲染的时候，在执行 renderComponentRoot 生成子树 vnode 的过程中，也生成了 hello 组件对应的新的组件 vnode。</p>\n<p>所以 processComponent 处理组件 vnode，本质上就是去判断子组件是否需要更新，如果需要则递归执行子组件的副作用渲染函数来更新，否则仅仅更新一些 vnode 的属性，并让子组件实例保留对组件 vnode 的引用，用于子组件自身数据变化引起组件重新渲染的时候，在渲染函数内部可以拿到新的组件 vnode。</p>\n<p>前面也说过，组件是抽象的，组件的更新最终还是会落到对普通 DOM 元素的更新。所以接下来我们详细分析一下组件更新中对普通元素的处理流程。</p>\n<h3>2.2 处理普通元素</h3>\n<p>我们再来看如何处理普通元素，我把之前的示例稍加修改，将其中的 Hello 组件删掉，如下所示：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>This is {{msg}}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;toggle&quot;</span>&gt;</span>Toggle msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&#x27;Vue&#x27;</span>\n      }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n      <span class=\"hljs-function\"><span class=\"hljs-title\">toggle</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-string\">&#x27;Vue&#x27;</span>? <span class=\"hljs-string\">&#x27;World&#x27;</span>: <span class=\"hljs-string\">&#x27;Vue&#x27;</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>当我们点击 App 组件中的按钮会执行 toggle 函数，然后修改 data 中的 msg，这就触发了 App 组件的重新渲染。</p>\n<p>App 组件的根节点是 div 标签，重新渲染的子树 vnode 节点是一个普通元素的 vnode，所以应该先走 processElement 逻辑，我们来看这个函数的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> processElement = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  container,\n  anchor,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  isSVG = isSVG || n2.type === <span class=\"hljs-string\">&quot;svg&quot;</span>;\n  <span class=\"hljs-keyword\">if</span> (n1 == <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-comment\">// 挂载元素</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 更新元素</span>\n    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);\n  }\n};\n<span class=\"hljs-keyword\">const</span> patchElement = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> el = (n2.el = n1.el);\n  <span class=\"hljs-keyword\">const</span> oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ;\n  <span class=\"hljs-keyword\">const</span> newProps = n2.props || EMPTY_OBJ;\n  <span class=\"hljs-comment\">// 更新 props</span>\n  patchProps(\n    el,\n    n2,\n    oldProps,\n    newProps,\n    parentComponent,\n    parentSuspense,\n    isSVG\n  );\n  <span class=\"hljs-keyword\">const</span> areChildrenSVG = isSVG &amp;&amp; n2.type !== <span class=\"hljs-string\">&quot;foreignObject&quot;</span>;\n  <span class=\"hljs-comment\">// 更新子节点</span>\n  patchChildren(\n    n1,\n    n2,\n    el,\n    <span class=\"hljs-literal\">null</span>,\n    parentComponent,\n    parentSuspense,\n    areChildrenSVG\n  );\n};\n</code></pre>\n<p>可以看到，更新元素的过程主要做两件事情：更新 props 和更新子节点。其实这是很好理解的，因为一个 DOM 节点元素就是由它自身的一些属性和子节点构成的。</p>\n<p>首先是更新 props，这里的 patchProps 函数就是在更新 DOM 节点的 class、style、event 以及其它的一些 DOM 属性，这个过程我不再深入分析了，感兴趣的朋友可以自己看这部分代码。</p>\n<p>其次是更新子节点，我们来看一下这里的 patchChildren 函数的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> patchChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  container,\n  anchor,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized = <span class=\"hljs-literal\">false</span>\n</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> c1 = n1 &amp;&amp; n1.children;\n  <span class=\"hljs-keyword\">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">const</span> c2 = n2.children;\n  <span class=\"hljs-keyword\">const</span> { shapeFlag } = n2;\n  <span class=\"hljs-comment\">// 子节点有 3 种可能情况：文本、数组、空</span>\n  <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* TEXT_CHILDREN */</span>) {\n    <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n      <span class=\"hljs-comment\">// 数组 -&gt; 文本，则删除之前的子节点</span>\n      unmountChildren(c1, parentComponent, parentSuspense);\n    }\n    <span class=\"hljs-keyword\">if</span> (c2 !== c1) {\n      <span class=\"hljs-comment\">// 文本对比不同，则替换为新文本</span>\n      hostSetElementText(container, c2);\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n      <span class=\"hljs-comment\">// 之前的子节点是数组</span>\n      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n        <span class=\"hljs-comment\">// 新的子节点仍然是数组，则做完整地 diff</span>\n        patchKeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        );\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 数组 -&gt; 空，则仅仅删除之前的子节点</span>\n        unmountChildren(c1, parentComponent, parentSuspense, <span class=\"hljs-literal\">true</span>);\n      }\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 之前的子节点是文本节点或者为空</span>\n      <span class=\"hljs-comment\">// 新的子节点是数组或者为空</span>\n      <span class=\"hljs-keyword\">if</span> (prevShapeFlag &amp; <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* TEXT_CHILDREN */</span>) {\n        <span class=\"hljs-comment\">// 如果之前子节点是文本，则把它清空</span>\n        hostSetElementText(container, <span class=\"hljs-string\">&quot;&quot;</span>);\n      }\n      <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n        <span class=\"hljs-comment\">// 如果新的子节点是数组，则挂载新子节点</span>\n        mountChildren(\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        );\n      }\n    }\n  }\n};\n</code></pre>\n<p>对于一个元素的子节点 vnode 可能会有三种情况：纯文本、vnode 数组和空。那么根据排列组合对于新旧子节点来说就有九种情况，我们可以通过三张图来表示。</p>\n<p>首先来看一下旧子节点是纯文本的情况：</p>\n<ul>\n<li>如果新子节点也是纯文本，那么做简单地文本替换即可；</li>\n<li>如果新子节点是空，那么删除旧子节点即可；</li>\n<li>如果新子节点是 vnode 数组，那么先把旧子节点的文本清空，再去旧子节点的父容器下添加多个新子节点。</li>\n</ul>\n<p><img src=\"/assets/blog/context/2020-12-23-vue3-core-source-code-2/Ciqc1F8MBDWAfUAXAADe59XvjHY701.png\" alt=\"image.png\">\n接下来看一下旧子节点是空的情况：</p>\n<ul>\n<li>如果新子节点是纯文本，那么在旧子节点的父容器下添加新文本节点即可；</li>\n<li>如果新子节点也是空，那么什么都不需要做；</li>\n<li>如果新子节点是 vnode 数组，那么直接去旧子节点的父容器下添加多个新子节点即可。</li>\n</ul>\n<p><img src=\"/assets/blog/context/2020-12-23-vue3-core-source-code-2/CgqCHl8MBEOANnFmAADYr-_R5mM894.png\" alt=\"image.png\">\n最后来看一下旧子节点是 vnode 数组的情况：</p>\n<ul>\n<li>如果新子节点是纯文本，那么先删除旧子节点，再去旧子节点的父容器下添加新文本节点；</li>\n<li>如果新子节点是空，那么删除旧子节点即可；</li>\n<li>如果新子节点也是 vnode 数组，那么就需要做完整的 diff 新旧子节点了，这是最复杂的情况，内部运用了核心 diff 算法。</li>\n</ul>\n<p><img src=\"/assets/blog/context/2020-12-23-vue3-core-source-code-2/CgqCHl8MBCuAUZksAADplAU2718113.png\" alt=\"image.png\"></p>\n<p>下一篇我们就来深入探究一下这个复杂的 diff 算法。</p>\n<blockquote>\n<p><strong>本文的相关代码在源代码中的位置如下：</strong><br>\npackages/runtime-core/src/renderer.ts<br>\npackages/runtime-core/src/componentRenderUtils.ts</p>\n</blockquote>\n","ogImage":{"url":"/assets/blog/cover/2020-12-23-vue3-core-source-code-2.png"},"coverImage":"/assets/blog/cover/2020-12-23-vue3-core-source-code-2.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}