{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","slug":"2021-01-25-vue3-core-source-code-25"},"nextPost":{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","slug":"2021-01-27-vue3-core-source-code-27"}},"post":{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","description":"Vue Router：如何实现一个前端路由？（上）","keyword":"vue,vue3.0,源码","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>相信对有一定基础的前端开发工程师来说，路由并不陌生，它最初源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p>\n<p>而在 Web 前端单页应用 SPA 中，路由描述的是 URL 与视图之间的映射关系，这种映射是单向的，即 URL 变化会引起视图的更新。</p>\n<p>相比于后端路由，前端路由的好处是无须刷新页面，减轻了服务器的压力，提升了用户体验。目前主流支持单页应用的前端框架，基本都有配套的或第三方的路由系统。相应的，Vue.js 也提供了官方前端路由实现 Vue Router，那么本篇我们就来学习它的实现原理。</p>\n<blockquote>\n<p>Vue.js 3.0 配套的 Vue Router 源码在<a href=\"https://github.com/vuejs/vue-router-next\">这里</a>，建议你学习前先把源码 clone 下来。如果你还不会使用路由，建议你先看它的<a href=\"https://next.router.vuejs.org/\">官网文档</a>，会使用后再来深入学习本篇内容。</p>\n</blockquote>\n<h2>1 路由的基本用法</h2>\n<p>我们先通过一个简单地示例来看路由的基本用法，希望你也可以使用 Vue cli 脚手架创建一个 Vue.js 3.0 的项目，并安装 4.x 版本的 Vue Router 把项目跑起来。</p>\n<p>注意，为了让 Vue.js 可以在线编译模板，你需要在根目录下配置 vue.config.js，并且设置 runtimeCompiler 为 true：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">runtimeCompiler</span>: <span class=\"hljs-literal\">true</span>,\n};\n</code></pre>\n<p>然后我们修改页面的 HTML 模板，加上如下代码：</p>\n<pre class=\"hljs\"><code>&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello App!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/&quot;</span>&gt;</span>Go to Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/about&quot;</span>&gt;</span>Go to About<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span></span>\n&lt;/div&gt;\n</code></pre>\n<p>其中，RouterLink 和 RouterView 是 Vue Router 内置的组件。</p>\n<p>RouterLink 表示路由的导航组件，我们可以配置 to 属性来指定它跳转的链接，它最终会在页面上渲染生成 a 标签。</p>\n<p>RouterView 表示路由的视图组件，它会渲染路径对应的 Vue 组件，也支持嵌套。</p>\n<p>RouterLink 和 RouterView 的具体实现，我们会放到后面去分析。</p>\n<p>有了模板之后，我们接下来看如何初始化路由：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { createApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createRouter, createWebHashHistory } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue-router&quot;</span>;\n<span class=\"hljs-comment\">// 1. 定义路由组件</span>\n<span class=\"hljs-keyword\">const</span> Home = { <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&quot;&lt;div&gt;Home&lt;/div&gt;&quot;</span> };\n<span class=\"hljs-keyword\">const</span> About = { <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&quot;&lt;div&gt;About&lt;/div&gt;&quot;</span> };\n<span class=\"hljs-comment\">// 2. 定义路由配置，每个路径映射一个路由视图组件</span>\n<span class=\"hljs-keyword\">const</span> routes = [\n  { <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">component</span>: Home },\n  { <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/about&quot;</span>, <span class=\"hljs-attr\">component</span>: About },\n];\n<span class=\"hljs-comment\">// 3. 创建路由实例，可以指定路由模式，传入路由配置对象</span>\n<span class=\"hljs-keyword\">const</span> router = createRouter({\n  <span class=\"hljs-attr\">history</span>: createWebHistory(),\n  routes,\n});\n<span class=\"hljs-comment\">// 4. 创建 app 实例</span>\n<span class=\"hljs-keyword\">const</span> app = createApp({});\n<span class=\"hljs-comment\">// 5. 在挂载页面 之前先安装路由</span>\napp.use(router);\n<span class=\"hljs-comment\">// 6. 挂载页面</span>\napp.mount(<span class=\"hljs-string\">&quot;#app&quot;</span>);\n</code></pre>\n<p>可以看到，路由的初始化过程很简单，首先需要定义一个路由配置，这个配置主要用于描述路径和组件的映射关系，即什么路径下 RouterView 应该渲染什么路由组件。</p>\n<p>接着创建路由对象实例，传入路由配置对象，并且也可以指定路由模式，Vue Router 目前支持三种模式，hash 模式，HTML5 模式和 memory 模式，我们常用的是前两种模式。</p>\n<p>最后在挂载页面前，我们需要安装路由，这样我们就可以在各个组件中访问路由对象以及使用路由的内置组件 RouterLink 和 RouterView 了。</p>\n<p>知道了 Vue Router 的基本用法后，接下来我们就可以探究它的实现原理了。由于 Vue Router 源码加起来有几千行，限于篇幅，我会把重点放在整体的实现流程上，不会讲实现的细节。</p>\n<h2>2 路由的实现原理</h2>\n<p>我们先从用户使用的角度来分析，先从路由对象的创建过程开始。</p>\n<h3>2.1 路由对象的创建</h3>\n<p>Vue Router 提供了一个 createRouter API，你可以通过它来创建一个路由对象，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createRouter</span>(<span class=\"hljs-params\">options</span>) </span>{\n  <span class=\"hljs-comment\">// 定义一些辅助方法和变量</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// 创建 router 对象</span>\n  <span class=\"hljs-keyword\">const</span> router = {\n    <span class=\"hljs-comment\">// 当前路径</span>\n    currentRoute,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    <span class=\"hljs-attr\">back</span>: <span class=\"hljs-function\">() =&gt;</span> go(-<span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">forward</span>: <span class=\"hljs-function\">() =&gt;</span> go(<span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">beforeEach</span>: beforeGuards.add,\n    <span class=\"hljs-attr\">beforeResolve</span>: beforeResolveGuards.add,\n    <span class=\"hljs-attr\">afterEach</span>: afterGuards.add,\n    <span class=\"hljs-attr\">onError</span>: errorHandlers.add,\n    isReady,\n    <span class=\"hljs-function\"><span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">app</span>)</span> {\n      <span class=\"hljs-comment\">// 安装路由函数</span>\n    },\n  };\n  <span class=\"hljs-keyword\">return</span> router;\n}\n</code></pre>\n<p>我们省略了大部分代码，只保留了路由对象相关的代码，可以看到路由对象 router 就是一个对象，它维护了当前路径 currentRoute，且拥有很多辅助方法。</p>\n<p>目前你只需要了解这么多，创建完路由对象后，我们现在来安装它。</p>\n<h3>2.2 路由的安装</h3>\n<p>Vue Router 作为 Vue 的插件，当我们执行 app.use(router) 的时候，实际上就是在执行 router 的 install 方法来安装路由，并把 app 作为参数传入，来看它的定义：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> router = {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">app</span>)</span> {\n    <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-comment\">// 注册路由组件</span>\n    app.component(<span class=\"hljs-string\">&quot;RouterLink&quot;</span>, RouterLink);\n    app.component(<span class=\"hljs-string\">&quot;RouterView&quot;</span>, RouterView);\n    <span class=\"hljs-comment\">// 全局配置定义 $router 和 $route</span>\n    app.config.globalProperties.$router = router;\n    <span class=\"hljs-built_in\">Object</span>.defineProperty(app.config.globalProperties, <span class=\"hljs-string\">&quot;$route&quot;</span>, {\n      <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> unref(currentRoute),\n    });\n    <span class=\"hljs-comment\">// 在浏览器端初始化导航</span>\n    <span class=\"hljs-keyword\">if</span> (\n      isBrowser &amp;&amp;\n      !started &amp;&amp;\n      currentRoute.value === START_LOCATION_NORMALIZED\n    ) {\n      <span class=\"hljs-comment\">// see above</span>\n      started = <span class=\"hljs-literal\">true</span>;\n      push(routerHistory.location).catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> {\n        warn(<span class=\"hljs-string\">&quot;Unexpected error when starting the router:&quot;</span>, err);\n      });\n    }\n    <span class=\"hljs-comment\">// 路径变成响应式</span>\n    <span class=\"hljs-keyword\">const</span> reactiveRoute = {};\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> START_LOCATION_NORMALIZED) {\n      reactiveRoute[key] = computed(<span class=\"hljs-function\">() =&gt;</span> currentRoute.value[key]);\n    }\n    <span class=\"hljs-comment\">// 全局注入 router 和 reactiveRoute</span>\n    app.provide(routerKey, router);\n    app.provide(routeLocationKey, reactive(reactiveRoute));\n    <span class=\"hljs-keyword\">let</span> unmountApp = app.unmount;\n    installedApps.add(app);\n    <span class=\"hljs-comment\">// 应用卸载的时候，需要做一些路由清理工作</span>\n    app.unmount = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n      installedApps.delete(app);\n      <span class=\"hljs-keyword\">if</span> (installedApps.size &lt; <span class=\"hljs-number\">1</span>) {\n        removeHistoryListener();\n        currentRoute.value = START_LOCATION_NORMALIZED;\n        started = <span class=\"hljs-literal\">false</span>;\n        ready = <span class=\"hljs-literal\">false</span>;\n      }\n      unmountApp.call(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n    };\n  },\n};\n</code></pre>\n<p>路由的安装的过程我们需要记住以下两件事情。</p>\n<ol>\n<li>全局注册 RouterView 和 RouterLink 组件——这是你安装了路由后，可以在任何组件中去使用这俩个组件的原因，如果你使用 RouterView 或者 RouterLink 的时候收到提示不能解析 router-link 和 router-view，这说明你压根就没有安装路由。</li>\n<li>通过 provide 方式全局注入 router 对象和 reactiveRoute 对象，其中 router 表示用户通过 createRouter 创建的路由对象，我们可以通过它去动态操作路由，reactiveRoute 表示响应式的路径对象，它维护着路径的相关信息。</li>\n<li>那么至此我们就已经了解了路由对象的创建，以及路由的安装，但是前端路由的实现，还需要解决几个核心问题：路径是如何管理的，路径和路由组件的渲染是如何映射的。</li>\n</ol>\n<p>那么接下来，我们就来更细节地来看，依次来解决这两个问题。</p>\n<h3>2.3 路径的管理</h3>\n<p>路由的基础结构就是一个路径对应一种视图，当我们切换路径的时候对应的视图也会切换，因此一个很重要的方面就是对路径的管理。</p>\n<p>首先，我们需要维护当前的路径 currentRoute，可以给它一个初始值 START_LOCATION_NORMALIZED，如下：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> START_LOCATION_NORMALIZED = {\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">params</span>: {},\n  <span class=\"hljs-attr\">query</span>: {},\n  <span class=\"hljs-attr\">hash</span>: <span class=\"hljs-string\">&quot;&quot;</span>,\n  <span class=\"hljs-attr\">fullPath</span>: <span class=\"hljs-string\">&quot;/&quot;</span>,\n  <span class=\"hljs-attr\">matched</span>: [],\n  <span class=\"hljs-attr\">meta</span>: {},\n  <span class=\"hljs-attr\">redirectedFrom</span>: <span class=\"hljs-literal\">undefined</span>,\n};\n</code></pre>\n<p>可以看到，路径对象包含了非常丰富的路径信息，具体含义我就不在这多说了，你可以参考<a href=\"https://next.router.vuejs.org/api/#meta-3\">官方文档</a>。</p>\n<p>路由想要发生变化，就是通过改变路径完成的，路由对象提供了很多改变路径的方法，比如 router.push、router.replace，它们的底层最终都是通过 pushWithRedirect 完成路径的切换，我们来看一下它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pushWithRedirect</span>(<span class=\"hljs-params\">to, redirectedFrom</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> targetLocation = (pendingLocation = resolve(to));\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">from</span> = currentRoute.value;\n  <span class=\"hljs-keyword\">const</span> data = to.state;\n  <span class=\"hljs-keyword\">const</span> force = to.force;\n  <span class=\"hljs-keyword\">const</span> replace = to.replace === <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">const</span> toLocation = targetLocation;\n  toLocation.redirectedFrom = redirectedFrom;\n  <span class=\"hljs-keyword\">let</span> failure;\n  <span class=\"hljs-keyword\">if</span> (!force &amp;&amp; isSameRouteLocation(stringifyQuery$<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">from</span>, targetLocation)) {\n    failure = createRouterError(<span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* NAVIGATION_DUPLICATED */</span>, {\n      <span class=\"hljs-attr\">to</span>: toLocation,\n      <span class=\"hljs-keyword\">from</span>,\n    });\n    handleScroll(<span class=\"hljs-keyword\">from</span>, <span class=\"hljs-keyword\">from</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> (failure ? <span class=\"hljs-built_in\">Promise</span>.resolve(failure) : navigate(toLocation, <span class=\"hljs-keyword\">from</span>))\n    .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (\n        isNavigationFailure(\n          error,\n          <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">/* NAVIGATION_ABORTED */</span> |\n            <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* NAVIGATION_CANCELLED */</span> |\n            <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/* NAVIGATION_GUARD_REDIRECT */</span>\n        )\n      ) {\n        <span class=\"hljs-keyword\">return</span> error;\n      }\n      <span class=\"hljs-keyword\">return</span> triggerError(error);\n    })\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">failure</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (failure) {\n        <span class=\"hljs-comment\">// 处理错误</span>\n      } <span class=\"hljs-keyword\">else</span> {\n        failure = finalizeNavigation(toLocation, <span class=\"hljs-keyword\">from</span>, <span class=\"hljs-literal\">true</span>, replace, data);\n      }\n      triggerAfterEach(toLocation, <span class=\"hljs-keyword\">from</span>, failure);\n      <span class=\"hljs-keyword\">return</span> failure;\n    });\n}\n</code></pre>\n<p>我省略了一部分代码的实现，这里主要来看 pushWithRedirect 的核心思路，首先参数 to 可能有多种情况，可以是一个表示路径的字符串，也可以是一个路径对象，所以要先经过一层 resolve 返回一个新的路径对象，它比前面提到的路径对象多了一个 matched 属性，它的作用我们后续会介绍。</p>\n<p>得到新的目标路径后，接下来执行 navigate 方法，它实际上是执行路由切换过程中的一系列导航守卫函数，我们后续会介绍。navigate 成功后，会执行 finalizeNavigation 完成导航，在这里完成真正的路径切换，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">finalizeNavigation</span>(<span class=\"hljs-params\">toLocation, <span class=\"hljs-keyword\">from</span>, isPush, replace, data</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> error = checkCanceledNavigation(toLocation, <span class=\"hljs-keyword\">from</span>);\n  <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> error;\n  <span class=\"hljs-keyword\">const</span> isFirstNavigation = <span class=\"hljs-keyword\">from</span> === START_LOCATION_NORMALIZED;\n  <span class=\"hljs-keyword\">const</span> state = !isBrowser ? {} : history.state;\n  <span class=\"hljs-keyword\">if</span> (isPush) {\n    <span class=\"hljs-keyword\">if</span> (replace || isFirstNavigation)\n      routerHistory.replace(\n        toLocation.fullPath,\n        assign(\n          {\n            <span class=\"hljs-attr\">scroll</span>: isFirstNavigation &amp;&amp; state &amp;&amp; state.scroll,\n          },\n          data\n        )\n      );\n    <span class=\"hljs-keyword\">else</span> routerHistory.push(toLocation.fullPath, data);\n  }\n  currentRoute.value = toLocation;\n  handleScroll(toLocation, <span class=\"hljs-keyword\">from</span>, isPush, isFirstNavigation);\n  markAsReady();\n}\n</code></pre>\n<p>这里的 finalizeNavigation 函数，我们重点关注两个逻辑，一个是更新当前的路径 currentRoute 的值，一个是执行 routerHistory.push 或者是 routerHistory.replace 方法更新浏览器的 URL 的记录。</p>\n<p>每当我们切换路由的时候，会发现浏览器的 URL 发生了变化，但是页面却没有刷新，它是怎么做的呢？</p>\n<p>在我们创建 router 对象的时候，会创建一个 history 对象，前面提到 Vue Router 支持三种模式，这里我们重点分析 HTML5 的 history 的模式：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createWebHistory</span>(<span class=\"hljs-params\">base</span>) </span>{\n  base = normalizeBase(base);\n  <span class=\"hljs-keyword\">const</span> historyNavigation = useHistoryStateNavigation(base);\n  <span class=\"hljs-keyword\">const</span> historyListeners = useHistoryListeners(\n    base,\n    historyNavigation.state,\n    historyNavigation.location,\n    historyNavigation.replace\n  );\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">go</span>(<span class=\"hljs-params\">delta, triggerListeners = <span class=\"hljs-literal\">true</span></span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n  <span class=\"hljs-keyword\">const</span> routerHistory = assign(\n    {\n      <span class=\"hljs-comment\">// it&#x27;s overridden right after</span>\n      <span class=\"hljs-attr\">location</span>: <span class=\"hljs-string\">&quot;&quot;</span>,\n      base,\n      go,\n      <span class=\"hljs-attr\">createHref</span>: createHref.bind(<span class=\"hljs-literal\">null</span>, base),\n    },\n    historyNavigation,\n    historyListeners\n  );\n  <span class=\"hljs-built_in\">Object</span>.defineProperty(routerHistory, <span class=\"hljs-string\">&quot;location&quot;</span>, {\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> historyNavigation.location.value,\n  });\n  <span class=\"hljs-built_in\">Object</span>.defineProperty(routerHistory, <span class=\"hljs-string\">&quot;state&quot;</span>, {\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> historyNavigation.state.value,\n  });\n  <span class=\"hljs-keyword\">return</span> routerHistory;\n}\n</code></pre>\n<p>对于 routerHistory 对象而言，它有两个重要的作用，一个是路径的切换，一个是监听路径的变化。</p>\n<p>其中，路径切换主要通过 historyNavigation 来完成的，它是 useHistoryStateNavigation 函数的返回值，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useHistoryStateNavigation</span>(<span class=\"hljs-params\">base</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { history, location } = <span class=\"hljs-built_in\">window</span>;\n  <span class=\"hljs-keyword\">let</span> currentLocation = {\n    <span class=\"hljs-attr\">value</span>: createCurrentLocation(base, location),\n  };\n  <span class=\"hljs-keyword\">let</span> historyState = { <span class=\"hljs-attr\">value</span>: history.state };\n  <span class=\"hljs-keyword\">if</span> (!historyState.value) {\n    changeLocation(\n      currentLocation.value,\n      {\n        <span class=\"hljs-attr\">back</span>: <span class=\"hljs-literal\">null</span>,\n        <span class=\"hljs-attr\">current</span>: currentLocation.value,\n        <span class=\"hljs-attr\">forward</span>: <span class=\"hljs-literal\">null</span>,\n        <span class=\"hljs-attr\">position</span>: history.length - <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">replaced</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">scroll</span>: <span class=\"hljs-literal\">null</span>,\n      },\n      <span class=\"hljs-literal\">true</span>\n    );\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">changeLocation</span>(<span class=\"hljs-params\">to, state, replace</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> url =\n      createBaseLocation() +\n      <span class=\"hljs-comment\">// preserve any existing query when base has a hash</span>\n      (base.indexOf(<span class=\"hljs-string\">&quot;#&quot;</span>) &gt; -<span class=\"hljs-number\">1</span> &amp;&amp; location.search\n        ? location.pathname + location.search + <span class=\"hljs-string\">&quot;#&quot;</span>\n        : base) +\n      to;\n    <span class=\"hljs-keyword\">try</span> {\n      history[replace ? <span class=\"hljs-string\">&quot;replaceState&quot;</span> : <span class=\"hljs-string\">&quot;pushState&quot;</span>](state, <span class=\"hljs-string\">&quot;&quot;</span>, url);\n      historyState.value = state;\n    } <span class=\"hljs-keyword\">catch</span> (err) {\n      warn(<span class=\"hljs-string\">&quot;Error with push/replace State&quot;</span>, err);\n      location[replace ? <span class=\"hljs-string\">&quot;replace&quot;</span> : <span class=\"hljs-string\">&quot;assign&quot;</span>](url);\n    }\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replace</span>(<span class=\"hljs-params\">to, data</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> state = assign(\n      {},\n      history.state,\n      buildState(\n        historyState.value.back,\n        <span class=\"hljs-comment\">// keep back and forward entries but override current position</span>\n        to,\n        historyState.value.forward,\n        <span class=\"hljs-literal\">true</span>\n      ),\n      data,\n      { <span class=\"hljs-attr\">position</span>: historyState.value.position }\n    );\n    changeLocation(to, state, <span class=\"hljs-literal\">true</span>);\n    currentLocation.value = to;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">push</span>(<span class=\"hljs-params\">to, data</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> currentState = assign({}, historyState.value, history.state, {\n      <span class=\"hljs-attr\">forward</span>: to,\n      <span class=\"hljs-attr\">scroll</span>: computeScrollPosition(),\n    });\n    <span class=\"hljs-keyword\">if</span> (!history.state) {\n      warn(\n        <span class=\"hljs-string\">`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n`</span> +\n          <span class=\"hljs-string\">`history.replaceState(history.state, &#x27;&#x27;, url)\\n\\n`</span> +\n          <span class=\"hljs-string\">`You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`</span>\n      );\n    }\n    changeLocation(currentState.current, currentState, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">const</span> state = assign(\n      {},\n      buildState(currentLocation.value, to, <span class=\"hljs-literal\">null</span>),\n      { <span class=\"hljs-attr\">position</span>: currentState.position + <span class=\"hljs-number\">1</span> },\n      data\n    );\n    changeLocation(to, state, <span class=\"hljs-literal\">false</span>);\n    currentLocation.value = to;\n  }\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">location</span>: currentLocation,\n    <span class=\"hljs-attr\">state</span>: historyState,\n    push,\n    replace,\n  };\n}\n</code></pre>\n<p>该函数返回的 push 和 replace 函数，会添加给 routerHistory 对象上，因此当我们调用 routerHistory.push 或者是 routerHistory.replace 方法的时候实际上就是在执行这两个函数。</p>\n<p>push 和 replace 方法内部都是执行了 changeLocation 方法，该函数内部执行了浏览器底层的 history.pushState 或者 history.replaceState 方法，会向当前浏览器会话的历史堆栈中添加一个状态，这样就在不刷新页面的情况下修改了页面的 URL。</p>\n<p>我们使用这种方法修改了路径，这个时候假设我们点击浏览器的回退按钮回到上一个 URL，这需要恢复到上一个路径以及更新路由视图，因此我们还需要监听这种 history 变化的行为，做一些相应的处理。</p>\n<p>History 变化的监听主要是通过 historyListeners 来完成的，它是 useHistoryListeners 函数的返回值，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useHistoryListeners</span>(<span class=\"hljs-params\">base, historyState, currentLocation, replace</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> listeners = [];\n  <span class=\"hljs-keyword\">let</span> teardowns = [];\n  <span class=\"hljs-keyword\">let</span> pauseState = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">const</span> popStateHandler = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ state }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> to = createCurrentLocation(base, location);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">from</span> = currentLocation.value;\n    <span class=\"hljs-keyword\">const</span> fromState = historyState.value;\n    <span class=\"hljs-keyword\">let</span> delta = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">if</span> (state) {\n      currentLocation.value = to;\n      historyState.value = state;\n      <span class=\"hljs-keyword\">if</span> (pauseState &amp;&amp; pauseState === <span class=\"hljs-keyword\">from</span>) {\n        pauseState = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      delta = fromState ? state.position - fromState.position : <span class=\"hljs-number\">0</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      replace(to);\n    }\n    listeners.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">listener</span>) =&gt;</span> {\n      listener(currentLocation.value, <span class=\"hljs-keyword\">from</span>, {\n        delta,\n        <span class=\"hljs-attr\">type</span>: NavigationType.pop,\n        <span class=\"hljs-attr\">direction</span>: delta\n          ? delta &gt; <span class=\"hljs-number\">0</span>\n            ? NavigationDirection.forward\n            : NavigationDirection.back\n          : NavigationDirection.unknown,\n      });\n    });\n  };\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pauseListeners</span>(<span class=\"hljs-params\"></span>) </span>{\n    pauseState = currentLocation.value;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">listen</span>(<span class=\"hljs-params\">callback</span>) </span>{\n    listeners.push(callback);\n    <span class=\"hljs-keyword\">const</span> teardown = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> index = listeners.indexOf(callback);\n      <span class=\"hljs-keyword\">if</span> (index &gt; -<span class=\"hljs-number\">1</span>) listeners.splice(index, <span class=\"hljs-number\">1</span>);\n    };\n    teardowns.push(teardown);\n    <span class=\"hljs-keyword\">return</span> teardown;\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">beforeUnloadListener</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">const</span> { history } = <span class=\"hljs-built_in\">window</span>;\n    <span class=\"hljs-keyword\">if</span> (!history.state) <span class=\"hljs-keyword\">return</span>;\n    history.replaceState(\n      assign({}, history.state, { <span class=\"hljs-attr\">scroll</span>: computeScrollPosition() }),\n      <span class=\"hljs-string\">&quot;&quot;</span>\n    );\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">destroy</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> teardown <span class=\"hljs-keyword\">of</span> teardowns) teardown();\n    teardowns = [];\n    <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;popstate&quot;</span>, popStateHandler);\n    <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;beforeunload&quot;</span>, beforeUnloadListener);\n  }\n  <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;popstate&quot;</span>, popStateHandler);\n  <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;beforeunload&quot;</span>, beforeUnloadListener);\n  <span class=\"hljs-keyword\">return</span> {\n    pauseListeners,\n    listen,\n    destroy,\n  };\n}\n</code></pre>\n<p>该函数返回了 listen 方法，允许你添加一些侦听器，侦听 hstory 的变化，同时这个方法也被挂载到了 routerHistory 对象上，这样外部就可以访问到了。</p>\n<p>该函数内部还监听了浏览器底层 Window 的 popstate 事件，当我们点击浏览器的回退按钮或者是执行了 history.back 方法的时候，会触发事件的回调函数 popStateHandler，进而遍历侦听器 listeners，执行每一个侦听器函数。</p>\n<p>那么，Vue Router 是如何添加这些侦听器的呢？原来在安装路由的时候，会执行一次初始化导航，执行了 push 方法进而执行了 finalizeNavigation 方法。</p>\n<p>在 finalizeNavigation 的最后，会执行 markAsReady 方法，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">markAsReady</span>(<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (ready) <span class=\"hljs-keyword\">return</span>;\n  ready = <span class=\"hljs-literal\">true</span>;\n  setupListeners();\n  readyHandlers\n    .list()\n    .forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">[resolve, reject]</span>) =&gt;</span> (err ? reject(err) : resolve()));\n  readyHandlers.reset();\n}\n</code></pre>\n<p>markAsReady 内部会执行 setupListeners 函数初始化侦听器，且保证只初始化一次。我们再接着来看 setupListeners 的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setupListeners</span>(<span class=\"hljs-params\"></span>) </span>{\n  removeHistoryListener = routerHistory.listen(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, _from, info</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> toLocation = resolve(to);\n    pendingLocation = toLocation;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">from</span> = currentRoute.value;\n    <span class=\"hljs-keyword\">if</span> (isBrowser) {\n      saveScrollPosition(\n        getScrollKey(<span class=\"hljs-keyword\">from</span>.fullPath, info.delta),\n        computeScrollPosition()\n      );\n    }\n    navigate(toLocation, <span class=\"hljs-keyword\">from</span>)\n      .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (\n          isNavigationFailure(\n            error,\n            <span class=\"hljs-number\">4</span> <span class=\"hljs-comment\">/* NAVIGATION_ABORTED */</span> | <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* NAVIGATION_CANCELLED */</span>\n          )\n        ) {\n          <span class=\"hljs-keyword\">return</span> error;\n        }\n        <span class=\"hljs-keyword\">if</span> (isNavigationFailure(error, <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">/* NAVIGATION_GUARD_REDIRECT */</span>)) {\n          <span class=\"hljs-keyword\">if</span> (info.delta) routerHistory.go(-info.delta, <span class=\"hljs-literal\">false</span>);\n          pushWithRedirect(error.to, toLocation).catch(noop);\n          <span class=\"hljs-comment\">// avoid the then branch</span>\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.reject();\n        }\n        <span class=\"hljs-keyword\">if</span> (info.delta) routerHistory.go(-info.delta, <span class=\"hljs-literal\">false</span>);\n        <span class=\"hljs-keyword\">return</span> triggerError(error);\n      })\n      .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">failure</span>) =&gt;</span> {\n        failure = failure || finalizeNavigation(toLocation, <span class=\"hljs-keyword\">from</span>, <span class=\"hljs-literal\">false</span>);\n        <span class=\"hljs-keyword\">if</span> (failure &amp;&amp; info.delta) routerHistory.go(-info.delta, <span class=\"hljs-literal\">false</span>);\n        triggerAfterEach(toLocation, <span class=\"hljs-keyword\">from</span>, failure);\n      })\n      .catch(noop);\n  });\n}\n</code></pre>\n<p>侦听器函数也是执行 navigate 方法，执行路由切换过程中的一系列导航守卫函数，在 navigate 成功后执行 finalizeNavigation 完成导航，完成真正的路径切换。这样就保证了在用户点击浏览器回退按钮后，可以恢复到上一个路径以及更新路由视图。</p>\n<p>至此，我们就完成了路径管理，在内存中通过 currentRoute 维护记录当前的路径，通过浏览器底层 API 实现了路径的切换和 history 变化的监听。</p>\n","ogImage":{"url":"/assets/blog/cover/2021-01-26-vue3-core-source-code-26.png"},"coverImage":"/assets/blog/cover/2021-01-26-vue3-core-source-code-26.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}