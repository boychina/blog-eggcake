{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","slug":"2021-01-14-vue3-core-source-code-10"},"nextPost":{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","slug":"2021-01-15-vue3-core-source-code-12"}},"post":{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","description":"依赖注入：子孙组件如何共享数据？","keyword":"vue,vue3.0,源码","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>Vue.js 为我们提供了很多组件通讯的方式，常见的是父子组件通过 prop 传递数据。但是有时，我们希望能跨父子组件通讯，比如，无论组件之间嵌套多少层级，我都希望在后代组件中能访问它们祖先组件的数据。</p>\n<p>Vue.js 2.x 给我们提供了一种依赖注入的解决方案，即在祖先组件提供一个 provide 选项，举个例子：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Provider</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">this</span>.foo,\n    };\n  },\n};\n</code></pre>\n<p>这就相当于在祖先组件提供 foo 这个变量数据，我们就可以在任意子孙组件中注入这个变量数据：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Consumer</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">&quot;foo&quot;</span>],\n};\n</code></pre>\n<p>这样，我们就可以在子孙组件中通过 this.foo 访问祖先组件提供的数据，以达到组件通讯的目的。</p>\n<p>到了 Vue.js 3.0，除了可以继续沿用这种 Options 的依赖注入，还可以使用依赖注入的 API 函数 provide 和 inject，你可以在 setup 函数中调用它们。</p>\n<p>举个例子，我们在祖先组件调用 provide API：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Provider</span>\n<span class=\"hljs-keyword\">import</span> { provide, ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> theme = ref(<span class=\"hljs-string\">&quot;dark&quot;</span>);\n    provide(<span class=\"hljs-string\">&quot;theme&quot;</span>, theme);\n  },\n};\n</code></pre>\n<p>然后在子孙组件调用 inject API：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Consumer</span>\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> theme = inject(<span class=\"hljs-string\">&quot;theme&quot;</span>, <span class=\"hljs-string\">&quot;light&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> {\n      theme,\n    };\n  },\n};\n</code></pre>\n<p>这里要说明的是，inject 函数接受第二个参数作为默认值，如果祖先组件上下文没有提供 theme，则使用这个默认值。</p>\n<p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，而且它的规则更加宽松：<strong>祖先组件不需要知道哪些后代组件在使用它提供的数据，后代组件也不需要知道注入的数据来自哪里</strong>。</p>\n<p>那么，依赖注入的背后实现原理是怎样的呢？接下来我们就一起分析吧。</p>\n<h2>1 provide API</h2>\n<p>我们先来分析 provide API 的实现原理：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">provide</span>(<span class=\"hljs-params\">key, value</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> provides = currentInstance.provides;\n  <span class=\"hljs-keyword\">const</span> parentProvides =\n    currentInstance.parent &amp;&amp; currentInstance.parent.provides;\n  <span class=\"hljs-keyword\">if</span> (parentProvides === provides) {\n    provides = currentInstance.provides = <span class=\"hljs-built_in\">Object</span>.create(parentProvides);\n  }\n  provides[key] = value;\n}\n</code></pre>\n<p>在创建组件实例的时候，组件实例的 provides 对象指向父组件实例的 provides 对象：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> instance = {\n  <span class=\"hljs-comment\">// 依赖注入相关</span>\n  <span class=\"hljs-attr\">provides</span>: parent ? parent.provides : <span class=\"hljs-built_in\">Object</span>.create(appContext.provides),\n  <span class=\"hljs-comment\">// 其它属性</span>\n  <span class=\"hljs-comment\">// ...</span>\n};\n</code></pre>\n<p>这里，我们可以通过一张图直观感受一下它们之间的关系：\n<img src=\"/assets/blog/context/2021-01-15-vue3-core-source-code-11/CgqCHl86T3KAQuhfAACt-IfYuPc049.png\" alt=\"CgqCHl86T3KAQuhfAACt-IfYuPc049.png\">\n所以在默认情况下，组件实例的 provides 继承它的父组件，但是当组件实例需要提供自己的值的时候，它使用父级提供的对象创建自己的 provides 的对象原型。通过这种方式，在 inject 阶段，我们可以非常容易通过原型链查找来自直接父级提供的数据。</p>\n<p>另外，如果组件实例提供和父级 provides 中有相同 key 的数据，是可以覆盖父级提供的数据。举个例子：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { createApp, h, provide, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">const</span> ProviderOne = {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    provide(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;foo&quot;</span>);\n    provide(<span class=\"hljs-string\">&quot;bar&quot;</span>, <span class=\"hljs-string\">&quot;bar&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> h(ProviderTwo);\n  },\n};\n<span class=\"hljs-keyword\">const</span> ProviderTwo = {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    provide(<span class=\"hljs-string\">&quot;foo&quot;</span>, <span class=\"hljs-string\">&quot;fooOverride&quot;</span>);\n    provide(<span class=\"hljs-string\">&quot;baz&quot;</span>, <span class=\"hljs-string\">&quot;baz&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> h(Consumer);\n  },\n};\n<span class=\"hljs-keyword\">const</span> Consumer = {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">const</span> foo = inject(<span class=\"hljs-string\">&quot;foo&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> bar = inject(<span class=\"hljs-string\">&quot;bar&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> baz = inject(<span class=\"hljs-string\">&quot;baz&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> h(<span class=\"hljs-string\">&quot;div&quot;</span>, [foo, bar, baz].join(<span class=\"hljs-string\">&quot;&amp;&quot;</span>));\n  },\n};\ncreateApp(ProviderOne).mount(<span class=\"hljs-string\">&quot;#app&quot;</span>);\n</code></pre>\n<p>可以看到，这是一个嵌套 provider 的情况。根据 provide 函数的实现，ProviderTwo 提供的 key 为 foo 的 provider 会覆盖 ProviderOne 提供的 key 为 foo 的 provider，所以最后渲染在 Consumer 组件上的就是 <code>fooOverride&amp;bar&amp;baz</code> 。</p>\n<p>接下来，我们来分析另一个依赖注入的 API —— inject。</p>\n<h2>2 inject API</h2>\n<p>我们先来看 inject API 的实现原理：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">inject</span>(<span class=\"hljs-params\">key, defaultValue</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> instance = currentInstance || currentRenderingInstance;\n  <span class=\"hljs-keyword\">if</span> (instance) {\n    <span class=\"hljs-keyword\">const</span> provides = instance.provides;\n    <span class=\"hljs-keyword\">if</span> (key <span class=\"hljs-keyword\">in</span> provides) {\n      <span class=\"hljs-keyword\">return</span> provides[key];\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">arguments</span>.length &gt; <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">return</span> defaultValue;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n      warn(<span class=\"hljs-string\">`injection &quot;<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">String</span>(key)}</span>&quot; not found.`</span>);\n    }\n  }\n}\n</code></pre>\n<p>前文我们已经分析了 provide 的实现后，在此基础上，理解 inject 的实现就非常简单了。inject 支持两个参数，第一个参数是 key，我们可以访问组件实例中的 provides 对象对应的 key，层层查找父级提供的数据。第二个参数是默认值，如果查找不到数据，则直接返回默认值。</p>\n<p>如果既查找不到数据且也没有传入默认值，则在非生产环境下报警告，提示用户找不到这个注入的数据。</p>\n<p>到这里我们就掌握了 provide 和 inject 的实现原理。但是，我曾经看到过一个问题：“ Vue.js 3 跨组件共享数据，为何要用 provide/inject ？直接 export/import 数据行吗？“</p>\n<p>接下来我们就来探讨依赖注入和模块化共享数据的差异。</p>\n<h2>3 对比模块化共享数据的方式</h2>\n<p>我们先来看提问者给出的一个模块化共享数据的示例，即首先在根组件创建一个共享的数据 sharedData：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Root.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sharedData = ref(<span class=\"hljs-string\">&quot;&quot;</span>);\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Root&quot;</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// ...</span>\n  },\n  <span class=\"hljs-comment\">// ...</span>\n};\n</code></pre>\n<p>然后在子组件中使用 sharedData：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { sharedData } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./Root.js&quot;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Child&quot;</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-comment\">// 这里直接使用 sharedData 即可</span>\n  },\n};\n</code></pre>\n<p>当然，从这个示例上来看，模块化的方式是可以共享数据，但是 provide 和 inject 与模块化方式有如下几点不同。</p>\n<ul>\n<li><strong>作用域不同</strong></li>\n</ul>\n<p>对于依赖注入，它的作用域是局部范围，所以你只能把数据注入以这个节点为根的后代组件中，不是这棵子树上的组件是不能访问到该数据的；而对于模块化的方式，它的作用域是全局范围的，你可以在任何地方引用它导出的数据。</p>\n<ul>\n<li><strong>数据来源不同</strong></li>\n</ul>\n<p>对于依赖注入，后代组件是不需要知道注入的数据来自哪里，只管注入并使用即可；而对于模块化的方式提供的数据，用户必须明确知道这个数据是在哪个模块定义的，从而引入它。</p>\n<ul>\n<li><strong>上下文不同</strong></li>\n</ul>\n<p>对于依赖注入，提供数据的组件的上下文就是组件实例，而且同一个组件定义是可以有多个组件实例的，我们可以根据不同的组件上下文提供不同的数据给后代组件；而对于模块化提供的数据，它是没有任何上下文的，仅仅是这个模块定义的数据，如果想要根据不同的情况提供不同数据，那么从 API 层面设计就需要做更改。</p>\n<p>比如允许用户传递一个参数：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getShareData</span>(<span class=\"hljs-params\">context</span>) </span>{\n  <span class=\"hljs-comment\">// 根据不同的 context 参数返回不同的数据</span>\n}\n</code></pre>\n<p>掌握了这些不同，在不同场景下你就应该知道选择哪种方式提供数据了。</p>\n<h2>4 依赖注入的缺陷和应用场景</h2>\n<p>我们再回到依赖注入，它确实提供了一种组件共享的方式，但并非完美的。正因为依赖注入是上下文相关的，所以它会将你应用程序中的组件与它们当前的组织方式耦合起来，这使得重构变得困难。</p>\n<p>来回顾一下依赖注入的特点 ：<strong>祖先组件不需要知道哪些后代组件使用它提供的数据，后代组件也不需要知道注入的数据来自哪里</strong>。</p>\n<p>如果在一次重构中我们不小心挪动了有依赖注入的后代组件的位置，或者是挪动了提供数据的祖先组件的位置，都有可能导致后代组件丢失注入的数据，进而导致应用程序异常。所以，我<strong>并不推荐在普通应用程序代码中使用依赖注入</strong>。</p>\n<p>但是我推荐你在组件库的开发中使用，因为对于一个特定组件，它和其嵌套的子组件上下文联系很紧密。</p>\n<p>这里来举一个 Element-UI 组件库 Select 组件的例子：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;value&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请选择&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-option</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in options&quot;</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;item.value&quot;</span>\n      <span class=\"hljs-attr\">:label</span>=<span class=\"hljs-string\">&quot;item.label&quot;</span>\n      <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;item.value&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-select</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">options</span>: [{\n          <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;选项1&#x27;</span>,\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;黄金糕&#x27;</span>\n        }, {\n          <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;选项2&#x27;</span>,\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;双皮奶&#x27;</span>\n        }, {\n          <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;选项3&#x27;</span>,\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;蚵仔煎&#x27;</span>\n        }, {\n          <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;选项4&#x27;</span>,\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;龙须面&#x27;</span>\n        }, {\n          <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;选项5&#x27;</span>,\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;北京烤鸭&#x27;</span>\n        }],\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>这是 Select 组件的基础示例，它最终会在页面上渲染成这样：\n<img src=\"/assets/blog/context/2021-01-15-vue3-core-source-code-11/Ciqc1F86T9CAGMkuAACL3WKe6QA403.png\" alt=\"Ciqc1F86T9CAGMkuAACL3WKe6QA403.png\">\n子组件 ElOption 负责渲染每一个选项，它的内部想要访问最外层的 ElSelect 组件时，就可以通过依赖注入的方式，在 ElSelect 组件中提供组件的实例：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">provide</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">select</span>: <span class=\"hljs-built_in\">this</span>,\n    };\n  },\n};\n</code></pre>\n<p>就这样，我们可以在 ElOption 组件注入这个数据：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">&quot;select&quot;</span>],\n};\n</code></pre>\n<p>虽然这些代码还是用的 Vue.js 2.x 的 Options API 方式，但是依赖注入的思想是不变的。</p>\n<p>你可能会问，为什么不在 ElOption 子组件内通过 this.$parent 访问外层的 ElSelect 组件实例呢？</p>\n<p>虽然 this.$parent 指向的是它的父组件实例，在我们这个例子是可以的，但如果组件结构发生了变化呢？</p>\n<p>我们再来看另一个 Select 组件的例子：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;value&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请选择&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-option-group</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;group in options&quot;</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;group.label&quot;</span>\n      <span class=\"hljs-attr\">:label</span>=<span class=\"hljs-string\">&quot;group.label&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-option</span>\n        <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in group.options&quot;</span>\n        <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;item.value&quot;</span>\n        <span class=\"hljs-attr\">:label</span>=<span class=\"hljs-string\">&quot;item.label&quot;</span>\n        <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">&quot;item.value&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-option-group</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-select</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">options</span>: [{\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;热门城市&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: [{\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Shanghai&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;上海&#x27;</span>\n          }, {\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;北京&#x27;</span>\n          }]\n        }, {\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;城市名&#x27;</span>,\n          <span class=\"hljs-attr\">options</span>: [{\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Chengdu&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;成都&#x27;</span>\n          }, {\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Shenzhen&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;深圳&#x27;</span>\n          }, {\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Guangzhou&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;广州&#x27;</span>\n          }, {\n            <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Dalian&#x27;</span>,\n            <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">&#x27;大连&#x27;</span>\n          }]\n        }],\n        <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>这是 Select 组件的分组示例，最终会在页面上渲染成这样：\n<img src=\"/assets/blog/context/2021-01-15-vue3-core-source-code-11/CgqCHl86T-OAVgk-AACFqLBanFk012.png\" alt=\"CgqCHl86T-OAVgk-AACFqLBanFk012.png\">\n显然，这里 ElOption 中的 this.$parent 指向的就不是 ElSelect 组件实例，而是 ElOptionGroup 组件实例。但如果我们用依赖注入的方式，即使结构变了，还是可以在 ElOption 组件中正确访问到 ElSelect 的实例。</p>\n<p>所以，this.$parent 是一种强耦合的获取父组件实例方式，非常不利于代码的重构，因为一旦组件层级发生变化，就会产生非预期的后果，所以在平时的开发工作中你应该慎用这个属性。</p>\n<p>相反，在组件库的场景中，依赖注入还是很方便的，除了示例中提供组件实例数据，还可以提供任意类型的数据。因为入口组件和它的相关子组件关联性是很强的，无论后代组件的结构如何变化，最终都会渲染在入口组件的子树上。</p>\n<h2>5 总结</h2>\n<p>好的，到这里我们这一篇的内容，通过阅读本文，你应该掌握 Vue.js 依赖注入的实现原理，了解依赖注入的使用场景和它的缺陷。</p>\n<p>到目前为止，我们已经了解了 Vue.js 3.0 提供的所有常用的 Composition API。可以看到和 Vue.js 2.x Options API 相比，我们不再是通过编写一些组件配置去描述一个组件，更像是主动调用一些 API 去编写组件的实现逻辑。</p>\n<p>Vue.js 2.x 中，框架背后帮我们做了很多事情，比如我们在 data 中定义的变量，在组件实例化阶段会把它们变成响应式的，这个行为是黑盒的，用户是无感知的。反观 Vue.js 3.0 Composition API，用户会利用 reactive 或者 ref API 主动去申明一个响应式对象。</p>\n<p>所以<strong>通过 Composition API 去编写组件，用户更清楚自己在做什么事情</strong>。</p>\n<p>另外，为什么说 Composition API 比 mixin 更适合逻辑复用呢？</p>\n<p>其实，二者都是把复用的逻辑放在单独的文件中维护。但从使用的方式而言，用户只是在需要混入 mixin 的组件中去申明这个 mixin，使用方式如下：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    Mouse position: x {{ x }} / y {{ y }}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> mousePositionMixin <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./mouse&#x27;</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">mixins</span>: [mousePositionMixin]\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>我们在组件中申明了 mousePositionMixin，组件模板中使用的 x、y 就来源于这个 mixin，这一切都是 Vue.js 内部帮我们做的。如果该组件只引入这单个 mixin，问题倒不大，但如果这个组件引入的 mixin 越来越多，很容易出现命名冲突的情况，以及造成数据来源不清晰等问题。</p>\n<p>而我们通过 Composition API 去编写功能类似的 hook 函数，使用方式如下：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    Mouse position: x {{ x }} / y {{ y }}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> useMousePosition <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./mouse&#x27;</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">const</span> { x, y } = useMousePosition()\n      <span class=\"hljs-keyword\">return</span> { x, y }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>我们可以清楚地分辨出模板中使用的 x、y 是来源于 useMousePosition 函数，即便我们引入更多的 hook 函数，也不会出现命名冲突的情况。</p>\n<p>Composition API 在逻辑复用上确实有不错的优势，但是它并非完美的，使用起来会增加代码量。Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，还是可 以使用 Options API 的。</p>\n<p>最后，思考一个问题，如果你想利用依赖注入让整个应用下组件都能共享某个数据，你会怎么做？为什么？</p>\n<blockquote>\n<p><strong>本篇的相关代码在源代码中的位置如下</strong>：<br>\npackages/runtime-core/src/apiInject.ts</p>\n</blockquote>\n","ogImage":{"url":"/assets/blog/cover/2021-01-15-vue3-core-source-code-11.png"},"coverImage":"/assets/blog/cover/2021-01-15-vue3-core-source-code-11.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}