{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"MySQL 常用命令","slug":"2018-08-09-mysql-common-commands"},"nextPost":{"title":"Vue 服务端渲染","slug":"2018-08-15-vue-server-side-render"}},"post":{"title":"React16.3+ 新的生命周期钩子","description":"React16.3+ 新的生命周期钩子","keyword":"react,生命周期","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<p>在 React 16.3 中，Facebook 的工程师们给 React 带了来一系列的新特性，如 suspense 和 time slicing 等，这些都为 React 接下来即将到来的异步渲染机制做准备，有兴趣的可以看<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dv6iR3Zk4oDY\">Sophie Alpert 在 JSConf Iceland 2018 的演讲</a>。</p>\n<p>像 time slicing 等 React 内部优化特性，在 API 层面不会有太大变化，而 API 层面最大的变化应该在生命周期钩子。</p>\n<p>React 的生命周期 API 一直以来十分稳定，但是当 React 团队在引入异步渲染机制的时候，发现之前的生命周期在使用时会产生一些问题，所以才会改动生命周期 API，感兴趣可以看<a href=\"https://link.juejin.im/?target=https%3A%2F%2Freactjs.org%2Fblog%2F2018%2F03%2F27%2Fupdate-on-async-rendering.html%23initializing-state\">这篇博客</a>。</p>\n<p>在 React 16.3 中，为下面三个生命周期钩子加上了 UNSAFE 标记：</p>\n<ul>\n<li>UNSAFE_componentWillMount</li>\n<li>UNSAFE_componentWillReceiveProps</li>\n<li>UNSAFE_componentWillUpdate</li>\n</ul>\n<p>新增下面两个生命周期方法</p>\n<ul>\n<li>static getDerivedStateFromProps // 从道具中获得派生状态</li>\n<li>getSnapshotBeforeUpdate // 获取快照更新之前</li>\n</ul>\n<p>在目前 16.X（X &gt; 3）的 React 中，使用 componentWillMount, componentWillReceiveProps, componentWillUpdate 这三个方法会收到警告。<strong>React 团队计划在 17.0 中彻底废弃掉这几个 API</strong>。</p>\n<h3>新的生命周期钩子：static getDerivedStateFromProps</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Example</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromProps</span>(<span class=\"hljs-params\">props, state</span>)</span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p>React 在实例化组件之后以及重新渲染组件之前，将调用新的 static getDerivedStateFromProps 生命周期方法。该方法类似于 componentWillReceiveProps，可以用来控制 props 更新 state 的过程。<strong>它返回一个对象表示新的 state。如果不需要更新组件，返回 null 即可</strong>。</p>\n<p>geDerivedStateFromProps 与 componentDidUpdate 一起将会替换掉所有的 componentWillReceiveProps。</p>\n<h3>新的生命周期钩子：getSnapshotBeforeUpadte</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Example</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getSnapshotBeforeUpate</span>(<span class=\"hljs-params\">prevProps, prevState</span>)</span> {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p>getSnapshotBeforeUpdate 方法 <strong>在 React 对视图做出实际改动（如 DOM 更新）发生前被调用，返回值将作为 ComponentDidUpdate 的第三个参数</strong>。</p>\n<p>getSnapshotBeforeUpdate 配合 componentDidUpdate 可以取代 componentWillUpdate。</p>\n<h3>为何移除 componentWillMount</h3>\n<p>因为在 React 未来的版本中，异步渲染机制可能会导致单个组件实例可以多次调用该方法。很多开发者目前会将时间绑定、异步请求等写在 componentWillMount 中，一旦异步渲染 componentWillMount 被多次调用，将导致：</p>\n<ul>\n<li>进行重复的时间监听，无法正常取消重复的 Listener ，更有可能 <strong>导致内存泄漏</strong></li>\n<li>发出重复的异步网络请求， <strong>导致 IO 资源被浪费</strong></li>\n<li>在服务端渲染时，componentWillMount 会被调用，但是会因忽略异步获取的数据而浪费 IO 资源</li>\n</ul>\n<p>现在，React 推荐将原本在 componentWillMount 中的网络请求移到 componentDidMount 中。至于这样会不会导致请求被延迟发出影响用户体验，React 团队是这么解释的：</p>\n<blockquote>\n<p>There is a common misconception that fetching in componentWillMount lets you avoid the first empty rendering state. In practice this was never true because React has always executed render immediately after componentWillMount. If the data is not available by the time componentWillMount fires, the first render will still show a loading state regardless of where you initiate the fetch. This is why moving the fetch to componentDidMount has no perceptible effect in the vast majority of cases.</p>\n</blockquote>\n<blockquote>\n<p>有一种常见的误解，认为在 componentWillMount 中请求可以避免第一个空呈现状态。在实践中，这从来都不是正确的，因为在组件挂起之后，React 总是立即执行。如果数据在组件挂起的时候没有可用，那么第一个渲染将仍然显示加载状态，而不管您发起请求的位置。这就是为什么在绝大多数情况下移动 fetch 到 componentDidMount 并没有明显的效果。</p>\n</blockquote>\n<p>componentWillMount、render 和 componentDidMount 方法虽然存在调用先后顺序，但在大多数情况下，几乎都是在很短的时间内先后执行完毕，几乎不会对用户体验产生影响。</p>\n<h3>为什么移除 comonentWillUpdate</h3>\n<p>大多数开发者使用 componentWillUpdate 的场景是配合 componentDidUpdate，分别获取 render 前后的视图状态，进行必要的处理。但随着 React 新的 suspense、time slicing、异步渲染等机制的到来，render 过程可以可以被分割成多次完成，还可以被暂停甚至回溯，这 <strong>导致 componentWillUpdate 和 componentDidUpdate 执行前后可能会间隔很长时间</strong>，足够使用户进行交互操作更改当前组件的状态，这样可能会导致难以追踪的 BUG。</p>\n<p>React 新增的 getSnapshotBeforeUpdate 方法就是为了解决上述问题，因为 getSnapshotBeforeUpdate 方法是在 componentWillUpadate 后（如果存在的话），在 React 真正更改 DOM 前调用的，它获取到组件状态信息更可靠。</p>\n<p>除此之外，getSnapshotBeforeUpdate 还有一个十分明显的好处：它调用的结果会作为第三个参数传入 componentDidUpdate，避免了 componentWillUpdate 和 componentDidUpdate 配合使用时将组件临时的状态数据存在组件实例上浪费内存，getSnapshotBeforeUpdate 返回的数据在 componentDidUpdate 中用完即被销毁，效率更高。</p>\n<h3>总结</h3>\n<p>React 进来 API 变化十分大，React 团队很长时间以来一直在实现异步渲染机制，目前的特性只是为异步渲染做准备，预计 React 在 17 版本发布时，性能会取的巨大的提升，期待中。。。</p>\n<p>PS：从 Sophie Alpert 验证的两个 DEMO 上看，异步渲染的高效确实十分惊艳，有兴趣的可以看文章开头的演讲。</p>\n","ogImage":{"url":"/assets/blog/cover/2018-08-15-react-new-life-cycle-hook.jpg"},"coverImage":"/assets/blog/cover/2018-08-15-react-new-life-cycle-hook.jpg"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}