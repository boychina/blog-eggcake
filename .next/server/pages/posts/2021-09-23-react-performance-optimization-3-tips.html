<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="ysl9po9N59vjLGroL70RxvgSCwmCa4y0Vf-bQ0dnnYg"/><meta name="baidu-site-verification" content="code-SQ8pinCY3n"/><meta name="sogou_site_verification" content="IbqK7EsWs0"/><a href="https://github.com/boychina" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="64x64" href="/favicon/favicon-64x64.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="http://www.eggcake.cn/favicon/safari-pinned-tab.svg"/><title>React性能优化3大技巧 | 蛋烘糕</title><meta property="og:image" content="http://assets.eggcake.cn/cover/2021-09-23-React性能优化3大技巧.png"/><meta name="description" itemProp="description" content="React性能优化3大技巧"/><meta name="keywords" itemProp="keywords" content="react"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/25dec47f644ce948ceaf.css" as="style"/><link rel="stylesheet" href="/_next/static/css/25dec47f644ce948ceaf.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0dfeaabe61d45728c2c5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0dfeaabe61d45728c2c5.css" data-n-g=""/><link rel="preload" href="/_next/static/css/935e64bee0f4c6ad8975.css" as="style"/><link rel="stylesheet" href="/_next/static/css/935e64bee0f4c6ad8975.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.d2ae4074d0a54d95f68e.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.aa38fa4438674e4829e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-289a634af5672dccc790.js" as="script"/><link rel="preload" href="/_next/static/chunks/88ba77ff.ddce25b62cf34b951439.js" as="script"/><link rel="preload" href="/_next/static/chunks/7fc15881135854c491ac39d12fa6613ab66b01b2.c42c97147b951804797d.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d7fdca0a1114199b8fb8.js" as="script"/><link rel="preload" href="/_next/static/chunks/29107295.a17518e86625a3a5a388.js" as="script"/><link rel="preload" href="/_next/static/chunks/75fc9c18.93c7b383c2ac9fbfc4eb.js" as="script"/><link rel="preload" href="/_next/static/chunks/7003c6d6bfd23e1c87ce347f6e370329b7a168b3.05d2a21d83a8f633eaf7.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-e52ee22239e463e4ff9f.js" as="script"/></head><body><div id="__next"><div class="min-h-screen"><section class="w-screen bg-white flex-col md:flex-row flex items-center md:justify-between pt-3 pb-1 mb-6 md:mb-4 pl-10 pr-20 shadow-lg md:fixed z-50"><a href="/"><div class="text-xl h-6 font-bold tracking-tighter leading-tight flex"><img src="/favicon/safari-pinned-tab.svg" class="w-6 mr-1"/><span>蛋烘糕.</span></div></a><h4 class="text-center md:text-left text-sm mt-2 md:mt-4 md:pl-8">不写博客的工程师不是好的搬砖工🧱</h4></section><main class="md:pt-20"><div class="container max-w-screen-xl mx-auto px-4 grid grid-cols-12 gap-1 md:gap-2 lg:gap-3 xl:gap-4 xxl:gap-5"><div class="mb-5 col-span-12 md:col-span-10 lg:col-span-9"><h1 class="text-2xl md:text-3xl lg:text-4xl font-bold tracking-tighter leading-tight md:leading-none mb-4 text-center md:text-left">React性能优化3大技巧</h1><div class="hidden md:block md:mb-12"><div class="flex items-center"><img src="/assets/blog/authors/zhaohuan.jpg" class="w-8 h-8 rounded-full mr-4" alt="蛋烘糕"/><div class="text-sm text-cyan-600">蛋烘糕</div><span class="ml-1 text-gray-500"><time dateTime="2021-09-23 11:56:00">2021-09-23</time></span></div></div><div class="mb-6 md:mb-8 sm:mx-0"><div class="sm:mx-0"><img src="http://assets.eggcake.cn/cover/2021-09-23-React性能优化3大技巧.png" alt="Cover Image for React性能优化3大技巧" class="h-64 rounded-xl mx-auto"/></div></div><div class="mx-auto"><div class="block md:hidden mb-6"><div class="flex items-center"><img src="/assets/blog/authors/zhaohuan.jpg" class="w-8 h-8 rounded-full mr-4" alt="蛋烘糕"/><div class="text-sm text-cyan-600">蛋烘糕</div><span class="ml-1 text-gray-500"><time dateTime="2021-09-23 11:56:00">2021-09-23</time></span></div></div></div><div class="markdown-body"><div class="PostBody_markdown___-zaK"><p>在业务迭代过程中，React 性能优化是我们不得不考虑的问题，虽然项目在启动之初，我们一般不会考虑项目的复杂度，而且因为产品的用户体量和技术场景也不复杂，并不需要考虑性能优化，但是随着业务场景的复杂化，性能优化就变得格外重要了。</p>
<p>我们从 React 源码入手，以有具体业务为例，运用 3 大优化技巧对系统进行“外科手术式”的优化，同时深入刨析 React Profiler，利用这款性能优化利器，帮我们定位性能瓶颈。</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"><br />页面加载流程</p>
<ul>
<li>假设用户首次打开页面（无缓存），这个时候页面是完全空白的；</li>
<li>HTML 和引用的 CSS 加载完毕，浏览器进行首次渲染；</li>
<li>React、ReactDom、业务代码加载完毕，应用第一次渲染（或者说首次内容渲染）；</li>
<li>应用代码开始执行，拉取数据、进行动态 import、响应事件……完毕后页面进入可交互状态；</li>
<li>Lazy Load 的图片等多媒体内容开始逐渐加载完毕；</li>
<li>直到页面的其他资源（如错误上报组件、打点上报组件等）加载完毕，整个页面加载完成。</li>
</ul>
<p>接下来，我们主要来针对 React 剖析它渲染性能优化的三个方向（这三个方向也适用于其他软件开发领域）。</p>
<ul>
<li>减少计算的量：在 React 中，就是减少渲染的节点，或通过索引减少渲染复杂度。</li>
<li>利用缓存：在 React 中，就是避免重新渲染（利用 memo 方式来避免组件重新渲染）。</li>
<li>精确重新计算的范围：在 React 中，就是绑定组件和状态关系，精确判断更新的“时机”和“范围”，只重新渲染变更的组件（减少渲染范围）。</li>
</ul>
<p>如何做到这三点呢？<strong>我们从 React 本身的特性入手分析。</strong></p>
<p><a name="wU2DA"></a></p>
<h3>React 的工作流</h3>
<p>React 是声明式 UI 库，负责把 State 转换成页面结构后（虚拟 DOM 结构），再转换成真实 DOM 结构，交给浏览器渲染。State 发生改变时，React 会先进行 Reconciliation，结束后立刻进入 Commit 阶段，Commit结束后，新 State 对应的页面才被展示出来。</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p>其中，React 的 Reconciliation 需要做两件事：</p>
<ul>
<li>计算出目标 State 对应的虚拟 DOM 结构；</li>
<li>寻找“将虚拟 DOM 结构修改为目标虚拟 DOM 结构”的最优方案。</li>
</ul>
<p>React 按照深度优先遍历虚拟 DOM 树的方式，在一个虚拟 DOM 上完成 Render 和 Diff 的计算后，再计算下一个虚拟 DOM，Diff 算法会记录虚拟 DOM 的更新方式（如：Update、Mount、Unmount），为 Commit 做准备。</p>
<p>而 React 的 Commit 也需要做两件事：</p>
<ul>
<li>将 Reconciliation 结果应用到 DOM 中；</li>
<li>调用暴露的 Hooks 如：componentDidUpdate、useLayoutEffect 等。</li>
</ul>
<p>了解完 React 的工作流之后，我们就针对三个优化方向精准分析。</p>
<p><a name="uX8Qs"></a></p>
<h3>如何减少计算的量</h3>
<p>关于 Reconciliation、Commit 两个阶段的优化办法，我遵循减少计算量（列表项使用 key 属性)的方式，React 内部的 Fiber 结构和并发模式也是在减少该过程的耗时阻塞。</p>
<p>对于 Commit 在执行Hooks 时，开发者应保证 Hooks 中的代码尽量轻量、避免耗时阻塞，同时应避免在 CDM、CDU 周期中更新组件。</p>
<p>假如你没有在列表中添加 key 属性，控制台会展示一片大红（系统会时刻提醒你记得加 Key）</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p><a name="FSoH8"></a></p>
<h3>优化 Render 过程</h3>
<p>Render 过程即 Reconciliation 中计算出目标 State 对应的虚拟 DOM 结构。触发 React 组件的 Render 过程目前有三种方式：forceUpdate、State 更新、父组件 Render 触发子组件 Render 过程。</p>
<p><a name="xmvXV"></a></p>
<h4>优化技巧一：PureComponent、React.memo</h4>
<p>在 React 工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。</p>
<p>从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变，当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。</p>
<p>PureComponent 和 React.memo应对了这种场景：</p>
<ul>
<li>PureComponent 是对类组件的 Props 和 State 进行浅比较；</li>
<li>React.memo 是对函数组件的 Props 进行浅比较。</li>
</ul>
<p><a name="Pac5h"></a></p>
<h4>优化技巧二：useMemo、useCallback 实现稳定的 Props 值</h4>
<p>如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效，所以需要用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。</p>
<p><a name="M6TAg"></a></p>
<h4>优化技巧三：useMemo 减少组件 Render 过程耗时</h4>
<p>useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算，一般用在“计算派生状态的代码”非常耗时的场景中（比如遍历大列表做统计信息）。</p>
<pre class="hljs"><code><span class="hljs-comment">// 大列表渲染</span>
<span class="hljs-keyword">const</span> renderTable = useMemo(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    &lt;Table&lt;TS.OrderPollData&gt;
      bordered
      scroll={{ <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;max-content&#x27;</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">620</span> }}
      rowClassName={styles.tableLine}
      columns={tableColumns}
    	dataSource={dataSource}
    	loading={loading}
    	pagination={<span class="hljs-literal">false</span>}
  	/&gt;
  );
}, [loading, datasource, pageConfig, tablecolumns])
</code></pre>
<p>显然，useMemo的作用是缓存昂贵的计算(避免在每次渲染时都进行高开销的计算)，在业务中使用它去控制变量来更新表格。</p>
<p><a name="yvRVR"></a></p>
<h4>优化技巧四：shouldComponentUpdate</h4>
<p>在类组件中，例如要往数组中添加一项数据时，当时的代码很可能是 state.push(item)，而不是 const newState = [...state, item]。</p>
<pre class="hljs"><code>shouldComponentUpdate = <span class="hljs-function">(<span class="hljs-params">nextProps:PromiseRenderProps&lt;T, K&gt;, nextState: PromiseRenderState</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { component } = <span class="hljs-built_in">this</span>.state;
  <span class="hljs-keyword">if</span> (!isEqual(nextProps, <span class="hljs-built_in">this</span>.props)) {
    <span class="hljs-built_in">this</span>.setRenderComponent(nextProps);
  }
  <span class="hljs-keyword">if</span> (nextState.component !== component) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>在此背景下，当时的开发者经常使用 shouldComponentUpdate 来深比较 Props，只在 Props 有修改才执行组件的 Render 过程，如今由于数据不可变性和函数组件的流行，这样的优化场景已经很少再出现了。</p>
<p>为了贴合 shouldComponentUpdate 的思想：给子组件传 Props 时一定只传其需要的，而并非一股脑全部传入。</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> AbleHiddenFiltersprops = useMemo(<span class="hljs-function">() =&gt;</span> 
	<span class="hljs-keyword">return</span> {
		hideFilters,
		gradeInfo,
    subjectInfo,
    ......
		setHideFilters,
		findOrderValue
  }
}, [gradeInfo, subjectInfo, hideFilters, studentId, findorderValue]);

<span class="hljs-keyword">const</span> CommonFiltersProps = useMemo(<span class="hljs-function">() =&gt;</span> {
	<span class="hljs-keyword">return</span> {
		user,
    userId,
    orgInfo,
    pickerValue,
    ......
    studentId,
    userDisabled,
    userData,
    organizationData,
  }
}, [userId, orgInfo, pickerValue, studentId, isShowOrg, cUserFilteRef, initialOwnerListRef?.current]);
</code></pre>
<p>传入子组件的参数一定保证其在自组件中被使用到。</p>
<p><a name="i5nrj"></a></p>
<h3>批量更新，减少 Render 次数</h3>
<p>在 React 管理的事件回调和生命周期中，setState 是异步的，其他时候 setState 是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候是立即更新的。</p>
<p>批量更新 setState 时，<strong>多次执行 setState 只会触发一次 Render 过程</strong>。相反在立即更新 setState 时，每次 setState 都会触发一次 Render 过程，就存在性能影响。</p>
<p>假设有如下组件代码，该组件在 getData() 的 API 请求结果返回后，分别更新了两个 State 。</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NormalComponent</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">const</span> [list, setList] = useState(<span class="hljs-literal">null</span>);
	<span class="hljs-keyword">const</span> [info, setInfo] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function">() =&gt;</span> {
    ;(<span class="hljs-keyword">async</span> () =&gt; {
			<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> getData();
			setList(data.list);
      setInfo (data.info);
    )();
	}, []);

	<span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
			非批量更新组件时 Render 次数:
      {renderOnce(&#x27;normal&#x27;)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
	)
}
</code></pre>
<p>该组件会在 setList(data.list) 后，触发组件的 Render 过程，然后在 setInfo(<a href="http://data.info">data.info</a>) 后再次触发 Render 过程，造成性能损失，<strong>那我们该如何解决呢？</strong></p>
<ul>
<li>将多个 State 合并为单个 State，比如 useState({ list: null, info: null }) 替代 list 和 info 两个 State。</li>
<li>使用 React 官方提供的 unstable_batchedUpdates 方法，将多次 setState 封装到 unstable_batchedUpdates 回调中。</li>
</ul>
<p>修改后代码如下：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BatchedComponent</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-keyword">const</span> [list, setList] = useState(<span class="hljs-literal">null</span>);
	<span class="hljs-keyword">const</span> [info, setInfo] = useState(<span class="hljs-literal">null</span>);

	useEffect(<span class="hljs-function">() =&gt;</span> {
		;(<span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> data= <span class="hljs-keyword">await</span> getData();
			unstable_batchedUpdates(<span class="hljs-function">() =&gt;</span> {
        setList(data.list);
				setInfo(data.info);
      });
    })()
  }, [])

	<span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      批量更新组件时 Render 次数：
      {renderOnce(&#x27;batched&#x27;)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
</code></pre>
<p><a name="dbUs8"></a></p>
<h3>精细化渲染阶段</h3>
<p><a name="urvIk"></a></p>
<h4>按优先级更新，及时响应用户</h4>
<p>如果页面弹出一个 Modal，当用户点击 Modal 中的确定按钮后，代码将执行两个操作：</p>
<ul>
<li>关闭 Modal；</li>
<li>页面处理 Modal 传回的数据并展示给用户。</li>
</ul>
<p>当操作 2 需要执行 500ms 时，用户会明显感觉到从点击按钮到 Modal 被关闭之间的延迟。下图为一般的实现方式，将 slowHandle 函数作为用户点击按钮的回调函数。</p>
<pre class="hljs"><code><span class="hljs-comment">// 非延迟执行</span>
<span class="hljs-keyword">const</span> slowHandle = <span class="hljs-function">() =&gt;</span> {
  setShowInput(<span class="hljs-literal">false</span>)
  setNumbers ([...numbers, +inputValue].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) ));
}
</code></pre>
<p>slowHandle() 执行过程耗时长，用户点击按钮后会明显感觉到页面卡顿。</p>
<p>如果让页面优先隐藏输入框，用户就能立刻感知到页面更新，不会有卡顿感。<strong>而实现优先级更新的要点是：将耗时任务移动到下一个宏任务中执行，优先响应用户行为。</strong></p>
<p>比如在示例中，将 setNumbers 移动到 setTimeout 的回调中，用户点击按钮后能立刻看到输入框被隐藏，不会感知到页面卡顿。项目中优化后的代码如下：</p>
<pre class="hljs"><code><span class="hljs-comment">// 延迟执行</span>
<span class="hljs-keyword">const</span> fastHandle = <span class="hljs-function">() =&gt;</span> {
	<span class="hljs-comment">// 优先响应用户行为</span>
	setShowInput(<span class="hljs-literal">false</span>);
	<span class="hljs-comment">// 将耗时任务移动到下一个宏任务执行</span>
	<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
		setNumbers([...numbers, +inputValue].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b));
  })
}
</code></pre>
<p><a name="xXjN4"></a></p>
<h4>发布者订阅者跳过中间组件 Render 过程</h4>
<p>React 推荐将公共数据放在所有“需要该状态的组件”的公共组件上，但是将状态放在公共组件上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p>传统 Redux 数据流</p>
<p>可以看到，每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下，<strong>可以将状态用“发布者、订阅者模式”维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态</strong>。</p>
<p>当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。</p>
<p>只要是发布者订阅者模式的库，都可以使用 useContext 进行该优化。比如 redux、use-global-state、React.createContext 等。</p>
<p>业务代码中的使用如下：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p>从图中可看出，优化后只有使用了公共状态的组件 renderTable 才会发生更新，可以大大减少父组件和其他 renderSon 组件的 Render 次数(减少叶子节点的重渲染)。</p>
<p><a name="uk68B"></a></p>
<h4>useMemo 返回虚拟 DOM 可跳过该组件 Render 过程</h4>
<p>利用 useMemo 可以缓存计算结果的特点，如果 useMemo 返回的是组件的虚拟 DOM，那么将在 useMemo 依赖不变时，跳过组件的 Render 阶段。该方式与 React.memo 类似，但与 React.memo 相比有以下优势。</p>
<ul>
<li>更方便：React.memo 需要对组件进行一次包装，生成新的组件，而 useMemo 只需在存在性能瓶颈的地方使用，不用修改组件。</li>
<li>更灵活：useMemo 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 useDeepCompareMemo 对用到的值进行深比较。</li>
</ul>
<p>该例子中，父组件状态更新后，不使用 useMemo 的子组件会执行 Render 过程，而使用 useMemo 的子组件会按需执行更新。</p>
<p>业务代码中的使用方法如下：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p><a name="exACa"></a></p>
<h3>精确判断更新的“时机”和“范围”</h3>
<p><a name="xWbRv"></a></p>
<h4>debounce、throttle 优化频繁触发的回调</h4>
<p>在搜索组件中，当 input 中内容修改时就触发搜索回调，当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。</p>
<p>在搜索场景中一般使用 useDebounce+ useEffect 的方式获取数据。</p>
<pre class="hljs"><code><span class="hljs-comment">/**
 * 使用ref存储setTimeout 返回的值，避免普通防抖函数在函数组件中使用时依赖变化导致setTimeout唯一标识符丟失
 * <span class="hljs-doctag">@param </span>fun 防抖目标函数
 * <span class="hljs-doctag">@param </span>delay 防抖时间
*/</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebounce</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">unknown</span>[]&gt;(<span class="hljs-params">fun:(...args: T) =&gt; unknown, delay: number = <span class="hljs-number">300</span></span>) </span>{
  <span class="hljs-keyword">const</span> ref = useRef&lt;any&gt;();
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">...args: T</span>) </span>{
    <span class="hljs-comment">// ats-ignore</span>
    <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span>;
    <span class="hljs-built_in">clearTimeout</span>(ref.current);
    ref.current = <span class="hljs-built_in">setTimeout</span>(() - fun.apply&lt;any,T, unknown&gt;(that, args), delay);
  };
}

<span class="hljs-comment">/**
 * 节流 delay 内时间内只能触发1次回调
 * <span class="hljs-doctag">@param </span>fun 函数
 * <span class="hljs-doctag">@param </span>delay 间隔时间
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useThrottle</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">unknown</span>[], <span class="hljs-title">R</span> = <span class="hljs-title">any</span>&gt;(<span class="hljs-params">fun:(...args: T) =&gt; R, delay: number = <span class="hljs-number">700</span></span>) </span>{
	<span class="hljs-keyword">const</span> ref = useRef&lt;number&gt;(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">...args: T</span>): <span class="hljs-title">R</span> | <span class="hljs-title">undefined</span> </span>{
    <span class="hljs-keyword">const</span> date = <span class="hljs-built_in">Date</span>.now();
    <span class="hljs-keyword">if</span> (ref.current + delay &gt; date) <span class="hljs-keyword">return</span>;
    ref.current = date;
    <span class="hljs-comment">// @ts-ignore</span>
    <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span>;
    <span class="hljs-keyword">return</span> fun.apply&lt;any, T, R&gt;(that, args);
  }
}


<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">const</span> [text, setText] = useState(<span class="hljs-string">&#x27;Hello&#x27;</span>);
  <span class="hljs-keyword">const</span> [debouncedValue] = useDebounce(text, <span class="hljs-number">300</span>);
	useEffect(<span class="hljs-function">() =&gt;</span> {
  	<span class="hljs-comment">//根据 debouncedvalue 进行搜索</span>
  },[debouncedvalue]);
};

</code></pre>
<p>在搜索场景中：</p>
<ul>
<li>只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合；</li>
<li>throttle 更适合需要实时响应用户的场景，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如window 的 resize 事件）。</li>
</ul>
<p><a name="fueVH"></a></p>
<h4>懒加载与懒渲染</h4>
<p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由；还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块（大数据量弹窗）。在这些场景下，结合 Code Split 收益较高。</p>
<p>懒加载的实现是通过 Webpack 的动态导入和 React.lazy 方法。实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png" alt="1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png"></p>
<p>而懒渲染指：当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。懒渲染的使用场景有：</p>
<ul>
<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>
<li>需用户操作后才展示的组件（这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单）。</li>
</ul>
<p>在懒渲染的实现中，判断组件是否出现在可视区域内，借助 react-visibility-observer 依赖：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> VisibilityObserver, { useVisibilityObserver } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-visibility-observer&#x27;</span>;

<span class="hljs-keyword">const</span> VisibilityObserverChildren = <span class="hljs-function">(<span class="hljs-params">{ callback, children }</span>)=&gt;</span> {
	<span class="hljs-keyword">const</span> { isVisible } = useVisibilityObserver();
  useEffect(
    <span class="hljs-function">() =&gt;</span> {
      callback(isVisible)
    },
    [callback, isVisiblel]
  );
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>{children}<span class="hljs-tag">&lt;/&gt;</span></span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LazyRender = <span class="hljs-function">() =&gt;</span> {
	<span class="hljs-keyword">const</span> [isRendered, setIsRendered] = useState(<span class="hljs-literal">false</span>);
  
  <span class="hljs-keyword">if</span> (!isRendered) {
    <span class="hljs-keyword">return</span>(
			<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">VisibilityObserver</span> <span class="hljs-attr">rootMargin</span>=<span class="hljs-string">{</span>&#x27;<span class="hljs-attr">Opx</span> <span class="hljs-attr">Opx</span> <span class="hljs-attr">Opx</span> <span class="hljs-attr">Opx</span>&#x27;}&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">VisibilityObserverChildren</span>
          <span class="hljs-attr">callback</span>=<span class="hljs-string">{isVisible</span> =&gt;</span> {
            if (isVisible) {
              setIsRendered(true);
            }
          }}
				&gt;
					<span class="hljs-tag">&lt;<span class="hljs-name">span</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">VisibilityObserverChildren</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">VisibilityObserver</span>&gt;</span></span>
		)
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> LazyRender;

</code></pre>
<p><a name="xrqiR"></a></p>
<h4>虚拟列表</h4>
<p>虚拟列表是懒渲染的一种特殊场景，虚拟列表的组件有 react-window和 react-virtualized。、</p>
<p>其中，react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好，我建议你用 react-window，只需要计算每项的高度即可（如果每项的高度是变化的，可给 itemSize 参数传一个函数）：</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { FixedSizeList <span class="hljs-keyword">as</span> List } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-window&#x27;</span>;
<span class="hljs-keyword">const</span> Row = ({ index,  style }) = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">stvle</span>=<span class="hljs-string">{style}</span>&gt;</span>Row {index}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-keyword">const</span> Example =<span class="hljs-function">() =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span>
    <span class="hljs-attr">height</span>=<span class="hljs-string">{150}</span>
    <span class="hljs-attr">itemcount</span>=<span class="hljs-string">{1000}</span>
    <span class="hljs-attr">itemsize</span>=<span class="hljs-string">{35}</span> //每项的高度为 <span class="hljs-attr">35</span>
    <span class="hljs-attr">width</span>=<span class="hljs-string">{300}</span>
	&gt;</span>
    {Row}
  <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span>
)

</code></pre>
<p>所以在开发过程中，遇到接口返回的是所有数据时，需提前预防这类会有展示的性能瓶颈的需求时，<strong>推荐使用虚拟列表优化</strong>。</p>
<p><a name="ehjVN"></a></p>
<h4>避免在 didMount、didUpdate 中更新组件 State</h4>
<p>这个技巧不仅仅适用于 didMount、didUpdate，还包括 willUnmount、useLayoutEffect 和特殊场景下的 useEffect（当父组件的 cDU/cDM 触发时，子组件的 useEffect 会同步调用），我简化一下，把它们叫作“提交阶段钩子”。</p>
<p><strong>React 工作流 Commit 阶段的第二步就是执行提交阶段钩子</strong>，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。一般在提交阶段的钩子中更新组件状态的场景有：</p>
<ul>
<li>计算并更新组件的派生状态（Derived State）。在该场景中，类组件应使用 getDerivedStateFromProps 钩子方法代替，函数组件应使用函数调用时执行 setState 的方式代替。使用上面两种方式后，React 会将新状态和派生状态在一次更新内完成。</li>
<li>根据 DOM 信息，修改组件状态。在该场景中，除非想办法不依赖 DOM 信息，否则两次更新过程是少不了的，就只能用其他优化技巧了。</li>
</ul>
<p>use-swr 的源码就使用了该优化技巧：当某个接口存在缓存数据时，use-swr 会先使用该接口的缓存数据，并在 requestIdleCallback 时再重新发起请求，获取最新数据。</p>
<p>我模拟一个 swr：</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompWithUseFetch</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">const</span> [search, setSearch] = useState(<span class="hljs-string">&quot;&quot;</span>);
  <span class="hljs-comment">//如果 search 改变就重新发起请求</span>
	<span class="hljs-keyword">const</span> { data } = useFetch(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.fetch(<span class="hljs-string">`/api/data?search=<span class="hljs-subst">${search}</span>`</span>)
	}, [search]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setSearch(e.target.value)} /&gt;
    	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  		{data || &quot;-&quot;}
  	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
	)
}

</code></pre>
<ul>
<li>它的第二个参数 deps，是为了在请求带有参数时，如果参数改变了就重新发起请求。</li>
<li>暴露给调用方的 fetch 函数，可以应对主动刷新的场景，比如页面上的刷新按钮。</li>
</ul>
<p>如果 use-swr 不做该优化的话，就会在 useLayoutEffect 中触发重新验证并设置 isValidating 状态为 true，引起组件的更新流程，造成性能损失。</p>
<p><a name="t8lZe"></a></p>
<h3>React Profiler 使用心得</h3>
<p>React Profiler 是 React 官方提供的性能审查工具，我只讲一下自己的使用心得。</p>
<p>Note：react-dom 16.5+ 在 DEV 模式下才支持 Profiling，同时生产环境下也可以通过一个 profiling bundle react-dom/profiling 来支持，你可以在 <a href="https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977">https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977</a>上查看如何使用这个 bundle。</p>
<p>“Profiler” 的面板在刚开始的时候是空的，你可以点击 record 按钮来启动 profile：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png" alt="1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png"></p>
<p><a name="Zwf4S"></a></p>
<h4>Profiler 只记录了 Render 过程耗时</h4>
<p>不要通过 Profiler 定位非 Render 过程的性能瓶颈问题，通过 React Profiler，开发者可以查看组件 Render 过程耗时，但无法知晓提交阶段的耗时。尽管 Profiler 面板中有 Committed at 字段，但这个字段是相对于录制开始时间，根本没有意义。</p>
<p>通过在 React v16 版本上进行实验，同时开启 Chrome 的 Performance 和 React Profiler 统计。</p>
<p>如下图，在 Performance 面板中，Reconciliation和Commit阶段耗时分别为 642ms 和 300ms，而 Profiler 面板中只显示了 642ms：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png" alt="1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png"></p>
<p><a name="loc6F"></a></p>
<h4>开启“记录组件更新原因”</h4>
<p>点击面板上的齿轮，然后勾选“Record why each component rendered while profiling.”，如下图：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png" alt="1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png"></p>
<p>然后点击面板中的虚拟 DOM 节点，右侧便会展示该组件重新 Render 的原因。</p>
<p><a name="SYpWs"></a></p>
<h4>定位产生本次 Render 过程原因</h4>
<p>由于 React 的批量更新（Batch Update）机制，产生一次 Render 过程可能涉及到很多个组件的状态更新，<strong>那么如何定位是哪些组件状态更新导致的呢</strong>？</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png" alt="1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png"></p>
<p>在 Profiler 面板左侧的虚拟 DOM 树结构中，从上到下审查每个发生了渲染的（不会灰色的）组件。如果组件是由于 State 或 Hook 改变触发了 Render 过程，那它就是我们要找的组件，如下图：</p>
<p><img src="https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png" alt="1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png"></p>
<p>小结<br />这一讲，我从三个方向深度剖析了 React 的性能优化，由浅及深地从业务角度入手，用例证深刻解读了在各种业务场景下，应该使用何种优化手段，核心主要概括成以下几点：</p>
<ul>
<li>了解 React 的工作流，熟悉其中各阶段的职责；</li>
<li>通过减少计算量来优化 Render 的过程；</li>
<li>通过几种技巧来精细化渲染阶段的加载速度；</li>
<li>通过控制更新的时机与范围来最大化优化效果；</li>
<li>学习 React Profiler 的使用。</li>
</ul>
<p>总的来说，性能优化没有银弹，作为技术人，需要内修于心（熟知底层原理），同时把对性能优化当作习惯，植入日常思考中去。</p>
</div></div><div class="ant-row flex justify-between my-8" style="margin-left:-6px;margin-right:-6px"><div style="padding-left:6px;padding-right:6px" class="ant-col ant-col-12"><div class="whitespace-nowrap cursor-pointer flex items-center h-full text-sm bg-black hover:bg-white hover:text-black border border-black text-white font-bold py-2 px-4 duration-200 transition-colors"><span role="img" aria-label="arrow-left" class="anticon anticon-arrow-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="arrow-left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"></path></svg></span><span class="ml-2">Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？</span></div></div><div style="padding-left:6px;padding-right:6px" class="ant-col ant-col-12"></div></div></div><div class="col-span-12 md:col-span-2 lg:col-span-3"><div><div class="flex items-center" style="padding:12px 0"><span role="img" aria-label="send" class="anticon anticon-send"><svg viewBox="64 64 896 896" focusable="false" data-icon="send" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M931.4 498.9L94.9 79.5c-3.4-1.7-7.3-2.1-11-1.2a15.99 15.99 0 00-11.7 19.3l86.2 352.2c1.3 5.3 5.2 9.6 10.4 11.3l147.7 50.7-147.6 50.7c-5.2 1.8-9.1 6-10.3 11.3L72.2 926.5c-.9 3.7-.5 7.6 1.2 10.9 3.9 7.9 13.5 11.1 21.5 7.2l836.5-417c3.1-1.5 5.6-4.1 7.2-7.1 3.9-8 .7-17.6-7.2-21.6zM170.8 826.3l50.3-205.6 295.2-101.3c2.3-.8 4.2-2.6 5-5 1.4-4.2-.8-8.7-5-10.2L221.1 403 171 198.2l628 314.9-628.2 313.2z"></path></svg></span><span class="ml-1">标签</span></div><svg width="330" height="300" class="mx-auto md:m-0"><g transform="translate(160, 150)"><text text-anchor="middle" fill="#c23531" transform="translate(6, -46)rotate(90)" style="font-size:20px"><a>体验</a></text><text text-anchor="middle" fill="#2f4554" transform="translate(-82, 74)rotate(90)" style="font-size:20px"><a>响应式</a></text><text text-anchor="middle" fill="#61a0a8" transform="translate(-32, 114)rotate(0)" style="font-size:20px"><a>自适应</a></text><text text-anchor="middle" fill="#d48265" transform="translate(-82, -28)rotate(90)" style="font-size:20px"><a>Apple</a></text><text text-anchor="middle" fill="#91c7ae" transform="translate(46, -58)rotate(90)" style="font-size:20px"><a>数字</a></text><text text-anchor="middle" fill="#749f83" transform="translate(-109, 67)rotate(90)" style="font-size:20px"><a>端到端</a></text><text text-anchor="middle" fill="#ca8622" transform="translate(-10, 0)rotate(0)" style="font-size:20px"><a>Unix</a></text><text text-anchor="middle" fill="#bda29a" transform="translate(-19, -45)rotate(90)" style="font-size:20px"><a>Linux</a></text><text text-anchor="middle" fill="#6e7074" transform="translate(38, 5)rotate(0)" style="font-size:20px"><a>UI</a></text><text text-anchor="middle" fill="#546570" transform="translate(43, -15)rotate(0)" style="font-size:20px"><a>CSS</a></text><text text-anchor="middle" fill="#c4ccd3" transform="translate(95, 2)rotate(90)" style="font-size:20px"><a>angular</a></text><text text-anchor="middle" fill="#c23531" transform="translate(-38, 62)rotate(90)" style="font-size:20px"><a>生活</a></text><text text-anchor="middle" fill="#2f4554" transform="translate(-67, -59)rotate(0)" style="font-size:20px"><a>Node</a></text><text text-anchor="middle" fill="#61a0a8" transform="translate(-39, -64)rotate(90)" style="font-size:20px"><a>H5</a></text><text text-anchor="middle" fill="#d48265" transform="translate(11, -101)rotate(90)" style="font-size:20px"><a>小程序</a></text><text text-anchor="middle" fill="#91c7ae" transform="translate(-111, -13)rotate(90)" style="font-size:20px"><a>MySQL</a></text><text text-anchor="middle" fill="#749f83" transform="translate(82, -68)rotate(0)" style="font-size:20px"><a>ssr</a></text><text text-anchor="middle" fill="#ca8622" transform="translate(111, -45)rotate(90)" style="font-size:20px"><a>VScode</a></text><text text-anchor="middle" fill="#bda29a" transform="translate(70, -94)rotate(0)" style="font-size:20px"><a>webpack</a></text><text text-anchor="middle" fill="#6e7074" transform="translate(-108, -104)rotate(90)" style="font-size:20px"><a>typescript</a></text><text text-anchor="middle" fill="#546570" transform="translate(16, 76)rotate(90)" style="font-size:23px"><a>alibaba</a></text><text text-anchor="middle" fill="#c4ccd3" transform="translate(81, 83)rotate(0)" style="font-size:23px"><a>模块化</a></text><text text-anchor="middle" fill="#c23531" transform="translate(-58, -16)rotate(90)" style="font-size:25px"><a>前端</a></text><text text-anchor="middle" fill="#2f4554" transform="translate(80, 58)rotate(0)" style="font-size:26px"><a>PWA</a></text><text text-anchor="middle" fill="#61a0a8" transform="translate(-61, 63)rotate(90)" style="font-size:30px"><a>react</a></text><text text-anchor="middle" fill="#d48265" transform="translate(-24, 29)rotate(0)" style="font-size:32px"><a>JavaScript</a></text><text text-anchor="middle" fill="#91c7ae" transform="translate(67, -35)rotate(90)" style="font-size:36px"><a>vue</a></text></g></svg></div><div class="Calendars_calendars__2VsuL"><div class="flex items-center" style="padding:12px 0"><span role="img" aria-label="send" class="anticon anticon-send"><svg viewBox="64 64 896 896" focusable="false" data-icon="send" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M931.4 498.9L94.9 79.5c-3.4-1.7-7.3-2.1-11-1.2a15.99 15.99 0 00-11.7 19.3l86.2 352.2c1.3 5.3 5.2 9.6 10.4 11.3l147.7 50.7-147.6 50.7c-5.2 1.8-9.1 6-10.3 11.3L72.2 926.5c-.9 3.7-.5 7.6 1.2 10.9 3.9 7.9 13.5 11.1 21.5 7.2l836.5-417c3.1-1.5 5.6-4.1 7.2-7.1 3.9-8 .7-17.6-7.2-21.6zM170.8 826.3l50.3-205.6 295.2-101.3c2.3-.8 4.2-2.6 5-5 1.4-4.2-.8-8.7-5-10.2L221.1 403 171 198.2l628 314.9-628.2 313.2z"></path></svg></span><span class="ml-1">博客日历</span></div><div style="width:320px;border:1px solid #f0f0f0;border-radius:2px" class="mx-auto md:m-0"><div class="ant-picker-calendar ant-picker-calendar-mini"><div style="padding:8px"><div class="ant-row ant-row-space-between ant-row-middle" style="margin-left:-4px;margin-right:-4px"><div style="padding-left:4px;padding-right:4px" class="ant-col"><a class="flex justify-center items-center px-2"><span role="img" aria-label="left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></span></a></div><div style="padding-left:4px;padding-right:4px" class="ant-col"><span>2023年01月</span></div><div style="padding-left:4px;padding-right:4px" class="ant-col"><a class="flex justify-center items-center px-2"><span role="img" aria-label="right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z"></path></svg></span></a></div></div></div><div tabindex="0" class="ant-picker-panel"><div class="ant-picker-date-panel"><div class="ant-picker-body"><table class="ant-picker-content"><thead><tr><th>一</th><th>二</th><th>三</th><th>四</th><th>五</th><th>六</th><th>日</th></tr></thead><tbody><tr><td title="2022-12-26" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">26</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2022-12-27" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">27</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2022-12-28" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">28</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2022-12-29" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">29</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2022-12-30" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">30</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2022-12-31" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-end"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">31</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-01" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-start ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">01</div><div class="ant-picker-calendar-date-content"></div></div></td></tr><tr><td title="2023-01-02" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">02</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-03" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">03</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-04" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">04</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-05" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">05</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-06" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">06</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-07" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">07</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-08" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">08</div><div class="ant-picker-calendar-date-content"></div></div></td></tr><tr><td title="2023-01-09" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">09</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-10" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">10</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-11" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">11</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-12" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">12</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-13" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">13</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-14" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">14</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-15" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">15</div><div class="ant-picker-calendar-date-content"></div></div></td></tr><tr><td title="2023-01-16" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">16</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-17" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">17</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-18" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view ant-picker-cell-today ant-picker-cell-selected"><div class="ant-picker-cell-inner ant-picker-calendar-date ant-picker-calendar-date-today"><div class="ant-picker-calendar-date-value">18</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-19" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">19</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-20" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">20</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-21" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">21</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-22" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">22</div><div class="ant-picker-calendar-date-content"></div></div></td></tr><tr><td title="2023-01-23" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">23</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-24" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">24</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-25" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">25</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-26" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">26</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-27" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">27</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-28" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">28</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-29" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">29</div><div class="ant-picker-calendar-date-content"></div></div></td></tr><tr><td title="2023-01-30" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">30</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-01-31" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-end ant-picker-cell-in-view"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">31</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-02-01" class="ant-picker-cell ant-picker-cell-disabled ant-picker-cell-start"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">01</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-02-02" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">02</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-02-03" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">03</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-02-04" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">04</div><div class="ant-picker-calendar-date-content"></div></div></td><td title="2023-02-05" class="ant-picker-cell ant-picker-cell-disabled"><div class="ant-picker-cell-inner ant-picker-calendar-date"><div class="ant-picker-calendar-date-value">05</div><div class="ant-picker-calendar-date-content"></div></div></td></tr></tbody></table></div></div></div></div></div></div><div class="WidgetItem_widgetItem__xRRGd md:max-w-xs"><div class="ant-list ant-list-sm ant-list-split"><div class="ant-list-header"><div class="flex items-center"><span role="img" aria-label="send" class="anticon anticon-send"><svg viewBox="64 64 896 896" focusable="false" data-icon="send" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M931.4 498.9L94.9 79.5c-3.4-1.7-7.3-2.1-11-1.2a15.99 15.99 0 00-11.7 19.3l86.2 352.2c1.3 5.3 5.2 9.6 10.4 11.3l147.7 50.7-147.6 50.7c-5.2 1.8-9.1 6-10.3 11.3L72.2 926.5c-.9 3.7-.5 7.6 1.2 10.9 3.9 7.9 13.5 11.1 21.5 7.2l836.5-417c3.1-1.5 5.6-4.1 7.2-7.1 3.9-8 .7-17.6-7.2-21.6zM170.8 826.3l50.3-205.6 295.2-101.3c2.3-.8 4.2-2.6 5-5 1.4-4.2-.8-8.7-5-10.2L221.1 403 171 198.2l628 314.9-628.2 313.2z"></path></svg></span><span class="ml-1">最近更新</span></div></div><div class="ant-spin-nested-loading"><div class="ant-spin-container"><ul class="ant-list-items"><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-09-23-react-performance-optimization-3-tips">React性能优化3大技巧</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-09-23 11:56:00">2021-09-23</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-05-24-typescript-actual-combat">Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-05-24 22:00:00">2021-05-24</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-03-24-thorough-react-0">深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-03-24 14:00:00">2021-03-24</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-31-react-diff">React diff 算法</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-31 19:00:00">2021-01-31</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-27-vue3-core-source-code-27">Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-27 11:00:00">2021-01-27</time></div></li></ul></div></div></div></div><div class="WidgetItem_widgetItem__xRRGd md:max-w-xs"><div class="ant-list ant-list-sm ant-list-split"><div class="ant-list-header"><div class="flex items-center"><span role="img" aria-label="send" class="anticon anticon-send"><svg viewBox="64 64 896 896" focusable="false" data-icon="send" width="1em" height="1em" fill="currentColor" aria-hidden="true"><defs><style></style></defs><path d="M931.4 498.9L94.9 79.5c-3.4-1.7-7.3-2.1-11-1.2a15.99 15.99 0 00-11.7 19.3l86.2 352.2c1.3 5.3 5.2 9.6 10.4 11.3l147.7 50.7-147.6 50.7c-5.2 1.8-9.1 6-10.3 11.3L72.2 926.5c-.9 3.7-.5 7.6 1.2 10.9 3.9 7.9 13.5 11.1 21.5 7.2l836.5-417c3.1-1.5 5.6-4.1 7.2-7.1 3.9-8 .7-17.6-7.2-21.6zM170.8 826.3l50.3-205.6 295.2-101.3c2.3-.8 4.2-2.6 5-5 1.4-4.2-.8-8.7-5-10.2L221.1 403 171 198.2l628 314.9-628.2 313.2z"></path></svg></span><span class="ml-1">更多</span></div></div><div class="ant-spin-nested-loading"><div class="ant-spin-container"><ul class="ant-list-items"><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-26-vue3-core-source-code-26">Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-26 13:00:00">2021-01-26</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-25-vue3-core-source-code-25">Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-25 10:30:00">2021-01-25</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-24-vue3-core-source-code-24">Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-24 09:30:00">2021-01-24</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-23-vue3-core-source-code-23">Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-23 00:30:00">2021-01-23</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-22-vue3-core-source-code-22">Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-22 19:30:00">2021-01-22</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-21-vue3-core-source-code-21">Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-21 22:30:00">2021-01-21</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-20-vue3-core-source-code-20">Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-20 18:30:00">2021-01-20</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-19-vue3-core-source-code-19">Vue3.0 核心源码解读 | 插槽：如何实现内容分发？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-19 16:30:00">2021-01-19</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-18-vue3-core-source-code-18">Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-18 19:00:00">2021-01-18</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-17-vue3-core-source-code-17">Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-17 22:00:00">2021-01-17</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-16-vue3-core-source-code-16">Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-16 23:30:00">2021-01-16</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-16-vue3-core-source-code-15">Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-16 22:30:00">2021-01-16</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-16-vue3-core-source-code-14">Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-16 21:00:00">2021-01-16</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-16-vue3-core-source-code-13">Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-16 11:30:00">2021-01-16</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-15-vue3-core-source-code-12">Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-15 23:00:00">2021-01-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-15-vue3-core-source-code-11">Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-15 18:00:00">2021-01-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-14-vue3-core-source-code-10">Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-14 23:30:00">2021-01-14</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-13-vue3-core-source-code-9">Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-13 22:30:00">2021-01-13</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-12-vue3-core-source-code-8">Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-12 11:59:00">2021-01-12</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-10-vue3-core-source-code-7">Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-10 23:25:00">2021-01-10</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-09-vue3-core-source-code-6">Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-09 14:25:00">2021-01-09</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2021-01-08-vue3-core-source-code-5">Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2021-01-08 23:00:00">2021-01-08</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-30-vue3-core-source-code-4">Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-30 18:00:00">2020-12-30</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-24-vue3-core-source-code-3">Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-24 13:00:00">2020-12-24</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-23-vue3-core-source-code-2">Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-23 23:00:00">2020-12-23</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-21-vue3-core-source-code-1">Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-21 23:00:00">2020-12-21</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-19-vue3-core-source-code-0">Vue3.0核心源码解读 | 一文看懂Vue3.0的优化</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-19 14:00:00">2020-12-19</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-12-17-webpack5-build-react-dev-env">Webpack5搭建React开发环境</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-12-17 18:00:00">2020-12-17</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-10-06-react17-coming">React 17来了</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-10-06 12:00:00">2020-10-06</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-09-27-react-grid-layout">React-grid-layout 一个支持拖拽的栅格布局库</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-09-27 12:00:00">2020-09-27</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-09-20-ECMAScript2020">ECMAScript2020新特性总结及使用场景</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-09-20 12:00:00">2020-09-20</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-08-22-ECMAScript2019">ECMAScript2019新特性总结及使用场景</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-08-22 12:00:00">2020-08-22</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-08-12-ECMAScript2018">ECMAScript2018新特性总结及使用场景</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-08-12 12:00:00">2020-08-12</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-08-01-vscode-code-annotation-keyword-analysis">VScode代码注释关键字解析</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-08-01 12:00:00">2020-08-01</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-07-18-ECMAScript2017">ECMAScript2017新特性总结及使用场景</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-07-18 12:00:00">2020-07-18</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2020-07-11-ECMAScript2016">ECMAScript2016新特性总结及使用场景</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2020-07-11 12:00:00">2020-07-11</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2019-12-18-immutable-react">Immutable 详解及 React 中实践</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2019-12-18 12:00:00">2019-12-18</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2019-10-24-JavaScript-prototype">JavsScript 原型</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2019-10-24 12:00:00">2019-10-24</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2019-10-23-setState-sync-or-async">setState 是同步还是异步的呢？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2019-10-23 12:00:00">2019-10-23</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2019-09-22-javascript-this-pointer">JavaScript this 对象查找</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2019-09-22 12:00:00">2019-09-22</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-12-12-commonly-used-regular-expressionsm">一些常用的正则表达式</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-12-12 12:00:00">2018-12-12</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-12-12-downloading-frontend-data-stream-files">前端数据流文件下载三种方式</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-12-12 12:00:00">2018-12-12</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-15-react-new-life-cycle-hook">React16.3+ 新的生命周期钩子</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-15 12:00:00">2018-08-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-15-vue-server-side-render">Vue 服务端渲染</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-15 12:00:00">2018-08-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-09-mysql-common-commands">MySQL 常用命令</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-09 12:00:00">2018-08-09</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-07-vue-and-wechat-small-program-differences">Vue 和微信小程序的区别、比较</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-07 12:00:00">2018-08-07</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal">H5移动端常见问题及注意事项</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-06 12:00:00">2018-08-06</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-04-Proxy-and-Reflect-of-ES6">ES6 的 Proxy 和 Reflect</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-04 12:00:00">2018-08-04</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-08-02-make-the-cli-with-node">如何用 Node 来制作 CLI</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-08-02 12:00:00">2018-08-02</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2018-07-31-about-life-and-survival">关于生活与生存</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2018-07-31 05:35:07">2018-07-31</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2017-07-12-upgrading-eleme-to-pwa">饿了么的 PWA 升级实践</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2017-07-12 12:00:00">2017-07-12</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2017-02-09-nextgen-web-pwa">下一代 Web 应用模型 —— Progressive Web App</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2017-02-09 12:00:00">2017-02-09</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2016-10-20-pwa-qcon2016">Progressive Web Apps，复兴序章「QCon 上海 2016」</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2016-10-20 12:00:00">2016-10-20</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2016-06-05-pwa-in-my-pov">Progressive Web App 之我见</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2016-06-05 12:00:00">2016-06-05</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2016-02-01-React-vs-Angular2">React vs Angular 2：冰与火之歌「译」</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2016-02-01 12:00:00">2016-02-01</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-12-28-css-sucks-2015">都2015年了，CSS怎么还是这么糟糕</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-12-28 12:00:00">2015-12-28</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-12-15-ios9-safari-web">iOS 9，为前端世界都带来了些什么？「译」</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-12-15 12:00:00">2015-12-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-10-28-how-designer-learn-fe">设计师如何学习前端？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-10-28 12:00:00">2015-10-28</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-09-22-js-version">ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-09-22 12:00:00">2015-09-22</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-07-09-js-module-7day">JavaScript 模块化七日谈</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-07-09 12:00:00">2015-07-09</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-06-15-alitrip-strategy">聊聊「阿里旅行 · 去啊」—— 行业与战略</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-06-15 12:00:00">2015-06-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-05-25-js-module-loader">JavaScript模块化加载</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-05-25 12:00:00">2015-05-25</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-04-15-os-metro">操作系统的浪漫主义 —— Metro 篇</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-04-15 12:00:00">2015-04-15</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-04-14-unix-linux-note">Unix/Linux 扫盲笔记</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-04-14 12:00:00">2015-04-14</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-03-31-e2e_user_scenarios">端到端用户场景的定义</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-03-31 12:00:00">2015-03-31</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-03-25-digital-native">Digital native 数字原住民</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-03-25 12:00:00">2015-03-25</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2015-03-10-apple-event-2015">如何评价2015年3月9日Apple春季发布会</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2015-03-10 12:00:00">2015-03-10</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2014-11-20-responsive-web-design">你们觉得响应式好呢，还是手机和PC端分开来写？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2014-11-20 12:00:00">2014-11-20</time></div></li><li style="padding:8px 4px" class="ant-list-item flex-wrap"><div class="block truncate"><a href="/posts/2014-10-01-why-alibaba-ux-sucks">为什么阿里系软件体验都不好？</a></div><div class="text-gray-500 w-full text-right">--<time dateTime="2014-10-01 12:00:00">2014-10-01</time></div></li></ul></div></div></div></div></div></div></main><div class="ant-back-top"></div></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"><div class="pt-10 flex flex-col items-center"><div class="flex flex-col lg:flex-row justify-center items-center"><a href="https://github.com/boychina/blog-eggcake" class="text-sm mx-3 hover:underline" target="_blank"><div class="flex items-center"><span role="img" aria-label="github" class="anticon anticon-github mr-1"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span> GitHub</div></a><span>©2020-<!-- -->2023<!-- --> 蛋烘糕</span></div></div><div class="text-sm mt-2 pb-8 text-gray-500 flex justify-center"><a href="http://beian.miit.gov.cn" target="_blank">ICP备案号：蜀ICP备2020034346号-1</a><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51010802001016" class="ml-2 flex"><img src="/assets/备案图标.png" class="w-4 h-4"/>川公网安备 51010802001016号</a></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","slug":"2021-05-24-typescript-actual-combat"},"nextPost":null},"post":{"title":"React性能优化3大技巧","description":"React性能优化3大技巧","keyword":"react","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"\u003cp\u003e在业务迭代过程中，React 性能优化是我们不得不考虑的问题，虽然项目在启动之初，我们一般不会考虑项目的复杂度，而且因为产品的用户体量和技术场景也不复杂，并不需要考虑性能优化，但是随着业务场景的复杂化，性能优化就变得格外重要了。\u003c/p\u003e\n\u003cp\u003e我们从 React 源码入手，以有具体业务为例，运用 3 大优化技巧对系统进行“外科手术式”的优化，同时深入刨析 React Profiler，利用这款性能优化利器，帮我们定位性能瓶颈。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003cbr /\u003e页面加载流程\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e假设用户首次打开页面（无缓存），这个时候页面是完全空白的；\u003c/li\u003e\n\u003cli\u003eHTML 和引用的 CSS 加载完毕，浏览器进行首次渲染；\u003c/li\u003e\n\u003cli\u003eReact、ReactDom、业务代码加载完毕，应用第一次渲染（或者说首次内容渲染）；\u003c/li\u003e\n\u003cli\u003e应用代码开始执行，拉取数据、进行动态 import、响应事件……完毕后页面进入可交互状态；\u003c/li\u003e\n\u003cli\u003eLazy Load 的图片等多媒体内容开始逐渐加载完毕；\u003c/li\u003e\n\u003cli\u003e直到页面的其他资源（如错误上报组件、打点上报组件等）加载完毕，整个页面加载完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接下来，我们主要来针对 React 剖析它渲染性能优化的三个方向（这三个方向也适用于其他软件开发领域）。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e减少计算的量：在 React 中，就是减少渲染的节点，或通过索引减少渲染复杂度。\u003c/li\u003e\n\u003cli\u003e利用缓存：在 React 中，就是避免重新渲染（利用 memo 方式来避免组件重新渲染）。\u003c/li\u003e\n\u003cli\u003e精确重新计算的范围：在 React 中，就是绑定组件和状态关系，精确判断更新的“时机”和“范围”，只重新渲染变更的组件（减少渲染范围）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如何做到这三点呢？\u003cstrong\u003e我们从 React 本身的特性入手分析。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"wU2DA\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eReact 的工作流\u003c/h3\u003e\n\u003cp\u003eReact 是声明式 UI 库，负责把 State 转换成页面结构后（虚拟 DOM 结构），再转换成真实 DOM 结构，交给浏览器渲染。State 发生改变时，React 会先进行 Reconciliation，结束后立刻进入 Commit 阶段，Commit结束后，新 State 对应的页面才被展示出来。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，React 的 Reconciliation 需要做两件事：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e计算出目标 State 对应的虚拟 DOM 结构；\u003c/li\u003e\n\u003cli\u003e寻找“将虚拟 DOM 结构修改为目标虚拟 DOM 结构”的最优方案。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReact 按照深度优先遍历虚拟 DOM 树的方式，在一个虚拟 DOM 上完成 Render 和 Diff 的计算后，再计算下一个虚拟 DOM，Diff 算法会记录虚拟 DOM 的更新方式（如：Update、Mount、Unmount），为 Commit 做准备。\u003c/p\u003e\n\u003cp\u003e而 React 的 Commit 也需要做两件事：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将 Reconciliation 结果应用到 DOM 中；\u003c/li\u003e\n\u003cli\u003e调用暴露的 Hooks 如：componentDidUpdate、useLayoutEffect 等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e了解完 React 的工作流之后，我们就针对三个优化方向精准分析。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"uX8Qs\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e如何减少计算的量\u003c/h3\u003e\n\u003cp\u003e关于 Reconciliation、Commit 两个阶段的优化办法，我遵循减少计算量（列表项使用 key 属性)的方式，React 内部的 Fiber 结构和并发模式也是在减少该过程的耗时阻塞。\u003c/p\u003e\n\u003cp\u003e对于 Commit 在执行Hooks 时，开发者应保证 Hooks 中的代码尽量轻量、避免耗时阻塞，同时应避免在 CDM、CDU 周期中更新组件。\u003c/p\u003e\n\u003cp\u003e假如你没有在列表中添加 key 属性，控制台会展示一片大红（系统会时刻提醒你记得加 Key）\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"FSoH8\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e优化 Render 过程\u003c/h3\u003e\n\u003cp\u003eRender 过程即 Reconciliation 中计算出目标 State 对应的虚拟 DOM 结构。触发 React 组件的 Render 过程目前有三种方式：forceUpdate、State 更新、父组件 Render 触发子组件 Render 过程。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"xmvXV\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e优化技巧一：PureComponent、React.memo\u003c/h4\u003e\n\u003cp\u003e在 React 工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。\u003c/p\u003e\n\u003cp\u003e从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变，当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。\u003c/p\u003e\n\u003cp\u003ePureComponent 和 React.memo应对了这种场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePureComponent 是对类组件的 Props 和 State 进行浅比较；\u003c/li\u003e\n\u003cli\u003eReact.memo 是对函数组件的 Props 进行浅比较。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca name=\"Pac5h\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e优化技巧二：useMemo、useCallback 实现稳定的 Props 值\u003c/h4\u003e\n\u003cp\u003e如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效，所以需要用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"M6TAg\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e优化技巧三：useMemo 减少组件 Render 过程耗时\u003c/h4\u003e\n\u003cp\u003euseMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算，一般用在“计算派生状态的代码”非常耗时的场景中（比如遍历大列表做统计信息）。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 大列表渲染\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e renderTable = useMemo(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u0026lt;Table\u0026lt;TS.OrderPollData\u0026gt;\n      bordered\n      scroll={{ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;max-content\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e620\u003c/span\u003e }}\n      rowClassName={styles.tableLine}\n      columns={tableColumns}\n    \tdataSource={dataSource}\n    \tloading={loading}\n    \tpagination={\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e}\n  \t/\u0026gt;\n  );\n}, [loading, datasource, pageConfig, tablecolumns])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e显然，useMemo的作用是缓存昂贵的计算(避免在每次渲染时都进行高开销的计算)，在业务中使用它去控制变量来更新表格。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"yvRVR\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e优化技巧四：shouldComponentUpdate\u003c/h4\u003e\n\u003cp\u003e在类组件中，例如要往数组中添加一项数据时，当时的代码很可能是 state.push(item)，而不是 const newState = [...state, item]。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eshouldComponentUpdate = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enextProps:PromiseRenderProps\u0026lt;T, K\u0026gt;, nextState: PromiseRenderState\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { component } = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.state;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isEqual(nextProps, \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.props)) {\n    \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.setRenderComponent(nextProps);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextState.component !== component) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在此背景下，当时的开发者经常使用 shouldComponentUpdate 来深比较 Props，只在 Props 有修改才执行组件的 Render 过程，如今由于数据不可变性和函数组件的流行，这样的优化场景已经很少再出现了。\u003c/p\u003e\n\u003cp\u003e为了贴合 shouldComponentUpdate 的思想：给子组件传 Props 时一定只传其需要的，而并非一股脑全部传入。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e AbleHiddenFiltersprops = useMemo(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\t\thideFilters,\n\t\tgradeInfo,\n    subjectInfo,\n    ......\n\t\tsetHideFilters,\n\t\tfindOrderValue\n  }\n}, [gradeInfo, subjectInfo, hideFilters, studentId, findorderValue]);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e CommonFiltersProps = useMemo(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\t\tuser,\n    userId,\n    orgInfo,\n    pickerValue,\n    ......\n    studentId,\n    userDisabled,\n    userData,\n    organizationData,\n  }\n}, [userId, orgInfo, pickerValue, studentId, isShowOrg, cUserFilteRef, initialOwnerListRef?.current]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e传入子组件的参数一定保证其在自组件中被使用到。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"i5nrj\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e批量更新，减少 Render 次数\u003c/h3\u003e\n\u003cp\u003e在 React 管理的事件回调和生命周期中，setState 是异步的，其他时候 setState 是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候是立即更新的。\u003c/p\u003e\n\u003cp\u003e批量更新 setState 时，\u003cstrong\u003e多次执行 setState 只会触发一次 Render 过程\u003c/strong\u003e。相反在立即更新 setState 时，每次 setState 都会触发一次 Render 过程，就存在性能影响。\u003c/p\u003e\n\u003cp\u003e假设有如下组件代码，该组件在 getData() 的 API 请求结果返回后，分别更新了两个 State 。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNormalComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [list, setList] = useState(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [info, setInfo] = useState(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n  useEffect(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n    ;(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n\t\t\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e getData();\n\t\t\tsetList(data.list);\n      setInfo (data.info);\n    )();\n\t}, []);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\t\t\t非批量更新组件时 Render 次数:\n      {renderOnce(\u0026#x27;normal\u0026#x27;)}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\t)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该组件会在 setList(data.list) 后，触发组件的 Render 过程，然后在 setInfo(\u003ca href=\"http://data.info\"\u003edata.info\u003c/a\u003e) 后再次触发 Render 过程，造成性能损失，\u003cstrong\u003e那我们该如何解决呢？\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将多个 State 合并为单个 State，比如 useState({ list: null, info: null }) 替代 list 和 info 两个 State。\u003c/li\u003e\n\u003cli\u003e使用 React 官方提供的 unstable_batchedUpdates 方法，将多次 setState 封装到 unstable_batchedUpdates 回调中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e修改后代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBatchedComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [list, setList] = useState(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [info, setInfo] = useState(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n\tuseEffect(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\t\t;(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data= \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e getData();\n\t\t\tunstable_batchedUpdates(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n        setList(data.list);\n\t\t\t\tsetInfo(data.info);\n      });\n    })()\n  }, [])\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      批量更新组件时 Render 次数：\n      {renderOnce(\u0026#x27;batched\u0026#x27;)}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca name=\"dbUs8\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e精细化渲染阶段\u003c/h3\u003e\n\u003cp\u003e\u003ca name=\"urvIk\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e按优先级更新，及时响应用户\u003c/h4\u003e\n\u003cp\u003e如果页面弹出一个 Modal，当用户点击 Modal 中的确定按钮后，代码将执行两个操作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e关闭 Modal；\u003c/li\u003e\n\u003cli\u003e页面处理 Modal 传回的数据并展示给用户。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当操作 2 需要执行 500ms 时，用户会明显感觉到从点击按钮到 Modal 被关闭之间的延迟。下图为一般的实现方式，将 slowHandle 函数作为用户点击按钮的回调函数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 非延迟执行\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slowHandle = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  setShowInput(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n  setNumbers ([...numbers, +inputValue].sort(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) =\u0026gt;\u003c/span\u003e a - b) ));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eslowHandle() 执行过程耗时长，用户点击按钮后会明显感觉到页面卡顿。\u003c/p\u003e\n\u003cp\u003e如果让页面优先隐藏输入框，用户就能立刻感知到页面更新，不会有卡顿感。\u003cstrong\u003e而实现优先级更新的要点是：将耗时任务移动到下一个宏任务中执行，优先响应用户行为。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e比如在示例中，将 setNumbers 移动到 setTimeout 的回调中，用户点击按钮后能立刻看到输入框被隐藏，不会感知到页面卡顿。项目中优化后的代码如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 延迟执行\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fastHandle = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\t\u003cspan class=\"hljs-comment\"\u003e// 优先响应用户行为\u003c/span\u003e\n\tsetShowInput(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\t\u003cspan class=\"hljs-comment\"\u003e// 将耗时任务移动到下一个宏任务执行\u003c/span\u003e\n\t\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\t\tsetNumbers([...numbers, +inputValue].sort(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) =\u0026gt;\u003c/span\u003e a - b));\n  })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca name=\"xXjN4\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e发布者订阅者跳过中间组件 Render 过程\u003c/h4\u003e\n\u003cp\u003eReact 推荐将公共数据放在所有“需要该状态的组件”的公共组件上，但是将状态放在公共组件上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e传统 Redux 数据流\u003c/p\u003e\n\u003cp\u003e可以看到，每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下，\u003cstrong\u003e可以将状态用“发布者、订阅者模式”维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。\u003c/p\u003e\n\u003cp\u003e只要是发布者订阅者模式的库，都可以使用 useContext 进行该优化。比如 redux、use-global-state、React.createContext 等。\u003c/p\u003e\n\u003cp\u003e业务代码中的使用如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从图中可看出，优化后只有使用了公共状态的组件 renderTable 才会发生更新，可以大大减少父组件和其他 renderSon 组件的 Render 次数(减少叶子节点的重渲染)。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"uk68B\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003euseMemo 返回虚拟 DOM 可跳过该组件 Render 过程\u003c/h4\u003e\n\u003cp\u003e利用 useMemo 可以缓存计算结果的特点，如果 useMemo 返回的是组件的虚拟 DOM，那么将在 useMemo 依赖不变时，跳过组件的 Render 阶段。该方式与 React.memo 类似，但与 React.memo 相比有以下优势。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更方便：React.memo 需要对组件进行一次包装，生成新的组件，而 useMemo 只需在存在性能瓶颈的地方使用，不用修改组件。\u003c/li\u003e\n\u003cli\u003e更灵活：useMemo 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 useDeepCompareMemo 对用到的值进行深比较。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e该例子中，父组件状态更新后，不使用 useMemo 的子组件会执行 Render 过程，而使用 useMemo 的子组件会按需执行更新。\u003c/p\u003e\n\u003cp\u003e业务代码中的使用方法如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"exACa\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e精确判断更新的“时机”和“范围”\u003c/h3\u003e\n\u003cp\u003e\u003ca name=\"xWbRv\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003edebounce、throttle 优化频繁触发的回调\u003c/h4\u003e\n\u003cp\u003e在搜索组件中，当 input 中内容修改时就触发搜索回调，当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。\u003c/p\u003e\n\u003cp\u003e在搜索场景中一般使用 useDebounce+ useEffect 的方式获取数据。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * 使用ref存储setTimeout 返回的值，避免普通防抖函数在函数组件中使用时依赖变化导致setTimeout唯一标识符丟失\n * \u003cspan class=\"hljs-doctag\"\u003e@param \u003c/span\u003efun 防抖目标函数\n * \u003cspan class=\"hljs-doctag\"\u003e@param \u003c/span\u003edelay 防抖时间\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003euseDebounce\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eT\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eunknown\u003c/span\u003e[]\u0026gt;(\u003cspan class=\"hljs-params\"\u003efun:(...args: T) =\u0026gt; unknown, delay: number = \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ref = useRef\u0026lt;any\u0026gt;();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args: T\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// ats-ignore\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e that = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(ref.current);\n    ref.current = \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(() - fun.apply\u0026lt;any,T, unknown\u0026gt;(that, args), delay);\n  };\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * 节流 delay 内时间内只能触发1次回调\n * \u003cspan class=\"hljs-doctag\"\u003e@param \u003c/span\u003efun 函数\n * \u003cspan class=\"hljs-doctag\"\u003e@param \u003c/span\u003edelay 间隔时间\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003euseThrottle\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eT\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eunknown\u003c/span\u003e[], \u003cspan class=\"hljs-title\"\u003eR\u003c/span\u003e = \u003cspan class=\"hljs-title\"\u003eany\u003c/span\u003e\u0026gt;(\u003cspan class=\"hljs-params\"\u003efun:(...args: T) =\u0026gt; R, delay: number = \u003cspan class=\"hljs-number\"\u003e700\u003c/span\u003e\u003c/span\u003e) \u003c/span\u003e{\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ref = useRef\u0026lt;number\u0026gt;(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args: T\u003c/span\u003e): \u003cspan class=\"hljs-title\"\u003eR\u003c/span\u003e | \u003cspan class=\"hljs-title\"\u003eundefined\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e date = \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e.now();\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ref.current + delay \u0026gt; date) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    ref.current = date;\n    \u003cspan class=\"hljs-comment\"\u003e// @ts-ignore\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e that = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fun.apply\u0026lt;any, T, R\u0026gt;(that, args);\n  }\n}\n\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [text, setText] = useState(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [debouncedValue] = useDebounce(text, \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e);\n\tuseEffect(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \t\u003cspan class=\"hljs-comment\"\u003e//根据 debouncedvalue 进行搜索\u003c/span\u003e\n  },[debouncedvalue]);\n};\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在搜索场景中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合；\u003c/li\u003e\n\u003cli\u003ethrottle 更适合需要实时响应用户的场景，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如window 的 resize 事件）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca name=\"fueVH\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e懒加载与懒渲染\u003c/h4\u003e\n\u003cp\u003e在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由；还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块（大数据量弹窗）。在这些场景下，结合 Code Split 收益较高。\u003c/p\u003e\n\u003cp\u003e懒加载的实现是通过 Webpack 的动态导入和 React.lazy 方法。实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"\u003e\u003c/p\u003e\n\u003cp\u003e而懒渲染指：当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。懒渲染的使用场景有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。\u003c/li\u003e\n\u003cli\u003e需用户操作后才展示的组件（这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在懒渲染的实现中，判断组件是否出现在可视区域内，借助 react-visibility-observer 依赖：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e VisibilityObserver, { useVisibilityObserver } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react-visibility-observer\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e VisibilityObserverChildren = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ callback, children }\u003c/span\u003e)=\u0026gt;\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { isVisible } = useVisibilityObserver();\n  useEffect(\n    \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n      callback(isVisible)\n    },\n    [callback, isVisiblel]\n  );\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e LazyRender = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [isRendered, setIsRendered] = useState(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isRendered) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e(\n\t\t\t\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eVisibilityObserver\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erootMargin\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026#x27;\u003cspan class=\"hljs-attr\"\u003eOpx\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eOpx\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eOpx\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eOpx\u003c/span\u003e\u0026#x27;}\u0026gt;\u003c/span\u003e\n\t\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eVisibilityObserverChildren\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ecallback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{isVisible\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n            if (isVisible) {\n              setIsRendered(true);\n            }\n          }}\n\t\t\t\t\u0026gt;\n\t\t\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eVisibilityObserverChildren\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eVisibilityObserver\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\t\t)\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e LazyRender;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca name=\"xrqiR\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e虚拟列表\u003c/h4\u003e\n\u003cp\u003e虚拟列表是懒渲染的一种特殊场景，虚拟列表的组件有 react-window和 react-virtualized。、\u003c/p\u003e\n\u003cp\u003e其中，react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好，我建议你用 react-window，只需要计算每项的高度即可（如果每项的高度是变化的，可给 itemSize 参数传一个函数）：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { FixedSizeList \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e List } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react-window\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Row = ({ index,  style }) = \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estvle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{style}\u003c/span\u003e\u0026gt;\u003c/span\u003eRow {index}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Example =\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eList\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{150}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eitemcount\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{1000}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eitemsize\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{35}\u003c/span\u003e //每项的高度为 \u003cspan class=\"hljs-attr\"\u003e35\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{300}\u003c/span\u003e\n\t\u0026gt;\u003c/span\u003e\n    {Row}\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eList\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以在开发过程中，遇到接口返回的是所有数据时，需提前预防这类会有展示的性能瓶颈的需求时，\u003cstrong\u003e推荐使用虚拟列表优化\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"ehjVN\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e避免在 didMount、didUpdate 中更新组件 State\u003c/h4\u003e\n\u003cp\u003e这个技巧不仅仅适用于 didMount、didUpdate，还包括 willUnmount、useLayoutEffect 和特殊场景下的 useEffect（当父组件的 cDU/cDM 触发时，子组件的 useEffect 会同步调用），我简化一下，把它们叫作“提交阶段钩子”。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eReact 工作流 Commit 阶段的第二步就是执行提交阶段钩子\u003c/strong\u003e，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。一般在提交阶段的钩子中更新组件状态的场景有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e计算并更新组件的派生状态（Derived State）。在该场景中，类组件应使用 getDerivedStateFromProps 钩子方法代替，函数组件应使用函数调用时执行 setState 的方式代替。使用上面两种方式后，React 会将新状态和派生状态在一次更新内完成。\u003c/li\u003e\n\u003cli\u003e根据 DOM 信息，修改组件状态。在该场景中，除非想办法不依赖 DOM 信息，否则两次更新过程是少不了的，就只能用其他优化技巧了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003euse-swr 的源码就使用了该优化技巧：当某个接口存在缓存数据时，use-swr 会先使用该接口的缓存数据，并在 requestIdleCallback 时再重新发起请求，获取最新数据。\u003c/p\u003e\n\u003cp\u003e我模拟一个 swr：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCompWithUseFetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [search, setSearch] = useState(\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e//如果 search 改变就重新发起请求\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data } = useFetch(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.fetch(\u003cspan class=\"hljs-string\"\u003e`/api/data?search=\u003cspan class=\"hljs-subst\"\u003e${search}\u003c/span\u003e`\u003c/span\u003e)\n\t}, [search]);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\t\t\t\t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{e\u003c/span\u003e =\u0026gt;\u003c/span\u003e setSearch(e.target.value)} /\u0026gt;\n    \t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \t\t{data || \u0026quot;-\u0026quot;}\n  \t\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\t)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e它的第二个参数 deps，是为了在请求带有参数时，如果参数改变了就重新发起请求。\u003c/li\u003e\n\u003cli\u003e暴露给调用方的 fetch 函数，可以应对主动刷新的场景，比如页面上的刷新按钮。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果 use-swr 不做该优化的话，就会在 useLayoutEffect 中触发重新验证并设置 isValidating 状态为 true，引起组件的更新流程，造成性能损失。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"t8lZe\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eReact Profiler 使用心得\u003c/h3\u003e\n\u003cp\u003eReact Profiler 是 React 官方提供的性能审查工具，我只讲一下自己的使用心得。\u003c/p\u003e\n\u003cp\u003eNote：react-dom 16.5+ 在 DEV 模式下才支持 Profiling，同时生产环境下也可以通过一个 profiling bundle react-dom/profiling 来支持，你可以在 \u003ca href=\"https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977\"\u003ehttps://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977\u003c/a\u003e上查看如何使用这个 bundle。\u003c/p\u003e\n\u003cp\u003e“Profiler” 的面板在刚开始的时候是空的，你可以点击 record 按钮来启动 profile：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png\" alt=\"1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"Zwf4S\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003eProfiler 只记录了 Render 过程耗时\u003c/h4\u003e\n\u003cp\u003e不要通过 Profiler 定位非 Render 过程的性能瓶颈问题，通过 React Profiler，开发者可以查看组件 Render 过程耗时，但无法知晓提交阶段的耗时。尽管 Profiler 面板中有 Committed at 字段，但这个字段是相对于录制开始时间，根本没有意义。\u003c/p\u003e\n\u003cp\u003e通过在 React v16 版本上进行实验，同时开启 Chrome 的 Performance 和 React Profiler 统计。\u003c/p\u003e\n\u003cp\u003e如下图，在 Performance 面板中，Reconciliation和Commit阶段耗时分别为 642ms 和 300ms，而 Profiler 面板中只显示了 642ms：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png\" alt=\"1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"loc6F\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e开启“记录组件更新原因”\u003c/h4\u003e\n\u003cp\u003e点击面板上的齿轮，然后勾选“Record why each component rendered while profiling.”，如下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png\" alt=\"1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后点击面板中的虚拟 DOM 节点，右侧便会展示该组件重新 Render 的原因。\u003c/p\u003e\n\u003cp\u003e\u003ca name=\"SYpWs\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e定位产生本次 Render 过程原因\u003c/h4\u003e\n\u003cp\u003e由于 React 的批量更新（Batch Update）机制，产生一次 Render 过程可能涉及到很多个组件的状态更新，\u003cstrong\u003e那么如何定位是哪些组件状态更新导致的呢\u003c/strong\u003e？\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png\" alt=\"1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在 Profiler 面板左侧的虚拟 DOM 树结构中，从上到下审查每个发生了渲染的（不会灰色的）组件。如果组件是由于 State 或 Hook 改变触发了 Render 过程，那它就是我们要找的组件，如下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://assets.eggcake.cn/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png\" alt=\"1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e小结\u003cbr /\u003e这一讲，我从三个方向深度剖析了 React 的性能优化，由浅及深地从业务角度入手，用例证深刻解读了在各种业务场景下，应该使用何种优化手段，核心主要概括成以下几点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e了解 React 的工作流，熟悉其中各阶段的职责；\u003c/li\u003e\n\u003cli\u003e通过减少计算量来优化 Render 的过程；\u003c/li\u003e\n\u003cli\u003e通过几种技巧来精细化渲染阶段的加载速度；\u003c/li\u003e\n\u003cli\u003e通过控制更新的时机与范围来最大化优化效果；\u003c/li\u003e\n\u003cli\u003e学习 React Profiler 的使用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总的来说，性能优化没有银弹，作为技术人，需要内修于心（熟知底层原理），同时把对性能优化当作习惯，植入日常思考中去。\u003c/p\u003e\n","ogImage":{"url":"http://assets.eggcake.cn/cover/2021-09-23-React性能优化3大技巧.png"},"coverImage":"http://assets.eggcake.cn/cover/2021-09-23-React性能优化3大技巧.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2021-09-23-react-performance-optimization-3-tips"},"buildId":"R2cwfN4VfuXWj8uR2ypDl","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-040103c5c51c5268569e.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.d2ae4074d0a54d95f68e.js" async=""></script><script src="/_next/static/chunks/commons.aa38fa4438674e4829e3.js" async=""></script><script src="/_next/static/chunks/main-289a634af5672dccc790.js" async=""></script><script src="/_next/static/chunks/88ba77ff.ddce25b62cf34b951439.js" async=""></script><script src="/_next/static/chunks/7fc15881135854c491ac39d12fa6613ab66b01b2.c42c97147b951804797d.js" async=""></script><script src="/_next/static/chunks/pages/_app-d7fdca0a1114199b8fb8.js" async=""></script><script src="/_next/static/chunks/29107295.a17518e86625a3a5a388.js" async=""></script><script src="/_next/static/chunks/75fc9c18.93c7b383c2ac9fbfc4eb.js" async=""></script><script src="/_next/static/chunks/7003c6d6bfd23e1c87ce347f6e370329b7a168b3.05d2a21d83a8f633eaf7.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e52ee22239e463e4ff9f.js" async=""></script><script src="/_next/static/R2cwfN4VfuXWj8uR2ypDl/_buildManifest.js" async=""></script><script src="/_next/static/R2cwfN4VfuXWj8uR2ypDl/_ssgManifest.js" async=""></script><script src="https://hm.baidu.com/hm.js?984a14f3e0e615ff993c5631e3c3e660"></script></body></html>