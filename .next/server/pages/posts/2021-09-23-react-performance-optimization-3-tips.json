{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","slug":"2021-05-24-typescript-actual-combat"},"nextPost":null},"post":{"title":"React性能优化3大技巧","description":"React性能优化3大技巧","keyword":"react","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<p>在业务迭代过程中，React 性能优化是我们不得不考虑的问题，虽然项目在启动之初，我们一般不会考虑项目的复杂度，而且因为产品的用户体量和技术场景也不复杂，并不需要考虑性能优化，但是随着业务场景的复杂化，性能优化就变得格外重要了。</p>\n<p>我们从 React 源码入手，以有具体业务为例，运用 3 大优化技巧对系统进行“外科手术式”的优化，同时深入刨析 React Profiler，利用这款性能优化利器，帮我们定位性能瓶颈。</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"><br />页面加载流程</p>\n<ul>\n<li>假设用户首次打开页面（无缓存），这个时候页面是完全空白的；</li>\n<li>HTML 和引用的 CSS 加载完毕，浏览器进行首次渲染；</li>\n<li>React、ReactDom、业务代码加载完毕，应用第一次渲染（或者说首次内容渲染）；</li>\n<li>应用代码开始执行，拉取数据、进行动态 import、响应事件……完毕后页面进入可交互状态；</li>\n<li>Lazy Load 的图片等多媒体内容开始逐渐加载完毕；</li>\n<li>直到页面的其他资源（如错误上报组件、打点上报组件等）加载完毕，整个页面加载完成。</li>\n</ul>\n<p>接下来，我们主要来针对 React 剖析它渲染性能优化的三个方向（这三个方向也适用于其他软件开发领域）。</p>\n<ul>\n<li>减少计算的量：在 React 中，就是减少渲染的节点，或通过索引减少渲染复杂度。</li>\n<li>利用缓存：在 React 中，就是避免重新渲染（利用 memo 方式来避免组件重新渲染）。</li>\n<li>精确重新计算的范围：在 React 中，就是绑定组件和状态关系，精确判断更新的“时机”和“范围”，只重新渲染变更的组件（减少渲染范围）。</li>\n</ul>\n<p>如何做到这三点呢？<strong>我们从 React 本身的特性入手分析。</strong></p>\n<p><a name=\"wU2DA\"></a></p>\n<h3>React 的工作流</h3>\n<p>React 是声明式 UI 库，负责把 State 转换成页面结构后（虚拟 DOM 结构），再转换成真实 DOM 结构，交给浏览器渲染。State 发生改变时，React 会先进行 Reconciliation，结束后立刻进入 Commit 阶段，Commit结束后，新 State 对应的页面才被展示出来。</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p>其中，React 的 Reconciliation 需要做两件事：</p>\n<ul>\n<li>计算出目标 State 对应的虚拟 DOM 结构；</li>\n<li>寻找“将虚拟 DOM 结构修改为目标虚拟 DOM 结构”的最优方案。</li>\n</ul>\n<p>React 按照深度优先遍历虚拟 DOM 树的方式，在一个虚拟 DOM 上完成 Render 和 Diff 的计算后，再计算下一个虚拟 DOM，Diff 算法会记录虚拟 DOM 的更新方式（如：Update、Mount、Unmount），为 Commit 做准备。</p>\n<p>而 React 的 Commit 也需要做两件事：</p>\n<ul>\n<li>将 Reconciliation 结果应用到 DOM 中；</li>\n<li>调用暴露的 Hooks 如：componentDidUpdate、useLayoutEffect 等。</li>\n</ul>\n<p>了解完 React 的工作流之后，我们就针对三个优化方向精准分析。</p>\n<p><a name=\"uX8Qs\"></a></p>\n<h3>如何减少计算的量</h3>\n<p>关于 Reconciliation、Commit 两个阶段的优化办法，我遵循减少计算量（列表项使用 key 属性)的方式，React 内部的 Fiber 结构和并发模式也是在减少该过程的耗时阻塞。</p>\n<p>对于 Commit 在执行Hooks 时，开发者应保证 Hooks 中的代码尽量轻量、避免耗时阻塞，同时应避免在 CDM、CDU 周期中更新组件。</p>\n<p>假如你没有在列表中添加 key 属性，控制台会展示一片大红（系统会时刻提醒你记得加 Key）</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p><a name=\"FSoH8\"></a></p>\n<h3>优化 Render 过程</h3>\n<p>Render 过程即 Reconciliation 中计算出目标 State 对应的虚拟 DOM 结构。触发 React 组件的 Render 过程目前有三种方式：forceUpdate、State 更新、父组件 Render 触发子组件 Render 过程。</p>\n<p><a name=\"xmvXV\"></a></p>\n<h4>优化技巧一：PureComponent、React.memo</h4>\n<p>在 React 工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。</p>\n<p>从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变，当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。</p>\n<p>PureComponent 和 React.memo应对了这种场景：</p>\n<ul>\n<li>PureComponent 是对类组件的 Props 和 State 进行浅比较；</li>\n<li>React.memo 是对函数组件的 Props 进行浅比较。</li>\n</ul>\n<p><a name=\"Pac5h\"></a></p>\n<h4>优化技巧二：useMemo、useCallback 实现稳定的 Props 值</h4>\n<p>如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效，所以需要用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render。</p>\n<p><a name=\"M6TAg\"></a></p>\n<h4>优化技巧三：useMemo 减少组件 Render 过程耗时</h4>\n<p>useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算，一般用在“计算派生状态的代码”非常耗时的场景中（比如遍历大列表做统计信息）。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 大列表渲染</span>\n<span class=\"hljs-keyword\">const</span> renderTable = useMemo(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;Table&lt;TS.OrderPollData&gt;\n      bordered\n      scroll={{ <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">&#x27;max-content&#x27;</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">620</span> }}\n      rowClassName={styles.tableLine}\n      columns={tableColumns}\n    \tdataSource={dataSource}\n    \tloading={loading}\n    \tpagination={<span class=\"hljs-literal\">false</span>}\n  \t/&gt;\n  );\n}, [loading, datasource, pageConfig, tablecolumns])\n</code></pre>\n<p>显然，useMemo的作用是缓存昂贵的计算(避免在每次渲染时都进行高开销的计算)，在业务中使用它去控制变量来更新表格。</p>\n<p><a name=\"yvRVR\"></a></p>\n<h4>优化技巧四：shouldComponentUpdate</h4>\n<p>在类组件中，例如要往数组中添加一项数据时，当时的代码很可能是 state.push(item)，而不是 const newState = [...state, item]。</p>\n<pre class=\"hljs\"><code>shouldComponentUpdate = <span class=\"hljs-function\">(<span class=\"hljs-params\">nextProps:PromiseRenderProps&lt;T, K&gt;, nextState: PromiseRenderState</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> { component } = <span class=\"hljs-built_in\">this</span>.state;\n  <span class=\"hljs-keyword\">if</span> (!isEqual(nextProps, <span class=\"hljs-built_in\">this</span>.props)) {\n    <span class=\"hljs-built_in\">this</span>.setRenderComponent(nextProps);\n  }\n  <span class=\"hljs-keyword\">if</span> (nextState.component !== component) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n</code></pre>\n<p>在此背景下，当时的开发者经常使用 shouldComponentUpdate 来深比较 Props，只在 Props 有修改才执行组件的 Render 过程，如今由于数据不可变性和函数组件的流行，这样的优化场景已经很少再出现了。</p>\n<p>为了贴合 shouldComponentUpdate 的思想：给子组件传 Props 时一定只传其需要的，而并非一股脑全部传入。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> AbleHiddenFiltersprops = useMemo(<span class=\"hljs-function\">() =&gt;</span> \n\t<span class=\"hljs-keyword\">return</span> {\n\t\thideFilters,\n\t\tgradeInfo,\n    subjectInfo,\n    ......\n\t\tsetHideFilters,\n\t\tfindOrderValue\n  }\n}, [gradeInfo, subjectInfo, hideFilters, studentId, findorderValue]);\n\n<span class=\"hljs-keyword\">const</span> CommonFiltersProps = useMemo(<span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-keyword\">return</span> {\n\t\tuser,\n    userId,\n    orgInfo,\n    pickerValue,\n    ......\n    studentId,\n    userDisabled,\n    userData,\n    organizationData,\n  }\n}, [userId, orgInfo, pickerValue, studentId, isShowOrg, cUserFilteRef, initialOwnerListRef?.current]);\n</code></pre>\n<p>传入子组件的参数一定保证其在自组件中被使用到。</p>\n<p><a name=\"i5nrj\"></a></p>\n<h3>批量更新，减少 Render 次数</h3>\n<p>在 React 管理的事件回调和生命周期中，setState 是异步的，其他时候 setState 是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 setState 是批量更新的，而在其他时候是立即更新的。</p>\n<p>批量更新 setState 时，<strong>多次执行 setState 只会触发一次 Render 过程</strong>。相反在立即更新 setState 时，每次 setState 都会触发一次 Render 过程，就存在性能影响。</p>\n<p>假设有如下组件代码，该组件在 getData() 的 API 请求结果返回后，分别更新了两个 State 。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">NormalComponent</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-keyword\">const</span> [list, setList] = useState(<span class=\"hljs-literal\">null</span>);\n\t<span class=\"hljs-keyword\">const</span> [info, setInfo] = useState(<span class=\"hljs-literal\">null</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> {\n    ;(<span class=\"hljs-keyword\">async</span> () =&gt; {\n\t\t\t<span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> getData();\n\t\t\tsetList(data.list);\n      setInfo (data.info);\n    )();\n\t}, []);\n\n\t<span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n\t\t\t非批量更新组件时 Render 次数:\n      {renderOnce(&#x27;normal&#x27;)}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n\t)\n}\n</code></pre>\n<p>该组件会在 setList(data.list) 后，触发组件的 Render 过程，然后在 setInfo(<a href=\"http://data.info\">data.info</a>) 后再次触发 Render 过程，造成性能损失，<strong>那我们该如何解决呢？</strong></p>\n<ul>\n<li>将多个 State 合并为单个 State，比如 useState({ list: null, info: null }) 替代 list 和 info 两个 State。</li>\n<li>使用 React 官方提供的 unstable_batchedUpdates 方法，将多次 setState 封装到 unstable_batchedUpdates 回调中。</li>\n</ul>\n<p>修改后代码如下：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">BatchedComponent</span>(<span class=\"hljs-params\"></span>)</span>{\n\t<span class=\"hljs-keyword\">const</span> [list, setList] = useState(<span class=\"hljs-literal\">null</span>);\n\t<span class=\"hljs-keyword\">const</span> [info, setInfo] = useState(<span class=\"hljs-literal\">null</span>);\n\n\tuseEffect(<span class=\"hljs-function\">() =&gt;</span> {\n\t\t;(<span class=\"hljs-keyword\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">const</span> data= <span class=\"hljs-keyword\">await</span> getData();\n\t\t\tunstable_batchedUpdates(<span class=\"hljs-function\">() =&gt;</span> {\n        setList(data.list);\n\t\t\t\tsetInfo(data.info);\n      });\n    })()\n  }, [])\n\n\t<span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      批量更新组件时 Render 次数：\n      {renderOnce(&#x27;batched&#x27;)}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}\n</code></pre>\n<p><a name=\"dbUs8\"></a></p>\n<h3>精细化渲染阶段</h3>\n<p><a name=\"urvIk\"></a></p>\n<h4>按优先级更新，及时响应用户</h4>\n<p>如果页面弹出一个 Modal，当用户点击 Modal 中的确定按钮后，代码将执行两个操作：</p>\n<ul>\n<li>关闭 Modal；</li>\n<li>页面处理 Modal 传回的数据并展示给用户。</li>\n</ul>\n<p>当操作 2 需要执行 500ms 时，用户会明显感觉到从点击按钮到 Modal 被关闭之间的延迟。下图为一般的实现方式，将 slowHandle 函数作为用户点击按钮的回调函数。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 非延迟执行</span>\n<span class=\"hljs-keyword\">const</span> slowHandle = <span class=\"hljs-function\">() =&gt;</span> {\n  setShowInput(<span class=\"hljs-literal\">false</span>)\n  setNumbers ([...numbers, +inputValue].sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a - b) ));\n}\n</code></pre>\n<p>slowHandle() 执行过程耗时长，用户点击按钮后会明显感觉到页面卡顿。</p>\n<p>如果让页面优先隐藏输入框，用户就能立刻感知到页面更新，不会有卡顿感。<strong>而实现优先级更新的要点是：将耗时任务移动到下一个宏任务中执行，优先响应用户行为。</strong></p>\n<p>比如在示例中，将 setNumbers 移动到 setTimeout 的回调中，用户点击按钮后能立刻看到输入框被隐藏，不会感知到页面卡顿。项目中优化后的代码如下：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 延迟执行</span>\n<span class=\"hljs-keyword\">const</span> fastHandle = <span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-comment\">// 优先响应用户行为</span>\n\tsetShowInput(<span class=\"hljs-literal\">false</span>);\n\t<span class=\"hljs-comment\">// 将耗时任务移动到下一个宏任务执行</span>\n\t<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n\t\tsetNumbers([...numbers, +inputValue].sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a - b));\n  })\n}\n</code></pre>\n<p><a name=\"xXjN4\"></a></p>\n<h4>发布者订阅者跳过中间组件 Render 过程</h4>\n<p>React 推荐将公共数据放在所有“需要该状态的组件”的公共组件上，但是将状态放在公共组件上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p>传统 Redux 数据流</p>\n<p>可以看到，每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下，<strong>可以将状态用“发布者、订阅者模式”维护，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态</strong>。</p>\n<p>当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。</p>\n<p>只要是发布者订阅者模式的库，都可以使用 useContext 进行该优化。比如 redux、use-global-state、React.createContext 等。</p>\n<p>业务代码中的使用如下：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p>从图中可看出，优化后只有使用了公共状态的组件 renderTable 才会发生更新，可以大大减少父组件和其他 renderSon 组件的 Render 次数(减少叶子节点的重渲染)。</p>\n<p><a name=\"uk68B\"></a></p>\n<h4>useMemo 返回虚拟 DOM 可跳过该组件 Render 过程</h4>\n<p>利用 useMemo 可以缓存计算结果的特点，如果 useMemo 返回的是组件的虚拟 DOM，那么将在 useMemo 依赖不变时，跳过组件的 Render 阶段。该方式与 React.memo 类似，但与 React.memo 相比有以下优势。</p>\n<ul>\n<li>更方便：React.memo 需要对组件进行一次包装，生成新的组件，而 useMemo 只需在存在性能瓶颈的地方使用，不用修改组件。</li>\n<li>更灵活：useMemo 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 useDeepCompareMemo 对用到的值进行深比较。</li>\n</ul>\n<p>该例子中，父组件状态更新后，不使用 useMemo 的子组件会执行 Render 过程，而使用 useMemo 的子组件会按需执行更新。</p>\n<p>业务代码中的使用方法如下：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p><a name=\"exACa\"></a></p>\n<h3>精确判断更新的“时机”和“范围”</h3>\n<p><a name=\"xWbRv\"></a></p>\n<h4>debounce、throttle 优化频繁触发的回调</h4>\n<p>在搜索组件中，当 input 中内容修改时就触发搜索回调，当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。</p>\n<p>在搜索场景中一般使用 useDebounce+ useEffect 的方式获取数据。</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">/**\n * 使用ref存储setTimeout 返回的值，避免普通防抖函数在函数组件中使用时依赖变化导致setTimeout唯一标识符丟失\n * <span class=\"hljs-doctag\">@param </span>fun 防抖目标函数\n * <span class=\"hljs-doctag\">@param </span>delay 防抖时间\n*/</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useDebounce</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">unknown</span>[]&gt;(<span class=\"hljs-params\">fun:(...args: T) =&gt; unknown, delay: number = <span class=\"hljs-number\">300</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> ref = useRef&lt;any&gt;();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span>(<span class=\"hljs-params\">...args: T</span>) </span>{\n    <span class=\"hljs-comment\">// ats-ignore</span>\n    <span class=\"hljs-keyword\">const</span> that = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-built_in\">clearTimeout</span>(ref.current);\n    ref.current = <span class=\"hljs-built_in\">setTimeout</span>(() - fun.apply&lt;any,T, unknown&gt;(that, args), delay);\n  };\n}\n\n<span class=\"hljs-comment\">/**\n * 节流 delay 内时间内只能触发1次回调\n * <span class=\"hljs-doctag\">@param </span>fun 函数\n * <span class=\"hljs-doctag\">@param </span>delay 间隔时间\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useThrottle</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">unknown</span>[], <span class=\"hljs-title\">R</span> = <span class=\"hljs-title\">any</span>&gt;(<span class=\"hljs-params\">fun:(...args: T) =&gt; R, delay: number = <span class=\"hljs-number\">700</span></span>) </span>{\n\t<span class=\"hljs-keyword\">const</span> ref = useRef&lt;number&gt;(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span>(<span class=\"hljs-params\">...args: T</span>): <span class=\"hljs-title\">R</span> | <span class=\"hljs-title\">undefined</span> </span>{\n    <span class=\"hljs-keyword\">const</span> date = <span class=\"hljs-built_in\">Date</span>.now();\n    <span class=\"hljs-keyword\">if</span> (ref.current + delay &gt; date) <span class=\"hljs-keyword\">return</span>;\n    ref.current = date;\n    <span class=\"hljs-comment\">// @ts-ignore</span>\n    <span class=\"hljs-keyword\">const</span> that = <span class=\"hljs-built_in\">this</span>;\n    <span class=\"hljs-keyword\">return</span> fun.apply&lt;any, T, R&gt;(that, args);\n  }\n}\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-keyword\">const</span> [text, setText] = useState(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> [debouncedValue] = useDebounce(text, <span class=\"hljs-number\">300</span>);\n\tuseEffect(<span class=\"hljs-function\">() =&gt;</span> {\n  \t<span class=\"hljs-comment\">//根据 debouncedvalue 进行搜索</span>\n  },[debouncedvalue]);\n};\n\n</code></pre>\n<p>在搜索场景中：</p>\n<ul>\n<li>只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合；</li>\n<li>throttle 更适合需要实时响应用户的场景，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如window 的 resize 事件）。</li>\n</ul>\n<p><a name=\"fueVH\"></a></p>\n<h4>懒加载与懒渲染</h4>\n<p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由；还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块（大数据量弹窗）。在这些场景下，结合 Code Split 收益较高。</p>\n<p>懒加载的实现是通过 Webpack 的动态导入和 React.lazy 方法。实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\" alt=\"1665303348561-7e0a9df9-acfb-4376-9e50-db19737ba756.png\"></p>\n<p>而懒渲染指：当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。懒渲染的使用场景有：</p>\n<ul>\n<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>\n<li>需用户操作后才展示的组件（这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单）。</li>\n</ul>\n<p>在懒渲染的实现中，判断组件是否出现在可视区域内，借助 react-visibility-observer 依赖：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> VisibilityObserver, { useVisibilityObserver } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-visibility-observer&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> VisibilityObserverChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ callback, children }</span>)=&gt;</span> {\n\t<span class=\"hljs-keyword\">const</span> { isVisible } = useVisibilityObserver();\n  useEffect(\n    <span class=\"hljs-function\">() =&gt;</span> {\n      callback(isVisible)\n    },\n    [callback, isVisiblel]\n  );\n\t<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span>{children}<span class=\"hljs-tag\">&lt;/&gt;</span></span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> LazyRender = <span class=\"hljs-function\">() =&gt;</span> {\n\t<span class=\"hljs-keyword\">const</span> [isRendered, setIsRendered] = useState(<span class=\"hljs-literal\">false</span>);\n  \n  <span class=\"hljs-keyword\">if</span> (!isRendered) {\n    <span class=\"hljs-keyword\">return</span>(\n\t\t\t<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">VisibilityObserver</span> <span class=\"hljs-attr\">rootMargin</span>=<span class=\"hljs-string\">{</span>&#x27;<span class=\"hljs-attr\">Opx</span> <span class=\"hljs-attr\">Opx</span> <span class=\"hljs-attr\">Opx</span> <span class=\"hljs-attr\">Opx</span>&#x27;}&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">VisibilityObserverChildren</span>\n          <span class=\"hljs-attr\">callback</span>=<span class=\"hljs-string\">{isVisible</span> =&gt;</span> {\n            if (isVisible) {\n              setIsRendered(true);\n            }\n          }}\n\t\t\t\t&gt;\n\t\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">VisibilityObserverChildren</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">VisibilityObserver</span>&gt;</span></span>\n\t\t)\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> LazyRender;\n\n</code></pre>\n<p><a name=\"xrqiR\"></a></p>\n<h4>虚拟列表</h4>\n<p>虚拟列表是懒渲染的一种特殊场景，虚拟列表的组件有 react-window和 react-virtualized。、</p>\n<p>其中，react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好，我建议你用 react-window，只需要计算每项的高度即可（如果每项的高度是变化的，可给 itemSize 参数传一个函数）：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { FixedSizeList <span class=\"hljs-keyword\">as</span> List } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-window&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> Row = ({ index,  style }) = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">stvle</span>=<span class=\"hljs-string\">{style}</span>&gt;</span>Row {index}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n\n<span class=\"hljs-keyword\">const</span> Example =<span class=\"hljs-function\">() =&gt;</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{150}</span>\n    <span class=\"hljs-attr\">itemcount</span>=<span class=\"hljs-string\">{1000}</span>\n    <span class=\"hljs-attr\">itemsize</span>=<span class=\"hljs-string\">{35}</span> //每项的高度为 <span class=\"hljs-attr\">35</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{300}</span>\n\t&gt;</span>\n    {Row}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">List</span>&gt;</span></span>\n)\n\n</code></pre>\n<p>所以在开发过程中，遇到接口返回的是所有数据时，需提前预防这类会有展示的性能瓶颈的需求时，<strong>推荐使用虚拟列表优化</strong>。</p>\n<p><a name=\"ehjVN\"></a></p>\n<h4>避免在 didMount、didUpdate 中更新组件 State</h4>\n<p>这个技巧不仅仅适用于 didMount、didUpdate，还包括 willUnmount、useLayoutEffect 和特殊场景下的 useEffect（当父组件的 cDU/cDM 触发时，子组件的 useEffect 会同步调用），我简化一下，把它们叫作“提交阶段钩子”。</p>\n<p><strong>React 工作流 Commit 阶段的第二步就是执行提交阶段钩子</strong>，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。一般在提交阶段的钩子中更新组件状态的场景有：</p>\n<ul>\n<li>计算并更新组件的派生状态（Derived State）。在该场景中，类组件应使用 getDerivedStateFromProps 钩子方法代替，函数组件应使用函数调用时执行 setState 的方式代替。使用上面两种方式后，React 会将新状态和派生状态在一次更新内完成。</li>\n<li>根据 DOM 信息，修改组件状态。在该场景中，除非想办法不依赖 DOM 信息，否则两次更新过程是少不了的，就只能用其他优化技巧了。</li>\n</ul>\n<p>use-swr 的源码就使用了该优化技巧：当某个接口存在缓存数据时，use-swr 会先使用该接口的缓存数据，并在 requestIdleCallback 时再重新发起请求，获取最新数据。</p>\n<p>我模拟一个 swr：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">CompWithUseFetch</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-keyword\">const</span> [search, setSearch] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n  <span class=\"hljs-comment\">//如果 search 改变就重新发起请求</span>\n\t<span class=\"hljs-keyword\">const</span> { data } = useFetch(<span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.fetch(<span class=\"hljs-string\">`/api/data?search=<span class=\"hljs-subst\">${search}</span>`</span>)\n\t}, [search]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    \t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n\t\t\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{e</span> =&gt;</span> setSearch(e.target.value)} /&gt;\n    \t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  \t\t{data || &quot;-&quot;}\n  \t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n\t)\n}\n\n</code></pre>\n<ul>\n<li>它的第二个参数 deps，是为了在请求带有参数时，如果参数改变了就重新发起请求。</li>\n<li>暴露给调用方的 fetch 函数，可以应对主动刷新的场景，比如页面上的刷新按钮。</li>\n</ul>\n<p>如果 use-swr 不做该优化的话，就会在 useLayoutEffect 中触发重新验证并设置 isValidating 状态为 true，引起组件的更新流程，造成性能损失。</p>\n<p><a name=\"t8lZe\"></a></p>\n<h3>React Profiler 使用心得</h3>\n<p>React Profiler 是 React 官方提供的性能审查工具，我只讲一下自己的使用心得。</p>\n<p>Note：react-dom 16.5+ 在 DEV 模式下才支持 Profiling，同时生产环境下也可以通过一个 profiling bundle react-dom/profiling 来支持，你可以在 <a href=\"https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977\">https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977</a>上查看如何使用这个 bundle。</p>\n<p>“Profiler” 的面板在刚开始的时候是空的，你可以点击 record 按钮来启动 profile：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png\" alt=\"1665303631898-476b72a9-ec5c-4b74-8660-c2292966e52a.png\"></p>\n<p><a name=\"Zwf4S\"></a></p>\n<h4>Profiler 只记录了 Render 过程耗时</h4>\n<p>不要通过 Profiler 定位非 Render 过程的性能瓶颈问题，通过 React Profiler，开发者可以查看组件 Render 过程耗时，但无法知晓提交阶段的耗时。尽管 Profiler 面板中有 Committed at 字段，但这个字段是相对于录制开始时间，根本没有意义。</p>\n<p>通过在 React v16 版本上进行实验，同时开启 Chrome 的 Performance 和 React Profiler 统计。</p>\n<p>如下图，在 Performance 面板中，Reconciliation和Commit阶段耗时分别为 642ms 和 300ms，而 Profiler 面板中只显示了 642ms：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png\" alt=\"1665303747285-c21ecea0-122f-487d-81d7-355586596a38.png\"></p>\n<p><a name=\"loc6F\"></a></p>\n<h4>开启“记录组件更新原因”</h4>\n<p>点击面板上的齿轮，然后勾选“Record why each component rendered while profiling.”，如下图：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png\" alt=\"1665303817625-29010e7b-3bd0-40e7-bd7a-2ffd33a7699d.png\"></p>\n<p>然后点击面板中的虚拟 DOM 节点，右侧便会展示该组件重新 Render 的原因。</p>\n<p><a name=\"SYpWs\"></a></p>\n<h4>定位产生本次 Render 过程原因</h4>\n<p>由于 React 的批量更新（Batch Update）机制，产生一次 Render 过程可能涉及到很多个组件的状态更新，<strong>那么如何定位是哪些组件状态更新导致的呢</strong>？</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png\" alt=\"1665303888640-8dd49ec8-2a5b-4aa5-892e-7d5c77a79e17.png\"></p>\n<p>在 Profiler 面板左侧的虚拟 DOM 树结构中，从上到下审查每个发生了渲染的（不会灰色的）组件。如果组件是由于 State 或 Hook 改变触发了 Render 过程，那它就是我们要找的组件，如下图：</p>\n<p><img src=\"/assets/blog/context/2021-09-23-React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%963%E5%A4%A7%E6%8A%80%E5%B7%A7/1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png\" alt=\"1665304010851-19e98c9f-7d79-406e-b100-d08fe7ed03b2.png\"></p>\n<p>小结<br />这一讲，我从三个方向深度剖析了 React 的性能优化，由浅及深地从业务角度入手，用例证深刻解读了在各种业务场景下，应该使用何种优化手段，核心主要概括成以下几点：</p>\n<ul>\n<li>了解 React 的工作流，熟悉其中各阶段的职责；</li>\n<li>通过减少计算量来优化 Render 的过程；</li>\n<li>通过几种技巧来精细化渲染阶段的加载速度；</li>\n<li>通过控制更新的时机与范围来最大化优化效果；</li>\n<li>学习 React Profiler 的使用。</li>\n</ul>\n<p>总的来说，性能优化没有银弹，作为技术人，需要内修于心（熟知底层原理），同时把对性能优化当作习惯，植入日常思考中去。</p>\n","ogImage":{"url":"/assets/blog/cover/2021-09-23-React性能优化3大技巧.png"},"coverImage":"/assets/blog/cover/2021-09-23-React性能优化3大技巧.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}