{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","slug":"2021-01-19-vue3-core-source-code-19"},"nextPost":{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","slug":"2021-01-21-vue3-core-source-code-21"}},"post":{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","description":"指令：指令完整的生命周期是怎样的？","keyword":"vue,vue3.0,源码","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>我们知道 Vue.js 的核心思想之一是数据驱动，数据是 DOM 的映射。在大部分情况下，你是不用操作 DOM 的，但是这并不意味着你不能操作 DOM。</p>\n<p>有些时候，我们希望手动去操作某个元素节点的 DOM，比如当这个元素节点挂载到页面的时候通过操作底层的 DOM 来做一些事情。</p>\n<p>为了支持这个需求，Vue.js 提供了指令的功能，它允许我们自定义指令，作用在普通的 DOM 元素上。</p>\n<p>举个聚焦输入框的例子，我们希望在页面加载时，输入框自动获得焦点，我们可以全局注册一个 v-focus 指令：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">const</span> app = Vue.createApp({});\n<span class=\"hljs-comment\">// 注册全局 v-focus 指令</span>\napp.directive(<span class=\"hljs-string\">&quot;focus&quot;</span>, {\n  <span class=\"hljs-comment\">// 挂载的钩子函数</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\">el</span>)</span> {\n    el.focus();\n  },\n});\n</code></pre>\n<p>当然，我们也可以在组件内部局部注册：</p>\n<pre class=\"hljs\"><code>directives: {\n  <span class=\"hljs-attr\">focus</span>: {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\">el</span>)</span> {\n      el.focus()\n    }\n  }\n}\n</code></pre>\n<p>然后我们就可以在模板中使用这个指令了：<code>&lt;input v-focus /&gt;</code>。</p>\n<p>至此我们就大致了解了指令的功能和用法，那么接下来，我们就从指令的定义、指令的注册和指令的应用三个方面来一起探究它的实现原理。</p>\n<h2>1 指令的定义</h2>\n<p>指令本质上就是一个 JavaScript 对象，对象上挂着一些钩子函数，我们可以举个例子来说明，比如我定义一个 v-log 指令，这个指令做的事情就是在指令的各个生命周期去输出一些 log 信息：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> logDirective = {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">beforeMount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive before mount&quot;</span>);\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive mounted&quot;</span>);\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">beforeUpdate</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive before update&quot;</span>);\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">updated</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive updated&quot;</span>);\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">beforeUnmount</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive beforeUnmount&quot;</span>);\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-title\">unmounted</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;log directive unmounted&quot;</span>);\n  },\n};\n</code></pre>\n<p>然后你可以在创建应用后注册它：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { createApp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./App&quot;</span>;\n<span class=\"hljs-keyword\">const</span> app = createApp(App);\napp.directive(<span class=\"hljs-string\">&quot;log&quot;</span>, logDirective);\napp.mount(<span class=\"hljs-string\">&quot;#app&quot;</span>);\n</code></pre>\n<p>接着在 App 组件中使用这个指令：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;flag&quot;</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-else</span> <span class=\"hljs-attr\">v-log</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;text&quot;</span>/&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;flag=!flag&quot;</span>&gt;</span>toggle<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">flag</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&#x27;Hello Vue&#x27;</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>我建议你拷贝上述代码运行这个示例，你会发现，当你点击按钮后，会先执行指令定义的 beforeMount 和 mounted 钩子函数，然后你在 input 输入框中输入一些内容，会执行 beforeUpdate 和 updated 钩子函数，然后你再次点击按钮，会执行 beforeUnmount 和 unmounted 钩子函数。</p>\n<p>所以一个指令的定义，无非就是在合适的钩子函数中编写一些相关的处理逻辑。我基于 Vue.js 3.0 写过一个简单图片懒加载的插件 <a href=\"https://github.com/ustbhuangyi/vue3-lazy\">vue3-lazy</a>，你也可以去看看它的源码，了解一下一个成熟的指令插件是如何编写的。</p>\n<h2>2 指令的注册</h2>\n<p>所以当我们编写好指令后，在应用它之前，我们需要先注册它。所谓注册，其实就是把指令的定义保存到相应的地方，未来使用的时候我可以从保存的地方拿到它。</p>\n<p>指令的注册和组件一样，可以全局注册，也可以局部注册。我们来分别看一下它们的实现原理。</p>\n<p>首先，我们来了解全局注册的方式，它是通过 app.directive 方法去注册的，比如：</p>\n<pre class=\"hljs\"><code>app.directive(<span class=\"hljs-string\">&quot;focus&quot;</span>, {\n  <span class=\"hljs-comment\">// 挂载的钩子函数</span>\n  <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\">el</span>)</span> {\n    el.focus();\n  },\n});\n</code></pre>\n<p>我们来看 directive 方法的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createApp</span>(<span class=\"hljs-params\">rootComponent, rootProps = <span class=\"hljs-literal\">null</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> context = createAppContext();\n  <span class=\"hljs-keyword\">const</span> app = {\n    <span class=\"hljs-attr\">_component</span>: rootComponent,\n    <span class=\"hljs-attr\">_props</span>: rootProps,\n    <span class=\"hljs-function\"><span class=\"hljs-title\">directive</span>(<span class=\"hljs-params\">name, directive</span>)</span> {\n      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n        validateDirectiveName(name);\n      }\n      <span class=\"hljs-keyword\">if</span> (!directive) {\n        <span class=\"hljs-comment\">// 没有第二个参数，则获取对应的指令对象</span>\n        <span class=\"hljs-keyword\">return</span> context.directives[name];\n      }\n      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span> &amp;&amp; context.directives[name]) {\n        <span class=\"hljs-comment\">// 重复注册的警告</span>\n        warn(<span class=\"hljs-string\">`Directive &quot;<span class=\"hljs-subst\">${name}</span>&quot; has already been registered in target app.`</span>);\n      }\n      context.directives[name] = directive;\n      <span class=\"hljs-keyword\">return</span> app;\n    },\n  };\n  <span class=\"hljs-keyword\">return</span> app;\n}\n</code></pre>\n<p>directive 是 app 对象上的一个方法，它接受两个参数，第一个参数是指令的名称，第二个参数就是指令对象。</p>\n<p>指令全局注册方法的实现非常简单，就是把指令对象注册到 app 对象创建的全局上下文 context.directives 中，并用 name 作为 key。</p>\n<p>这里有几个细节要注意一下，validateDirectiveName 是用来检测指令名是否和内置的指令（如 v-model、v-show）冲突；如果不传第二个参数指令对象，表示这是一次指令的获取；指令重复注册会报警告。</p>\n<p>接下来，我们来了解局部注册的方式，它是直接在组件对象中定义的，比如：</p>\n<pre class=\"hljs\"><code>directives: {\n  <span class=\"hljs-attr\">focus</span>: {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\">el</span>)</span> {\n      el.focus()\n    }\n  }\n}\n</code></pre>\n<p>因此全局注册和局部注册的区别是，一个保存在 appContext 中，一个保存在组件对象的定义中。</p>\n<h2>3 指令的应用</h2>\n<p>接下来，我们重点分析指令的应用过程，我们以 v-focus 指令为例，在组件中使用这个指令：<code>&lt;input v-focus /&gt;</code>。</p>\n<p>我们先看这个模板编译后生成的 render 函数：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> {\n  resolveDirective <span class=\"hljs-keyword\">as</span> _resolveDirective,\n  createVNode <span class=\"hljs-keyword\">as</span> _createVNode,\n  withDirectives <span class=\"hljs-keyword\">as</span> _withDirectives,\n  openBlock <span class=\"hljs-keyword\">as</span> _openBlock,\n  createBlock <span class=\"hljs-keyword\">as</span> _createBlock,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> _directive_focus = _resolveDirective(<span class=\"hljs-string\">&quot;focus&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> _withDirectives(\n    (_openBlock(), _createBlock(<span class=\"hljs-string\">&quot;input&quot;</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">512</span> <span class=\"hljs-comment\">/* NEED_PATCH */</span>)),\n    [[_directive_focus]]\n  );\n}\n</code></pre>\n<p>我们再来看看如果不使用 v-focus，单个 input 编译生成后的 render 函数是怎样的：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> {\n  createVNode <span class=\"hljs-keyword\">as</span> _createVNode,\n  openBlock <span class=\"hljs-keyword\">as</span> _openBlock,\n  createBlock <span class=\"hljs-keyword\">as</span> _createBlock,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">_ctx, _cache, $props, $setup, $data, $options</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> _openBlock(), _createBlock(<span class=\"hljs-string\">&quot;input&quot;</span>);\n}\n</code></pre>\n<p>对比两个编译结果可以看到，区别在于如果元素节点使用指令，那么它编译生成的 vnode 会用 withDirectives 包装一层。</p>\n<p>在分析 withDirectives 函数的实现之前先来看指令的解析函数 resolveDirective，因为前面我们已经了解指令的注册其实就是把定义的指令对象保存下来，那么 resolveDirective 做的事情就是根据指令的名称找到保存的对应指令对象，我们来看一下它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> DIRECTIVES = <span class=\"hljs-string\">&quot;directives&quot;</span>;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolveDirective</span>(<span class=\"hljs-params\">name</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> resolveAsset(DIRECTIVES, name);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolveAsset</span>(<span class=\"hljs-params\">type, name, warnMissing = <span class=\"hljs-literal\">true</span></span>) </span>{\n  <span class=\"hljs-comment\">// 获取当前渲染实例</span>\n  <span class=\"hljs-keyword\">const</span> instance = currentRenderingInstance || currentInstance;\n  <span class=\"hljs-keyword\">if</span> (instance) {\n    <span class=\"hljs-keyword\">const</span> Component = instance.type;\n    <span class=\"hljs-keyword\">const</span> res =\n      <span class=\"hljs-comment\">// 局部注册</span>\n      resolve(Component[type], name) ||\n      <span class=\"hljs-comment\">// 全局注册</span>\n      resolve(instance.appContext[type], name);\n    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span> &amp;&amp; warnMissing &amp;&amp; !res) {\n      warn(<span class=\"hljs-string\">`Failed to resolve <span class=\"hljs-subst\">${type.slice(<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>)}</span>: <span class=\"hljs-subst\">${name}</span>`</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> res;\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n    warn(\n      <span class=\"hljs-string\">`resolve<span class=\"hljs-subst\">${capitalize(type.slice(<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>))}</span> `</span> +\n        <span class=\"hljs-string\">`can only be used in render() or setup().`</span>\n    );\n  }\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">registry, name</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> (\n    registry &amp;&amp;\n    (registry[name] ||\n      registry[camelize(name)] ||\n      registry[capitalize(camelize(name))])\n  );\n}\n</code></pre>\n<p>可以看到，resolveDirective 内部调用了 resolveAsset 函数，传入的类型名称为 directives 字符串。</p>\n<p>resolveAsset 内部先通过 resolve 函数解析局部注册的资源，由于我们传入的是 directives，所以就从组件定义对象上的 directives 属性中查找对应 name 的指令，如果查找不到则通过 instance.appContext，也就是我们前面提到的全局的 appContext，根据其中的 name 查找对应的指令。</p>\n<p>所以 resolveDirective 的实现很简单，优先查找组件是否局部注册该指令，如果没有则看是否全局注册该指令，如果还找不到则在非生产环境下报警告，提示用户没有解析到该指令。如果你平时在开发工作中遇到这个警告，那么你很可能就是没有注册这个指令，或者是 name 写得不对。</p>\n<p>注意，在 resolve 函数实现的过程中，它会先根据 name 匹配，如果失败则把 name 变成驼峰格式继续匹配，还匹配不到则把 name 首字母大写后继续匹配，这么做是为了让用户编写指令名称的时候可以更加灵活，所以需要多判断几步用户可能编写的指令名称的情况。</p>\n<p>接下来，我们来分析 withDirectives 的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withDirectives</span>(<span class=\"hljs-params\">vnode, directives</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> internalInstance = currentRenderingInstance;\n  <span class=\"hljs-keyword\">if</span> (internalInstance === <span class=\"hljs-literal\">null</span>) {\n    process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span> &amp;&amp;\n      warn(<span class=\"hljs-string\">`withDirectives can only be used inside render functions.`</span>);\n    <span class=\"hljs-keyword\">return</span> vnode;\n  }\n  <span class=\"hljs-keyword\">const</span> instance = internalInstance.proxy;\n  <span class=\"hljs-keyword\">const</span> bindings = vnode.dirs || (vnode.dirs = []);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; directives.length; i++) {\n    <span class=\"hljs-keyword\">let</span> [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\n    <span class=\"hljs-keyword\">if</span> (isFunction(dir)) {\n      dir = {\n        <span class=\"hljs-attr\">mounted</span>: dir,\n        <span class=\"hljs-attr\">updated</span>: dir,\n      };\n    }\n    bindings.push({\n      dir,\n      instance,\n      value,\n      <span class=\"hljs-attr\">oldValue</span>: <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,\n      arg,\n      modifiers,\n    });\n  }\n  <span class=\"hljs-keyword\">return</span> vnode;\n}\n</code></pre>\n<p>withDirectives 函数第一个参数是 vnode，第二个参数是指令构成的数组，因为一个元素节点上是可以应用多个指令的。</p>\n<p>withDirectives 其实就是给 vnode 添加了一个 dirs 属性，属性的值就是这个元素节点上的所有指令构成的对象数组。它通过对 directives 的遍历，拿到每一个指令对象以及指令对应的值 value、参数 arg、修饰符 modifiers 等，然后构造成一个 binding 对象，这个对象还绑定了组件的实例 instance。</p>\n<p>这么做的目的是在元素的生命周期中知道运行哪些指令相关的钩子函数，以及在运行这些钩子函数的时候，还可以往钩子函数中传递一些指令相关的参数。</p>\n<p>那么，接下来我们就来看在元素的生命周期中是如何运行这些钩子函数的。</p>\n<p>首先，我们来看元素挂载时候会执行哪些指令的钩子函数。通过前面章节的学习我们了解到，一个元素的挂载是通过执行 mountElement 函数完成的，我们再来回顾一下它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> mountElement = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  vnode,\n  container,\n  anchor,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">let</span> el;\n  <span class=\"hljs-keyword\">const</span> { type, props, shapeFlag, dirs } = vnode;\n  <span class=\"hljs-comment\">// 创建 DOM 元素节点</span>\n  el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is);\n  <span class=\"hljs-keyword\">if</span> (props) {\n    <span class=\"hljs-comment\">// 处理 props，比如 class、style、event 等属性</span>\n  }\n  <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* TEXT_CHILDREN */</span>) {\n    <span class=\"hljs-comment\">// 处理子节点是纯文本的情况</span>\n    hostSetElementText(el, vnode.children);\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n    <span class=\"hljs-comment\">// 处理子节点是数组的情况，挂载子节点</span>\n    mountChildren(\n      vnode.children,\n      el,\n      <span class=\"hljs-literal\">null</span>,\n      parentComponent,\n      parentSuspense,\n      isSVG &amp;&amp; type !== <span class=\"hljs-string\">&quot;foreignObject&quot;</span>,\n      optimized || !!vnode.dynamicChildren\n    );\n  }\n  <span class=\"hljs-keyword\">if</span> (dirs) {\n    invokeDirectiveHook(vnode, <span class=\"hljs-literal\">null</span>, parentComponent, <span class=\"hljs-string\">&quot;beforeMount&quot;</span>);\n  }\n  <span class=\"hljs-comment\">// 把创建的 DOM 元素节点挂载到 container 上</span>\n  hostInsert(el, container, anchor);\n  <span class=\"hljs-keyword\">if</span> (dirs) {\n    queuePostRenderEffect(<span class=\"hljs-function\">() =&gt;</span> {\n      invokeDirectiveHook(vnode, <span class=\"hljs-literal\">null</span>, parentComponent, <span class=\"hljs-string\">&quot;mounted&quot;</span>);\n    });\n  }\n};\n</code></pre>\n<p>这一次，我们添加了元素指令调用的相关代码，可以直观地看到，在元素插入到容器之前会执行指令的 beforeMount 钩子函数，在插入元素之后，会通过 queuePostRenderEffect 的方式执行指令的 mounted 钩子函数。</p>\n<p>钩子函数的执行，是通过调用 invokeDirectiveHook 方法完成的，我们来看它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">invokeDirectiveHook</span>(<span class=\"hljs-params\">vnode, prevVNode, instance, name</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> bindings = vnode.dirs;\n  <span class=\"hljs-keyword\">const</span> oldBindings = prevVNode &amp;&amp; prevVNode.dirs;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; bindings.length; i++) {\n    <span class=\"hljs-keyword\">const</span> binding = bindings[i];\n    <span class=\"hljs-keyword\">if</span> (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    <span class=\"hljs-keyword\">const</span> hook = binding.dir[name];\n    <span class=\"hljs-keyword\">if</span> (hook) {\n      callWithAsyncErrorHandling(hook, instance, <span class=\"hljs-number\">8</span> <span class=\"hljs-comment\">/* DIRECTIVE_HOOK */</span>, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode,\n      ]);\n    }\n  }\n}\n</code></pre>\n<p>invokeDirectiveHook 函数有四个参数，第一个和第二个参数分别代表新旧 vnode，第三个参数是组件实例 instance，第四个参数是钩子名称 name。</p>\n<p>invokeDirectiveHook 的实现很简单，通过遍历 vnode.dirs 数组，找到每一个指令对应的 binding 对象，然后从 binding 对象中根据 name 找到指令定义的对应的钩子函数，如果定义了这个钩子函数则执行它，并且传入一些响应的参数，包括元素的 DOM 节点 el，binding 对象，新旧 vnode，这就是我们在执行指令钩子函数的时候，可以访问到这些参数的原因。</p>\n<p>另外我们注意到，mounted 钩子函数会用 queuePostRenderEffect 包一层执行，这么做和组件的初始化过程执行 mounted 钩子函数一样，在整个应用 render 完毕后，同步执行 flushPostFlushCbs 的时候执行元素指令的 mounted 钩子函数。</p>\n<p>接下来，我们来看元素更新时候会执行哪些指令的钩子函数。通过前面章节的学习我们了解到，一个元素的更新是通过执行 patchElement 函数，我们再来回顾一下它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> patchElement = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  n1,\n  n2,\n  parentComponent,\n  parentSuspense,\n  isSVG,\n  optimized\n</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> el = (n2.el = n1.el);\n  <span class=\"hljs-keyword\">const</span> oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ;\n  <span class=\"hljs-keyword\">const</span> newProps = n2.props || EMPTY_OBJ;\n  <span class=\"hljs-keyword\">const</span> { dirs } = n2;\n  <span class=\"hljs-comment\">// 更新 props</span>\n  patchProps(\n    el,\n    n2,\n    oldProps,\n    newProps,\n    parentComponent,\n    parentSuspense,\n    isSVG\n  );\n  <span class=\"hljs-keyword\">const</span> areChildrenSVG = isSVG &amp;&amp; n2.type !== <span class=\"hljs-string\">&quot;foreignObject&quot;</span>;\n  <span class=\"hljs-keyword\">if</span> (dirs) {\n    invokeDirectiveHook(n2, n1, parentComponent, <span class=\"hljs-string\">&quot;beforeUpdate&quot;</span>);\n  }\n  <span class=\"hljs-comment\">// 更新子节点</span>\n  patchChildren(\n    n1,\n    n2,\n    el,\n    <span class=\"hljs-literal\">null</span>,\n    parentComponent,\n    parentSuspense,\n    areChildrenSVG\n  );\n  <span class=\"hljs-keyword\">if</span> (dirs) {\n    queuePostRenderEffect(<span class=\"hljs-function\">() =&gt;</span> {\n      invokeDirectiveHook(vnode, <span class=\"hljs-literal\">null</span>, parentComponent, <span class=\"hljs-string\">&quot;updated&quot;</span>);\n    });\n  }\n};\n</code></pre>\n<p>这一次，我们添加了元素指令调用的相关代码，可以直观地看到，在更新子节点之前会执行指令的 beforeUpdate 钩子函数，在更新完子节点之后，会通过 queuePostRenderEffect 的方式执行指令的 updated 钩子函数。</p>\n<p>最后，我们来看元素卸载时候会执行哪些指令的钩子函数。通过前面章节的学习我们了解到，一个元素的卸载是通过执行 unmount 函数，我们再来回顾一下它的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> unmount = <span class=\"hljs-function\">(<span class=\"hljs-params\">vnode, parentComponent, parentSuspense, doRemove = <span class=\"hljs-literal\">false</span></span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> {\n    type,\n    props,\n    children,\n    dynamicChildren,\n    shapeFlag,\n    patchFlag,\n    dirs,\n  } = vnode;\n  <span class=\"hljs-keyword\">let</span> vnodeHook;\n  <span class=\"hljs-keyword\">if</span> ((vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {\n    invokeVNodeHook(vnodeHook, parentComponent, vnode);\n  }\n  <span class=\"hljs-keyword\">const</span> shouldInvokeDirs = shapeFlag &amp; <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">/* ELEMENT */</span> &amp;&amp; dirs;\n  <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">6</span> <span class=\"hljs-comment\">/* COMPONENT */</span>) {\n    unmountComponent(vnode.component, parentSuspense, doRemove);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">128</span> <span class=\"hljs-comment\">/* SUSPENSE */</span>) {\n      vnode.suspense.unmount(parentSuspense, doRemove);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (shouldInvokeDirs) {\n      invokeDirectiveHook(vnode, <span class=\"hljs-literal\">null</span>, parentComponent, <span class=\"hljs-string\">&quot;beforeUnmount&quot;</span>);\n    }\n    <span class=\"hljs-comment\">// 卸载子节点</span>\n    <span class=\"hljs-keyword\">if</span> (\n      dynamicChildren &amp;&amp;\n      (type !== Fragment ||\n        (patchFlag &gt; <span class=\"hljs-number\">0</span> &amp;&amp; patchFlag &amp; <span class=\"hljs-number\">64</span>)) <span class=\"hljs-comment\">/* STABLE_FRAGMENT */</span>\n    ) {\n      unmountChildren(dynamicChildren, parentComponent, parentSuspense);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">16</span> <span class=\"hljs-comment\">/* ARRAY_CHILDREN */</span>) {\n      unmountChildren(children, parentComponent, parentSuspense);\n    }\n    <span class=\"hljs-keyword\">if</span> (shapeFlag &amp; <span class=\"hljs-number\">64</span> <span class=\"hljs-comment\">/* TELEPORT */</span>) {\n      vnode.type.remove(vnode, internals);\n    }\n    <span class=\"hljs-comment\">// 移除 DOM 节点</span>\n    <span class=\"hljs-keyword\">if</span> (doRemove) {\n      remove(vnode);\n    }\n  }\n  <span class=\"hljs-keyword\">if</span> ((vnodeHook = props &amp;&amp; props.onVnodeUnmounted) || shouldInvokeDirs) {\n    queuePostRenderEffect(<span class=\"hljs-function\">() =&gt;</span> {\n      vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      <span class=\"hljs-keyword\">if</span> (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, <span class=\"hljs-literal\">null</span>, parentComponent, <span class=\"hljs-string\">&quot;unmounted&quot;</span>);\n      }\n    }, parentSuspense);\n  }\n};\n</code></pre>\n<p>unmount 方法的主要思路就是用递归的方式去遍历删除自身节点和子节点。</p>\n<p>可以看到，在移除元素的子节点之前会执行指令的 beforeUnmount 钩子函数，在移除子节点和当前节点之后，会通过 queuePostRenderEffect 的方式执行指令的 unmounted 钩子函数。</p>\n<h2>4 总结</h2>\n<p>好的，到这里本篇的内容也要结束啦，通过这篇的学习，我们应该了解指令是如何定义、如何注册，以及如何应用的。指令无非就是给我们提供了在一个元素的生命周期中注入代码的途径，它的本身实现是很简单的。</p>\n<p>最后，思考一个问题，请实现一个 v-uid 指令，实现创建唯一的元素 id，使用方式如下：</p>\n<pre class=\"hljs\"><code>&lt;div v-uid=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;&lt;/div&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-uid</span>=<span class=\"hljs-string\">&quot;foo&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>最终会在页面上生成的 HTML 如下：</p>\n<pre class=\"hljs\"><code>&lt;div id=<span class=\"hljs-string\">&quot;foo-0&quot;</span>&gt;&lt;/div&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;foo-1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>你有什么好的思路吗？</p>\n<blockquote>\n<p><strong>本篇的相关代码在源代码中的位置如下</strong>：<br>\npackages/runtime-core/src/directives.ts<br>\npackages/runtime-core/src/apiCreateApp.ts<br>\npackages/runtime-core/src/helpers/resolveAssets.ts<br>\npackages/runtime-core/src/renderer.ts</p>\n</blockquote>\n","ogImage":{"url":"http://assets.eggcake.cn/cover/eggcake-baidu-484x300.png"},"coverImage":"http://assets.eggcake.cn/cover/eggcake-baidu-484x300.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}