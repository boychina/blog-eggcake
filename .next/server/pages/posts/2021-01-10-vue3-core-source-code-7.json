{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","slug":"2021-01-09-vue3-core-source-code-6"},"nextPost":{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","slug":"2021-01-12-vue3-core-source-code-8"}},"post":{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","description":"计算属性：计算属性比普通函数好在哪里？","keyword":"vue,vue3.0,源码","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>上篇我们学习了响应式的实现原理，本篇我们将学些一个非常常用的响应式 API —— <strong>计算属性</strong>。</p>\n<p>计算属性是 Vue.js 开发中一个非常实用的 API，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。</p>\n<p>在 Vue.js 2.x 中，相信你对计算属性的应用已经如数家珍了，我们可以再组件对象中定义 computed 属性。到了 Vue.js 3.0，虽然也可以在组件中沿用 Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性 API。</p>\n<p>计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在 Vue.js 3.0 中计算属性的 API 又是如何实现的呢？接下来，就请你带着这些疑问，我们一起深入其实现原理。</p>\n<h2>1 计算属性 API：computed</h2>\n<p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p>\n<p>我们看一个简单的例子：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">const</span> plusOne = computed(<span class=\"hljs-function\">() =&gt;</span> count.value + <span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">console</span>.log(plusOne.value); <span class=\"hljs-comment\">// 2</span>\nplusOne.value++; <span class=\"hljs-comment\">// error</span>\ncount.value++;\n<span class=\"hljs-built_in\">console</span>.log(plusOne.value); <span class=\"hljs-comment\">// 3</span>\n</code></pre>\n<p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候，plusOne.value 就会自动发生变化。</p>\n<p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p>\n<p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个函数式对象，就是计算属性的依赖。</p>\n<p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传一个对象：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">const</span> plusOne = computed({\n  <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =&gt;</span> count.value + <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> {\n    count.value = val - <span class=\"hljs-number\">1</span>;\n  },\n});\nplusOne.value = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-built_in\">console</span>.log(count.value); <span class=\"hljs-comment\">// 0</span>\n</code></pre>\n<p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p>\n<p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">computed</span>(<span class=\"hljs-params\">getterOrOptions</span>) </span>{\n  <span class=\"hljs-comment\">// getter 函数</span>\n  <span class=\"hljs-keyword\">let</span> getter;\n  <span class=\"hljs-comment\">// setter 函数</span>\n  <span class=\"hljs-keyword\">let</span> setter;\n  <span class=\"hljs-comment\">// 标准化参数</span>\n  <span class=\"hljs-keyword\">if</span> (isFunction(getterOrOptions)) {\n    <span class=\"hljs-comment\">// 表面传入的是 getter 函数，不能修改计算属性的值</span>\n    getter = getterOrOptions;\n    setter =\n      process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>\n        ? <span class=\"hljs-function\">() =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">&quot;Write operation failed: computed value is readonly&quot;</span>);\n          }\n        : NOOP;\n  } <span class=\"hljs-keyword\">else</span> {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  <span class=\"hljs-comment\">// 数据是否脏的</span>\n  <span class=\"hljs-keyword\">let</span> dirty = <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-comment\">// 计算结果</span>\n  <span class=\"hljs-keyword\">let</span> value;\n  <span class=\"hljs-keyword\">let</span> computed;\n  <span class=\"hljs-comment\">// 创建副作用函数</span>\n  <span class=\"hljs-keyword\">const</span> runner = effect(getter, {\n    <span class=\"hljs-comment\">// 延时执行</span>\n    <span class=\"hljs-attr\">lazy</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序</span>\n    <span class=\"hljs-attr\">computed</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// 调度执行的实现</span>\n    <span class=\"hljs-attr\">scheduler</span>: <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (!dirty) {\n        dirty = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-comment\">// 派发通知，通知运行访问该计算属性的 activeEffect</span>\n        trigger(computed, <span class=\"hljs-string\">&quot;set&quot;</span> <span class=\"hljs-comment\">/* SET */</span>, <span class=\"hljs-string\">&quot;value&quot;</span>);\n      }\n    },\n  });\n  <span class=\"hljs-comment\">// 创建 computed 对象</span>\n  computed = {\n    <span class=\"hljs-attr\">__v_isRef</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// 暴露 effect 对象以便计算属性可以停止计算</span>\n    <span class=\"hljs-attr\">effect</span>: runner,\n    <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">value</span>() {\n      <span class=\"hljs-comment\">// 计算属性的 getter</span>\n      <span class=\"hljs-keyword\">if</span> (dirty) {\n        <span class=\"hljs-comment\">// 只有数据为脏的时候才会重新计算</span>\n        value = runner();\n        dirty = <span class=\"hljs-literal\">false</span>;\n      }\n      <span class=\"hljs-comment\">// 依赖收集，收集运行访问该计算属性的 activeEffect</span>\n      track(computed, <span class=\"hljs-string\">&quot;get&quot;</span> <span class=\"hljs-comment\">/* GET */</span>, <span class=\"hljs-string\">&quot;value&quot;</span>);\n      <span class=\"hljs-keyword\">return</span> value;\n    },\n    <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title\">value</span>(<span class=\"hljs-params\">newValue</span>) {\n      <span class=\"hljs-comment\">// 计算属性的 setter</span>\n      setter(newValue);\n    },\n  };\n  <span class=\"hljs-keyword\">return</span> computed;\n}\n</code></pre>\n<p>从代码中可以看到，computed 函数的流程主要做了三件事情：标准化参数，创建副作用函数和创建 computed 对象。我们来详细分析一下这几个步骤。</p>\n<p>首先是<strong>标准化参数</strong>。computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象，通过判断参数的类型，我们初始化了函数内部定义的 getter 和 setter 函数。</p>\n<p>接着是<strong>创建副作用函数 runner</strong>。computed 内部通过 effect 创建了一个副作用函数，它是对 getter 函数做的一层封装，另外我们这里要注意第二个参数，也就是 effect 函数的配置对象。其中 lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行；computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序，我们稍后会分析；scheduler 表示它的调度运行的方式，我们也稍后分析。</p>\n<p>最后是<strong>创建 computed 对象并返回</strong>，这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断 dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定氮仪的 setter 函数。</p>\n<h2>2 计算属性的运行机制</h2>\n<p>computed 函数的逻辑会有一点绕，不过不打紧，我们可以结合一个应用 computed 计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住 computed 内部两个重要的变量，第一个 dirty 表示一个计算属性的值是否是“脏的”，用来判断需不需要重新计算，第二个 value 表示计算属性每次计算后的结果。</p>\n<p>现在，我们来看这个示例：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    {{ plusOne }}\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;plus&quot;</span>&gt;</span>plus<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> { ref, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>)\n      <span class=\"hljs-keyword\">const</span> plusOne = computed(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span>\n      })\n\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">plus</span>(<span class=\"hljs-params\"></span>) </span>{\n        count.value++\n      }\n      <span class=\"hljs-keyword\">return</span> {\n        plusOne,\n        plus\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>可以看到，在这个例子中我们利用 computed API 创建了计算属性对象 plusOne，它传入的是一个 getter 函数，为了和后面计算属性对象的 getter 函数区分，我们把它称作 computed getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。</p>\n<p>组件渲染阶段访问 plusOne，也就触发了 plusOne 对象的 getter 函数：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">value</span>() {\n  <span class=\"hljs-comment\">// 计算属性的 getter</span>\n  <span class=\"hljs-keyword\">if</span> (dirty) {\n    <span class=\"hljs-comment\">// 只有数据为脏的时候才会重新计算</span>\n    value = runner()\n    dirty = <span class=\"hljs-literal\">false</span>\n  }\n  <span class=\"hljs-comment\">// 依赖收集，收集运行访问该计算属性的 activeEffect</span>\n  track(computed, <span class=\"hljs-string\">&quot;get&quot;</span> <span class=\"hljs-comment\">/* GET */</span>, <span class=\"hljs-string\">&#x27;value&#x27;</span>)\n  <span class=\"hljs-keyword\">return</span> value\n}\n</code></pre>\n<p>由于默认 dirty 是 true，所以这个时候会执行 runner 函数，并进一步执行 computed getter，也就是 count.value + 1，因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发 count 对象的依赖收集过程。</p>\n<p>请注意，由于是在 runner 执行访问 count，所以这个时候的 activeEffect 是 runner 函数。runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track(computed, &quot;get&quot;, &quot;value&quot;) 函数做依赖收集，这个时候 runner 已经执行完了，所以 activeEffect 是组建副作用渲染函数。</p>\n<p>所以你要特别注意这是两个依赖收集过程：对于 plusOne 来说，它收集的依赖是组件副作用渲染函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p>\n<p>然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并派发通知。请注意，这里不是直接调用 runner 函数，而是 把 runner 作为参数去执行 scheduler 函数。我们来回顾一下 trigger 函数内部对于 effect 函数的执行方式：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">(<span class=\"hljs-params\">effect</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// 调度执行</span>\n  <span class=\"hljs-keyword\">if</span> (effect.options.scheduler) {\n    effect.options.scheduler(effect);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 直接运行</span>\n    effect();\n  }\n};\n</code></pre>\n<p>computed API 内部创建副作用函数是，已经配置了 scheduler 函数，如下：</p>\n<pre class=\"hljs\"><code>scheduler: <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (!dirty) {\n    dirty = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-comment\">// 派发通知，通知运行访问该计算属性的 activeEffect</span>\n    trigger(computed, <span class=\"hljs-string\">&quot;set&quot;</span> <span class=\"hljs-comment\">/* SET */</span>, <span class=\"hljs-string\">&quot;value&quot;</span>);\n  }\n};\n</code></pre>\n<p>它并没有对计算属性求新值，而仅仅是把 dirty 设置为 true，再执行 trigger(computed, &quot;set&quot;, &quot;value&quot;)，去通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。</p>\n<p>在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true，然后会再次执行 computed getter，此时才会执行 count.value + 1 求得新值。这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。</p>\n<p>为了更加直观的展示上述过程，我们来看一下这个流程：\n<img src=\"http://assets.eggcake.cn/Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png\" alt=\"Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png\">\n通过以上分析，我们可以看出 computed 计算属性有两个特点：</p>\n<ol>\n<li><strong>延时计算</strong>，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算；</li>\n<li><strong>缓存</strong>，它的内部会缓存上次的计算结果 value，而且只有 dirty 为 true 时才会重新计算。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。</li>\n</ol>\n<p>现在，我们就可以回答开头提出的问题了。和单纯使用普通函数相比，计算属性的优势是：<strong>只要依赖不变化，就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算</strong>，这是点醒的空间换时间的优化思想。</p>\n<h2>3 嵌套计算属性</h2>\n<p>计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问 plusOne，而在另一个计算属性中访问：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> plusOne = computed(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span>;\n});\n<span class=\"hljs-keyword\">const</span> plusTwo = computed(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> plusOne.value + <span class=\"hljs-number\">1</span>;\n});\n<span class=\"hljs-built_in\">console</span>.log(plusTwo.value);\n</code></pre>\n<p>从代码中可以看到，当我们访问 plusTwo 的时候，过程和前面差不多，同样也是两个依赖收集的过程。对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p>\n<p>接着当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。</p>\n<p>然后当当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed getter 即 count.value + 1 + 1，求得最终的新值 2。</p>\n<p>得益于 computed 这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。</p>\n<h2>4 计算属性的执行顺序</h2>\n<p>我们曾提到计算属性内部创建副作用函数的时候会配置 computed 为 true，标识这是一个 computed effect，用于在 trigger 阶段的优先级排序。我们来回顾一个 trigger 函数执行 effects 的过程：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">effectsToAdd</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (effectsToAdd) {\n    effectsToAdd.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">effect</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (effect !== activeEffect || !shouldTrack) {\n        <span class=\"hljs-keyword\">if</span> (effect.options.computed) {\n          computedRunners.add(effect);\n        } <span class=\"hljs-keyword\">else</span> {\n          effects.add(effect);\n        }\n      }\n    });\n  }\n};\n<span class=\"hljs-keyword\">const</span> run = <span class=\"hljs-function\">(<span class=\"hljs-params\">effect</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (effect.options.scheduler) {\n    effect.options.scheduler(effect);\n  } <span class=\"hljs-keyword\">else</span> {\n    effect();\n  }\n};\ncomputedRunners.forEach(run);\neffects.forEach(run);\n</code></pre>\n<p>在前一篇中分析 trigger 函数的时候，为了方便理解主干逻辑，我们省略了 computedRunners 的分支逻辑。实际上，在添加待运行的 effects 的时候，我们会判断每一个 effect 是不是一个 computed effect，如果是的话会添加到 computedRunners 中，在后面运行的时候会优先执行 computedRunners，然后再执行普通的 effects。</p>\n<p>那么为什么要这么设计呢？其实是考虑到一些特殊场景，我们通过一个示例来说明：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { ref, computed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { effect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@vue/reactivity&quot;</span>;\n<span class=\"hljs-keyword\">const</span> count = ref(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> plusOne = computed(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> count.value + <span class=\"hljs-number\">1</span>;\n});\neffect(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(plusOne.value + count.value);\n});\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">plus</span>(<span class=\"hljs-params\"></span>) </span>{\n  count.value++;\n}\nplus();\n</code></pre>\n<p>这个示例运行后的结果输出：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">1</span>;\n<span class=\"hljs-number\">3</span>;\n<span class=\"hljs-number\">3</span>;\n</code></pre>\n<p>在执行 effect 函数时运行 console.log(plusOne.value + count.value)，所以第一次输出 1，此时 count.value 是 0，plusOne.value 是 1。</p>\n<p>后面连续输出两次 3 是因为，plusOne 和 count 的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改 count 的值时，会触发并执行这个 effect 函数，因为 plusOne 的 runner 也是 count 的依赖，count 的值修改也会执行 plusOne 的 runner，也就是会再次执行 plusOne 的依赖即 effect 函数，因此会输出两次。</p>\n<p>那么为什么两次都输出 3 呢？这就跟先执行 computed runner 有关。首先，由于 plusOne 的 runner 和 effect 都是 count 的依赖，当我们修改 count 值的时候，plusOne 的 runner 和 effect 都会执行，那么此时执行顺序就很重要了。</p>\n<p>这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value。这个时候，由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了新值 2，再加上 1 就得到 3。执行完 plusOne 的 runner 以及以来更新之后，再去执行 count 的普通 effect 依赖，从而去执行 plusOne.value + count.value，这个时候 plusOne dirty 为 false，直接返回上次的计算结果 2，然后再加 1 就又得到 3。</p>\n<p>如果我们把 computed runner 和 effect 的执行顺序换一下会怎样？我来告诉你，会输出如下结果：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-number\">1</span>;\n<span class=\"hljs-number\">2</span>;\n<span class=\"hljs-number\">3</span>;\n</code></pre>\n<p>第一次输出 1 很好理解，因为流程是一样的。第二次为什么会输出 2 呢？我们来分析一下，当我们执行 plus 函数修改 count 的值时，会触发 plusOne 的 runner 和 effect 的执行，这一次我们先让 effect 执行 plusOne.value + count.value，那么就会访问 plusOne.value，但由于 plusOne 的 runner 还没执行，所以此时 dirty 为 false，得到的值还是上一次的计算结果 1，然后在加 1 得到 2。</p>\n<p>接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通过它的依赖 effect 执行 plusOne.value + count.value，这个时候由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到 3。</p>\n<p>知道原因后，我们再回过头看例子。因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，这就是为什么我们需要让 computed runner 的执行优先于普通的 effect 函数。</p>\n<h2>5 总结</h2>\n<p>本篇我们讨论了计算属性的工作机制，通过本篇，我们希望能够理解计算属性的工作机制，能够搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点——<strong>延时计算</strong>和<strong>缓存</strong>，也希望能够在组件开发中合理使用计算属性。</p>\n<p>最后，考虑一个问题：computed 函数返回的对象实际上劫持的是 value 属性的 getter 和 setter，但为什么我们在组件的模板中访问一个计算属性变量，不用手动在后面加上 .value 呢？</p>\n<blockquote>\n<p><strong>本篇的代码在源代码中的位置如下：</strong><br>\npackages/reactivity/src/computed.ts</p>\n</blockquote>\n","ogImage":{"url":"http://assets.eggcake.cn/cover/2021-01-10-vue3-core-source-code-7.png"},"coverImage":"http://assets.eggcake.cn/cover/2021-01-10-vue3-core-source-code-7.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}