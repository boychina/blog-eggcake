{"pageProps":{"allPosts":[{"title":"React性能优化3大技巧","date":"2021-09-23 11:56:00","slug":"2021-09-23-react-performance-optimization-3-tips","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Typescript实战 | 如何快速搭建 TypeScript 学习开发环境？","date":"2021-05-24 22:00:00","slug":"2021-05-24-typescript-actual-combat","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"深入浅出React | JSX 代码是如何“摇身一变”成为 DOM 的？","date":"2021-03-24 14:00:00","slug":"2021-03-24-thorough-react-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React diff 算法","date":"2021-01-31 19:00:00","slug":"2021-01-31-react-diff","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（下）","date":"2021-01-27 11:00:00","slug":"2021-01-27-vue3-core-source-code-27","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Vue Router：如何实现一个前端路由？（上）","date":"2021-01-26 13:00:00","slug":"2021-01-26-vue3-core-source-code-26","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（下）","date":"2021-01-25 10:30:00","slug":"2021-01-25-vue3-core-source-code-25","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Transition 组件：过渡动画的实现原理是怎样的？（上）","date":"2021-01-24 09:30:00","slug":"2021-01-24-vue3-core-source-code-24","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | KeepAlive 组件：如何让组件在内存中缓存和调度？","date":"2021-01-23 00:30:00","slug":"2021-01-23-vue3-core-source-code-23","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | Teleport 组件：如何脱离当前组件渲染子组件？","date":"2021-01-22 19:30:00","slug":"2021-01-22-vue3-core-source-code-22","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | v-model：双向绑定到底是怎么实现的？","date":"2021-01-21 22:30:00","slug":"2021-01-21-vue3-core-source-code-21","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 指令：指令完整的生命周期是怎样的？","date":"2021-01-20 18:30:00","slug":"2021-01-20-vue3-core-source-code-20","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 插槽：如何实现内容分发？","date":"2021-01-19 16:30:00","slug":"2021-01-19-vue3-core-source-code-19","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Props：Props 的初始化和更新流程是怎样的？","date":"2021-01-18 19:00:00","slug":"2021-01-18-vue3-core-source-code-18","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生成代码：AST 如何生成可运行的代码？（下）","date":"2021-01-17 22:00:00","slug":"2021-01-17-vue3-core-source-code-17","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 生成代码：AST 如何生成可运行的代码？（上）","date":"2021-01-16 23:30:00","slug":"2021-01-16-vue3-core-source-code-16","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（下）","date":"2021-01-16 22:30:00","slug":"2021-01-16-vue3-core-source-code-15","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | AST 转换：AST 节点内部做了哪些转换？（上）","date":"2021-01-16 21:00:00","slug":"2021-01-16-vue3-core-source-code-14","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（下）","date":"2021-01-16 11:30:00","slug":"2021-01-16-vue3-core-source-code-13","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0 核心源码解读 | 模板解析：构造 AST 的完整流程是怎样的？（上）","date":"2021-01-15 23:00:00","slug":"2021-01-15-vue3-core-source-code-12","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 依赖注入：子孙组件如何共享数据？","date":"2021-01-15 18:00:00","slug":"2021-01-15-vue3-core-source-code-11","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？","date":"2021-01-14 23:30:00","slug":"2021-01-14-vue3-core-source-code-10","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（下）","date":"2021-01-13 22:30:00","slug":"2021-01-13-vue3-core-source-code-9","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 侦听器：侦听器的实现原理和使用场景是什么？（上）","date":"2021-01-12 11:59:00","slug":"2021-01-12-vue3-core-source-code-8","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 计算属性：计算属性比普通函数好在哪里？","date":"2021-01-10 23:25:00","slug":"2021-01-10-vue3-core-source-code-7","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","date":"2021-01-09 14:25:00","slug":"2021-01-09-vue3-core-source-code-6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","date":"2020-12-30 18:00:00","slug":"2020-12-30-vue3-core-source-code-4","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（下）","date":"2020-12-24 13:00:00","slug":"2020-12-24-vue3-core-source-code-3","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件更新：完整的Dom diff流程（上）","date":"2020-12-23 23:00:00","slug":"2020-12-23-vue3-core-source-code-2","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 组件渲染：vnode 到真实 DOM 是如何转变的？","date":"2020-12-21 23:00:00","slug":"2020-12-21-vue3-core-source-code-1","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue3.0核心源码解读 | 一文看懂Vue3.0的优化","date":"2020-12-19 14:00:00","slug":"2020-12-19-vue3-core-source-code-0","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Webpack5搭建React开发环境","date":"2020-12-17 18:00:00","slug":"2020-12-17-webpack5-build-react-dev-env","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React 17来了","date":"2020-10-06 12:00:00","slug":"2020-10-06-react17-coming","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React-grid-layout 一个支持拖拽的栅格布局库","date":"2020-09-27 12:00:00","slug":"2020-09-27-react-grid-layout","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2020新特性总结及使用场景","date":"2020-09-20 12:00:00","slug":"2020-09-20-ECMAScript2020","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2019新特性总结及使用场景","date":"2020-08-22 12:00:00","slug":"2020-08-22-ECMAScript2019","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2018新特性总结及使用场景","date":"2020-08-12 12:00:00","slug":"2020-08-12-ECMAScript2018","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"VScode代码注释关键字解析","date":"2020-08-01 12:00:00","slug":"2020-08-01-vscode-code-annotation-keyword-analysis","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2017新特性总结及使用场景","date":"2020-07-18 12:00:00","slug":"2020-07-18-ECMAScript2017","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ECMAScript2016新特性总结及使用场景","date":"2020-07-11 12:00:00","slug":"2020-07-11-ECMAScript2016","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Immutable 详解及 React 中实践","date":"2019-12-18 12:00:00","slug":"2019-12-18-immutable-react","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavsScript 原型","date":"2019-10-24 12:00:00","slug":"2019-10-24-JavaScript-prototype","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"setState 是同步还是异步的呢？","date":"2019-10-23 12:00:00","slug":"2019-10-23-setState-sync-or-async","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"JavaScript this 对象查找","date":"2019-09-22 12:00:00","slug":"2019-09-22-javascript-this-pointer","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"一些常用的正则表达式","date":"2018-12-12 12:00:00","slug":"2018-12-12-commonly-used-regular-expressionsm","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"前端数据流文件下载三种方式","date":"2018-12-12 12:00:00","slug":"2018-12-12-downloading-frontend-data-stream-files","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"React16.3+ 新的生命周期钩子","date":"2018-08-15 12:00:00","slug":"2018-08-15-react-new-life-cycle-hook","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 服务端渲染","date":"2018-08-15 12:00:00","slug":"2018-08-15-vue-server-side-render","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"MySQL 常用命令","date":"2018-08-09 12:00:00","slug":"2018-08-09-mysql-common-commands","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"Vue 和微信小程序的区别、比较","date":"2018-08-07 12:00:00","slug":"2018-08-07-vue-and-wechat-small-program-differences","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"H5移动端常见问题及注意事项","date":"2018-08-06 12:00:00","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"ES6 的 Proxy 和 Reflect","date":"2018-08-04 12:00:00","slug":"2018-08-04-Proxy-and-Reflect-of-ES6","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"如何用 Node 来制作 CLI","date":"2018-08-02 12:00:00","slug":"2018-08-02-make-the-cli-with-node","author":{"name":"Hux","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"关于生活与生存","date":"2018-07-31 05:35:07","slug":"2018-07-31-about-life-and-survival","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"}},{"title":"饿了么的 PWA 升级实践","date":"2017-07-12 12:00:00","slug":"2017-07-12-upgrading-eleme-to-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"下一代 Web 应用模型 —— Progressive Web App","date":"2017-02-09 12:00:00","slug":"2017-02-09-nextgen-web-pwa","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web Apps，复兴序章「QCon 上海 2016」","date":"2016-10-20 12:00:00","slug":"2016-10-20-pwa-qcon2016","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Progressive Web App 之我见","date":"2016-06-05 12:00:00","slug":"2016-06-05-pwa-in-my-pov","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"React vs Angular 2：冰与火之歌「译」","date":"2016-02-01 12:00:00","slug":"2016-02-01-React-vs-Angular2","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"都2015年了，CSS怎么还是这么糟糕","date":"2015-12-28 12:00:00","slug":"2015-12-28-css-sucks-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"iOS 9，为前端世界都带来了些什么？「译」","date":"2015-12-15 12:00:00","slug":"2015-12-15-ios9-safari-web","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"设计师如何学习前端？","date":"2015-10-28 12:00:00","slug":"2015-10-28-how-designer-learn-fe","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎么回事？「译」","date":"2015-09-22 12:00:00","slug":"2015-09-22-js-version","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript 模块化七日谈","date":"2015-07-09 12:00:00","slug":"2015-07-09-js-module-7day","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"聊聊「阿里旅行 · 去啊」—— 行业与战略","date":"2015-06-15 12:00:00","slug":"2015-06-15-alitrip-strategy","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"JavaScript模块化加载","date":"2015-05-25 12:00:00","slug":"2015-05-25-js-module-loader","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"操作系统的浪漫主义 —— Metro 篇","date":"2015-04-15 12:00:00","slug":"2015-04-15-os-metro","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Unix/Linux 扫盲笔记","date":"2015-04-14 12:00:00","slug":"2015-04-14-unix-linux-note","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"端到端用户场景的定义","date":"2015-03-31 12:00:00","slug":"2015-03-31-e2e_user_scenarios","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"Digital native 数字原住民","date":"2015-03-25 12:00:00","slug":"2015-03-25-digital-native","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"如何评价2015年3月9日Apple春季发布会","date":"2015-03-10 12:00:00","slug":"2015-03-10-apple-event-2015","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"你们觉得响应式好呢，还是手机和PC端分开来写？","date":"2014-11-20 12:00:00","slug":"2014-11-20-responsive-web-design","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}},{"title":"为什么阿里系软件体验都不好？","date":"2014-10-01 12:00:00","slug":"2014-10-01-why-alibaba-ux-sucks","author":{"name":"Hux","picture":"/assets/blog/authors/hux.jpg"}}],"prevNextPost":{"prevPost":{"title":"Vue3.0核心源码解读 | Setup：组件渲染前的初始化过程是怎样的？","slug":"2020-12-30-vue3-core-source-code-4"},"nextPost":{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（下）","slug":"2021-01-09-vue3-core-source-code-6"}},"post":{"title":"Vue3.0核心源码解读 | 响应式：响应式内部的实现原理是怎样的？（上）","description":"响应式：响应式内部的实现原理是怎样的？（上）","keyword":"vue,vue3.0,源码","date":"2021-01-08 23:00:00","slug":"2021-01-08-vue3-core-source-code-5","author":{"name":"蛋烘糕","picture":"/assets/blog/authors/zhaohuan.jpg"},"content":"<blockquote>\n<p>纸上得来终觉浅，绝知此事要躬行。</p>\n</blockquote>\n<p>上一篇我们了解了 Composition API 的核心 setup 函数的实现，在 setup 函数中，我们多次使用一些 API 让数据变成响应式，本篇我们就来深入学习响应式内部的实现原理。</p>\n<p>除了组件化，Vue.js 另一个核心设计思想就是<strong>响应式</strong>。它的本质是当数据变化后会自动执行某个函数，映射到组件的实现，就是当数据变化后，会自动触发组件的重新渲染。<strong>响应式是 Vue.js 组件化更新渲染的一个核心机制。</strong></p>\n<p>在介绍 Vue.js 3.0 响应式实现之前，我们先来回顾一下 Vue.js 2.x 响应式实现的部分： 它在内部通过 Object.defineProperty API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新。我们用一张图可以直观地看清这个流程。</p>\n<p><img src=\"/assets/blog/context/2021-01-08-vue3-core-source-code-5/1611161832405.jpg\" alt=\"1611161832405.jpg\"></p>\n<p>在 Vue.js 2.x 中，Watcher 就是依赖，有专门针对组件渲染的 render watcher。注意这里有两个流程，首先是<strong>依赖收集流程</strong>，组件在 render 的时候会访问模板中的数据，触发 getter 把 render watcher 作为依赖收集，并和数据建立联系；然后是派发通知流程，当我对这些数据修改的时候，会触发 setter，通知 render watcher 更新，进而触发了组件的重新渲染。</p>\n<p>之前，我们提到了 Object.defineProperty API 的一些缺点：不能监听对象属性新增和删除；初始化阶段递归执行 Object.defineProperty 带来的性能负担。</p>\n<p>Vue.js 3.0 为了解决 Object.defineProperty 的这些缺陷，使用 Proxy API 重写了响应式部分，并独立维护和发布整个 reactivity 库，下面我们就一起来深入学习 Vue.js 3.0 响应式部分的实现原理。</p>\n<h2>1 响应式对象的实现差异</h2>\n<p>在 Vue.js 2.x 中构建组件时，只要我们在 data、props、computed 中定义数据，那么它就是响应式的，举个例子：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;random&quot;</span>&gt;</span>Random msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&#x27;msg reactive&#x27;</span>\n      }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n      <span class=\"hljs-function\"><span class=\"hljs-title\">random</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">Math</span>.random()\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>上述组件初次渲染会显示“msg reactive”，当我们点击按钮的时候，会执行 random 函数，random 函数会修改 this.msg，就会发现组件重新渲染了。\n我们对这个例子做一些改动，模板部分不变，我们把 msg 数据的定义放到 created 钩子中：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-title\">created</span>(<span class=\"hljs-params\"></span>)</span> {\n    <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-string\">&quot;msg not reactive&quot;</span>;\n  },\n  <span class=\"hljs-attr\">methods</span>: {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">random</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-built_in\">this</span>.msg = <span class=\"hljs-built_in\">Math</span>.random();\n    },\n  },\n};\n</code></pre>\n<p>此时，组件初次渲染显示“msg not reactive”，但是我们再次点击按钮就会发现组件并没有重新渲染。\n这个问题相信你可能遇到过，其中的根本原因是我们在 created 中定义的 this.msg 并不是响应式对象，所以 Vue.js 内部不会对它做额外的处理。而 data 中定义的数据，Vue.js 内部在组件初始化的过程中会把它变成响应式，这是一个相对黑盒的过程，用户通常不会感知到。</p>\n<p>你可能会好奇，为什么我在 created 钩子函数中定义数据而不在 data 中去定义？其实在 data 中定义数据最终也是挂载到组件实例 this 上，这和我直接在 created 钩子函数通过 <a href=\"http://this.xxx\">this.xxx</a> 定义的数据唯一区别就是，在 data 中定义的数据<strong>是响应式的</strong>。</p>\n<p>在一些场景下，如果我们仅仅想在组件上下文中共享某个变量，而不必去监测它的这个数据变化，这时就特别适合在 created 钩子函数中去定义这个变量，因为创建响应式的过程是有性能代价的，这相当于一种 Vue.js 应用的性能优化小技巧，你掌握了这一点就可以在合适的场景中应用了。</p>\n<p>到了 <strong>Vue.js 3.0</strong> 构建组件时，你可以不依赖于 Options API，而<strong>使用 Composition API</strong> 去编写。对于刚才的例子，我们可以用 Composition API 这样改写：</p>\n<pre class=\"hljs\"><code>&lt;template&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{{ state.msg }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;random&quot;</span>&gt;</span>Random msg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&lt;/template&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-keyword\">const</span> state = reactive({\n        <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">&#x27;msg reactive&#x27;</span>\n      })\n\n      <span class=\"hljs-keyword\">const</span> random = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        state.msg = <span class=\"hljs-built_in\">Math</span>.random()\n      }\n\n      <span class=\"hljs-keyword\">return</span> {\n        random,\n        state\n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>可以看到，我们通过 setup 函数实现和前面示例同样的功能。请注意，这里我们引入了 <strong>reactive API，它可以把一个对象数据变成响应式。</strong> 可以看出来 Composition API 更推荐用户主动定义响应式对象，而非内部的黑盒处理。这样用户可以更加明确哪些数据是响应式的，如果你不想让数据变成响应式，就定义成它的原始数据类型即可。</p>\n<p>也就是在 Vue.js 3.0 中，我们用 reactive 这个有魔力的函数，把数据变成了响应式，那么它内部到底是怎么实现的呢？我们接下来一探究竟。</p>\n<h2>2 Reactive API</h2>\n<p>我们先来看一下 reactive 函数的具体实现过程：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reactive</span>(<span class=\"hljs-params\">target</span>) </span>{\n  <span class=\"hljs-comment\">// 如果尝试把一个 readonly proxy 变成响应式，直接返回这个 readonly proxy</span>\n  <span class=\"hljs-keyword\">if</span> (target &amp;&amp; target.__v_isReadonly) {\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n  <span class=\"hljs-keyword\">return</span> createReactiveObject(\n    target,\n    <span class=\"hljs-literal\">false</span>,\n    mutableHandlers,\n    mutableCollectionHandlers\n  );\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createReactiveObject</span>(<span class=\"hljs-params\">\n  target,\n  isReadonly,\n  baseHandlers,\n  collectionHandlers\n</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (!isObject(target)) {\n    <span class=\"hljs-comment\">// 目标必须是对象或数组类型</span>\n    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&quot;production&quot;</span>) {\n      <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">`value cannot be made reactive: <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">String</span>(target)}</span>`</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n  <span class=\"hljs-keyword\">if</span> (target.__v_raw &amp;&amp; !(isReadonly &amp;&amp; target.__v_isReactive)) {\n    <span class=\"hljs-comment\">// target 已经是 Proxy 对象，直接返回</span>\n    <span class=\"hljs-comment\">// 有个例外，如果是 readonly 作用于一个响应式对象，则继续</span>\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n  <span class=\"hljs-keyword\">if</span> (\n    hasOwn(\n      target,\n      isReadonly ? <span class=\"hljs-string\">&quot;__v_readonly&quot;</span> <span class=\"hljs-comment\">/* readonly */</span> : <span class=\"hljs-string\">&quot;__v_reactive&quot;</span> <span class=\"hljs-comment\">/* reactive */</span>\n    )\n  ) {\n    <span class=\"hljs-comment\">// target 已经有对应的 Proxy 了</span>\n    <span class=\"hljs-keyword\">return</span> isReadonly ? target.__v_readonly : target.__v_reactive;\n  }\n  <span class=\"hljs-comment\">// 只有在白名单里的数据类型才能变成响应式</span>\n  <span class=\"hljs-keyword\">if</span> (!canObserve(target)) {\n    <span class=\"hljs-keyword\">return</span> target;\n  }\n  <span class=\"hljs-comment\">// 利用 Proxy 创建响应式</span>\n  <span class=\"hljs-keyword\">const</span> observed = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(\n    target,\n    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers\n  );\n  <span class=\"hljs-comment\">// 给原始数据打个标识，说明它已经变成响应式，并且有对应的 Proxy 了</span>\n  def(\n    target,\n    isReadonly ? <span class=\"hljs-string\">&quot;__v_readonly&quot;</span> <span class=\"hljs-comment\">/* readonly */</span> : <span class=\"hljs-string\">&quot;__v_reactive&quot;</span> <span class=\"hljs-comment\">/* reactive */</span>,\n    observed\n  );\n  <span class=\"hljs-keyword\">return</span> observed;\n}\n</code></pre>\n<p>可以看到，reactive 内部通过 createReactiveObject 函数把 target 变成了一个响应式对象。\n在这个过程中，createReactiveObject 函数主要做了以下几件事情。</p>\n<ol>\n<li>函数首先判断 target 是不是数组或者对象类型，如果不是则直接返回。所以<strong>原始数据 target 必须是对象或者数组</strong>。</li>\n<li>如果对一个已经是响应式的对象再次执行 reactive，还应该返回这个响应式对象，举个例子：</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">const</span> original = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">const</span> observed = reactive(original);\n<span class=\"hljs-keyword\">const</span> observed2 = reactive(observed);\nobserved === observed2;\n</code></pre>\n<p>可以看到 observed 已经是响应式结果了，如果对它再去执行 reactive，返回的值 observed2 和 observed 还是同一个对象引用。</p>\n<p>因为这里 reactive 函数会通过 target.**v_raw 属性来判断 target 是否已经是一个响应式对象（因为响应式对象的 **v_raw 属性会指向它自身，后面会提到），如果是的话则直接返回响应式对象。</p>\n<ol start=\"3\">\n<li>如果对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象，举个例子：</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { reactive } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;\n<span class=\"hljs-keyword\">const</span> original = { <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span> };\n<span class=\"hljs-keyword\">const</span> observed = reactive(original);\n<span class=\"hljs-keyword\">const</span> observed2 = reactive(original);\nobserved === observed2;\n</code></pre>\n<p>可以看到，原始数据 original 被反复执行 reactive，但是响应式结果 observed 和 observed2 是同一个对象。</p>\n<p>所以这里 reactive 函数会通过 target.**v_reactive 判断 target 是否已经有对应的响应式对象（因为创建完响应式对象后，会给原始对象打上 **v_reactive 标识，后面会提到），如果有则返回这个响应式对象。</p>\n<ol start=\"4\">\n<li>使用 canObserve 函数对 target 对象做一进步限制：</li>\n</ol>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> canObserve = <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    !value.__v_skip &amp;&amp;\n    isObservableType(toRawType(value)) &amp;&amp;\n    !<span class=\"hljs-built_in\">Object</span>.isFrozen(value)\n  );\n};\n<span class=\"hljs-keyword\">const</span> isObservableType = <span class=\"hljs-comment\">/*#__PURE__*/</span> makeMap(\n  <span class=\"hljs-string\">&quot;Object,Array,Map,Set,WeakMap,WeakSet&quot;</span>\n);\n</code></pre>\n<p>比如，带有 __v_skip 属性的对象、被冻结的对象，以及不在白名单内的对象如 Date 类型的对象实例是不能变成响应式的。</p>\n<ol start=\"5\">\n<li>\n<p>通过 Proxy API 劫持 target 对象，把它变成响应式。我们把 Proxy 函数返回的结果称作响应式对象，这里 Proxy 对应的处理器对象会根据数据类型的不同而不同，我们稍后会重点分析基本数据类型的 Proxy 处理器对象，reactive 函数传入的 baseHandlers 值是 mutableHandlers。</p>\n</li>\n<li>\n<p>给原始数据打个标识，如下：</p>\n</li>\n</ol>\n<pre class=\"hljs\"><code>target.__v_reactive = observed;\n</code></pre>\n<p>这就是前面“对同一个原始数据多次执行 reactive ，那么会返回相同的响应式对象”逻辑的判断依据。</p>\n<p>仔细想想看，响应式的实现方式无非就是劫持数据，Vue.js 3.0 的 reactive API 就是通过 Proxy 劫持数据，而且由于 Proxy 劫持的是整个对象，所以我们可以检测到任何对对象的修改，弥补了 Object.defineProperty API 的不足。</p>\n<p>接下来，我们继续看 Proxy 处理器对象 mutableHandlers 的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys,\n};\n</code></pre>\n<p>它其实就是劫持了我们对 observed 对象的一些操作，比如：</p>\n<ul>\n<li>\n<p>访问对象属性会触发 get 函数；</p>\n</li>\n<li>\n<p>设置对象属性会触发 set 函数；</p>\n</li>\n<li>\n<p>删除对象属性会触发 deleteProperty 函数；</p>\n</li>\n<li>\n<p>in 操作符会触发 has 函数；</p>\n</li>\n<li>\n<p>通过 Object.getOwnPropertyNames 访问对象属性名会触发 ownKeys 函数。</p>\n</li>\n</ul>\n<p>因为无论命中哪个处理器函数，它都会做依赖收集和派发通知这两件事其中的一个，所以这里我只要分析常用的 get 和 set 函数就可以了。</p>\n<h3>2.1 依赖收集：get 函数</h3>\n<p><strong>依赖收集发生在数据访问的阶段</strong>，由于我们用 Proxy API 劫持了数据对象，所以当这个响应式对象属性被访问的时候就会执行 get 函数，我们来看一下 get 函数的实现，其实它是执行 createGetter 函数的返回值，为了分析主要流程，这里省略了 get 函数中的一些分支逻辑，isReadonly 也默认为 false：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createGetter</span>(<span class=\"hljs-params\">isReadonly = <span class=\"hljs-literal\">false</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span>(<span class=\"hljs-params\">target, key, receiver</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">&quot;__v_isReactive&quot;</span> <span class=\"hljs-comment\">/* isReactive */</span>) {\n      <span class=\"hljs-comment\">// 代理 observed.__v_isReactive</span>\n      <span class=\"hljs-keyword\">return</span> !isReadonly;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">&quot;__v_isReadonly&quot;</span> <span class=\"hljs-comment\">/* isReadonly */</span>) {\n      <span class=\"hljs-comment\">// 代理 observed.__v_isReadonly</span>\n      <span class=\"hljs-keyword\">return</span> isReadonly;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">&quot;__v_raw&quot;</span> <span class=\"hljs-comment\">/* raw */</span>) {\n      <span class=\"hljs-comment\">// 代理 observed.__v_raw</span>\n      <span class=\"hljs-keyword\">return</span> target;\n    }\n    <span class=\"hljs-keyword\">const</span> targetIsArray = isArray(target);\n    <span class=\"hljs-comment\">// arrayInstrumentations 包含对数组一些方法修改的函数</span>\n    <span class=\"hljs-keyword\">if</span> (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(arrayInstrumentations, key, receiver);\n    }\n    <span class=\"hljs-comment\">// 求值</span>\n    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-built_in\">Reflect</span>.get(target, key, receiver);\n    <span class=\"hljs-comment\">// 内置 Symbol key 不需要依赖收集</span>\n    <span class=\"hljs-keyword\">if</span> ((isSymbol(key) &amp;&amp; builtInSymbols.has(key)) || key === <span class=\"hljs-string\">&quot;__proto__&quot;</span>) {\n      <span class=\"hljs-keyword\">return</span> res;\n    }\n    <span class=\"hljs-comment\">// 依赖收集</span>\n    !isReadonly &amp;&amp; track(target, <span class=\"hljs-string\">&quot;get&quot;</span> <span class=\"hljs-comment\">/* GET */</span>, key);\n    <span class=\"hljs-keyword\">return</span> isObject(res)\n      ? isReadonly\n        ? readonly(res)\n        : <span class=\"hljs-comment\">// 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式</span>\n          reactive(res)\n      : res;\n  };\n}\n</code></pre>\n<p>结合上述代码来看，get 函数主要做了四件事情，<strong>首先对特殊的 key 做了代理</strong>，这就是为什么我们在 createReactiveObject 函数中判断响应式对象是否存在 __v_raw 属性，如果存在就返回这个响应式对象本身。</p>\n<p><strong>接着通过 Reflect.get 方法求值</strong>，如果 target 是数组且 key 命中了 arrayInstrumentations，则执行对应的函数，我们可以大概看一下 arrayInstrumentations 的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> arrayInstrumentations = {}[\n  (<span class=\"hljs-string\">&quot;includes&quot;</span>, <span class=\"hljs-string\">&quot;indexOf&quot;</span>, <span class=\"hljs-string\">&quot;lastIndexOf&quot;</span>)\n].forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> {\n  arrayInstrumentations[key] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) </span>{\n    <span class=\"hljs-comment\">// toRaw 可以把响应式对象转成原始数据</span>\n    <span class=\"hljs-keyword\">const</span> arr = toRaw(<span class=\"hljs-built_in\">this</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = <span class=\"hljs-built_in\">this</span>.length; i &lt; l; i++) {\n      <span class=\"hljs-comment\">// 依赖收集</span>\n      track(arr, <span class=\"hljs-string\">&quot;get&quot;</span> <span class=\"hljs-comment\">/* GET */</span>, i + <span class=\"hljs-string\">&quot;&quot;</span>);\n    }\n    <span class=\"hljs-comment\">// 先尝试用参数本身，可能是响应式数据</span>\n    <span class=\"hljs-keyword\">const</span> res = arr[key](...args);\n    <span class=\"hljs-keyword\">if</span> (res === -<span class=\"hljs-number\">1</span> || res === <span class=\"hljs-literal\">false</span>) {\n      <span class=\"hljs-comment\">// 如果失败，再尝试把参数转成原始数据</span>\n      <span class=\"hljs-keyword\">return</span> arr[key](...args.map(toRaw));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> res;\n    }\n  };\n});\n</code></pre>\n<p>也就是说，当 target 是一个数组的时候，我们去访问 target.includes、target.indexOf 或者 target.lastIndexOf 就会执行 arrayInstrumentations 代理的函数，除了调用数组本身的方法求值外，还对数组每个元素做了依赖收集。因为一旦数组的元素被修改，数组的这几个 API 的返回结果都可能发生变化，所以我们需要跟踪数组每个元素的变化。</p>\n<p>回到 get 函数，第三步就是<strong>通过 Reflect.get 求值，然后会执行 track 函数收集依赖</strong>，我们稍后重点分析这个过程。</p>\n<p>函数最后<strong>会对计算的值 res 进行判断</strong>，如果它也是数组或对象，则递归执行 reactive 把 res 变成响应式对象。这么做是因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化，这点和 Object.defineProperty API 一致。但是 Object.defineProperty 是在初始化阶段，即定义劫持对象的时候就已经递归执行了，而 Proxy 是在对象属性被访问的时候才递归执行下一步 reactive，这其实是一种延时定义子对象响应式的实现，在性能上会有较大的提升。</p>\n<p>整个 get 函数最核心的部分其实是<strong>执行 track 函数收集依赖</strong>，下面我们重点分析这个过程。\n我们先来看一下 track 函数的实现：</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// 是否应该收集依赖</span>\n<span class=\"hljs-keyword\">let</span> shouldTrack = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-comment\">// 当前激活的 effect</span>\n<span class=\"hljs-keyword\">let</span> activeEffect;\n<span class=\"hljs-comment\">// 原始数据对象 map</span>\n<span class=\"hljs-keyword\">const</span> targetMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">track</span>(<span class=\"hljs-params\">target, type, key</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (!shouldTrack || activeEffect === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">return</span>;\n  }\n  <span class=\"hljs-keyword\">let</span> depsMap = targetMap.get(target);\n  <span class=\"hljs-keyword\">if</span> (!depsMap) {\n    <span class=\"hljs-comment\">// 每个 target 对应一个 depsMap</span>\n    targetMap.set(target, (depsMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()));\n  }\n  <span class=\"hljs-keyword\">let</span> dep = depsMap.get(key);\n  <span class=\"hljs-keyword\">if</span> (!dep) {\n    <span class=\"hljs-comment\">// 每个 key 对应一个 dep 集合</span>\n    depsMap.set(key, (dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()));\n  }\n  <span class=\"hljs-keyword\">if</span> (!dep.has(activeEffect)) {\n    <span class=\"hljs-comment\">// 收集当前激活的 effect 作为依赖</span>\n    dep.add(activeEffect);\n    <span class=\"hljs-comment\">// 当前激活的 effect 收集 dep 集合作为依赖</span>\n    activeEffect.deps.push(dep);\n  }\n}\n</code></pre>\n<p>分析这个函数的实现前，我们先想一下要收集的依赖是什么，我们的目的是实现响应式，就是当数据变化的时候可以自动做一些事情，比如执行某些函数，所以我们<strong>收集的依赖就是数据变化后执行的副作用函数</strong>。</p>\n<p>再来看实现，我们把 target 作为原始的数据，key 作为访问的属性。我们创建了全局的 targetMap 作为原始数据对象的 Map，它的键是 target，值是 depsMap，作为依赖的 Map；这个 depsMap 的键是 target 的 key，值是 dep 集合，dep 集合中存储的是依赖的副作用函数。为了方便理解，可以通过下图表示它们之间的关系：</p>\n<p><img src=\"/assets/blog/context/2021-01-08-vue3-core-source-code-5/Ciqc1F8YAL6Afvr-AAEj_nQbDuE332.png\" alt=\"Ciqc1F8YAL6Afvr-AAEj_nQbDuE332.png\">\n所以每次 track ，就是把当前激活的副作用函数 activeEffect 作为依赖，然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。\n了解完依赖收集的过程，下节课我们来分析派发通知的过程。</p>\n<blockquote>\n<p><strong>本文的相关代码在源代码中的位置如下：</strong><br>\npackages/reactivity/src/baseHandlers.ts<br>\npackages/reactivity/src/effect.ts<br>\npackages/reactivity/src/reactive.ts</p>\n</blockquote>\n","ogImage":{"url":"/assets/blog/cover/2021-01-08-vue3-core-source-code-5.png"},"coverImage":"/assets/blog/cover/2021-01-08-vue3-core-source-code-5.png"},"tags":{"alibaba":{"value":2,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"},{"tag":"alibaba","slug":"2015-06-15-alitrip-strategy"}]},"体验":{"value":1,"posts":[{"tag":"alibaba,体验","slug":"2014-10-01-why-alibaba-ux-sucks"}]},"响应式":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"自适应":{"value":1,"posts":[{"tag":"响应式,自适应","slug":"2014-11-20-responsive-web-design"}]},"Apple":{"value":1,"posts":[{"tag":"Apple","slug":"2015-03-10-apple-event-2015"}]},"数字":{"value":1,"posts":[{"tag":"数字","slug":"2015-03-25-digital-native"}]},"端到端":{"value":1,"posts":[{"tag":"端到端","slug":"2015-03-31-e2e_user_scenarios"}]},"Unix":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"Linux":{"value":1,"posts":[{"tag":"Unix,Linux","slug":"2015-04-14-unix-linux-note"}]},"UI":{"value":1,"posts":[{"tag":"UI","slug":"2015-04-15-os-metro"}]},"JavaScript":{"value":13,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"},{"tag":"JavaScript","slug":"2015-09-22-js-version"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"JavaScript","slug":"2018-08-04-Proxy-and-Reflect-of-ES6"},{"tag":"JavaScript","slug":"2018-12-12-commonly-used-regular-expressionsm"},{"tag":"JavaScript","slug":"2019-09-22-javascript-this-pointer"},{"tag":"JavaScript","slug":"2019-10-24-JavaScript-prototype"},{"tag":"JavaScript","slug":"2020-07-11-ECMAScript2016"},{"tag":"JavaScript","slug":"2020-07-18-ECMAScript2017"},{"tag":"JavaScript","slug":"2020-08-12-ECMAScript2018"},{"tag":"JavaScript","slug":"2020-08-22-ECMAScript2019"},{"tag":"JavaScript","slug":"2020-09-20-ECMAScript2020"}]},"模块化":{"value":2,"posts":[{"tag":"JavaScript,模块化","slug":"2015-05-25-js-module-loader"},{"tag":"JavaScript,模块化","slug":"2015-07-09-js-module-7day"}]},"前端":{"value":3,"posts":[{"tag":"前端","slug":"2015-10-28-how-designer-learn-fe"},{"tag":"前端,JavaScript","slug":"2015-12-15-ios9-safari-web"},{"tag":"前端","slug":"2018-12-12-downloading-frontend-data-stream-files"}]},"CSS":{"value":1,"posts":[{"tag":"CSS","slug":"2015-12-28-css-sucks-2015"}]},"react":{"value":10,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"},{"tag":"react","slug":"2018-08-15-react-new-life-cycle-hook"},{"tag":"react","slug":"2019-10-23-setState-sync-or-async"},{"tag":"react","slug":"2019-12-18-immutable-react"},{"tag":"react","slug":"2020-09-27-react-grid-layout"},{"tag":"react","slug":"2020-10-06-react17-coming"},{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"},{"tag":"react","slug":"2021-01-31-react-diff"},{"tag":"react","slug":"2021-03-24-thorough-react-0"},{"tag":"react","slug":"2021-09-23-react-performance-optimization-3-tips"}]},"angular":{"value":1,"posts":[{"tag":"react,angular","slug":"2016-02-01-React-vs-Angular2"}]},"PWA":{"value":4,"posts":[{"tag":"PWA","slug":"2016-06-05-pwa-in-my-pov"},{"tag":"PWA","slug":"2016-10-20-pwa-qcon2016"},{"tag":"PWA","slug":"2017-02-09-nextgen-web-pwa"},{"tag":"PWA","slug":"2017-07-12-upgrading-eleme-to-pwa"}]},"生活":{"value":1,"posts":[{"tag":"生活","slug":"2018-07-31-about-life-and-survival"}]},"Node":{"value":1,"posts":[{"tag":"Node","slug":"2018-08-02-make-the-cli-with-node"}]},"H5":{"value":1,"posts":[{"tag":"H5","slug":"2018-08-06-common-problems-and-matters-needing-attention-on-h5-mobile-terminal"}]},"vue":{"value":30,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"},{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"},{"tag":"vue","slug":"2020-12-19-vue3-core-source-code-0"},{"tag":"vue","slug":"2020-12-21-vue3-core-source-code-1"},{"tag":"vue","slug":"2020-12-23-vue3-core-source-code-2"},{"tag":"vue","slug":"2020-12-24-vue3-core-source-code-3"},{"tag":"vue","slug":"2020-12-30-vue3-core-source-code-4"},{"tag":"vue","slug":"2021-01-08-vue3-core-source-code-5"},{"tag":"vue","slug":"2021-01-09-vue3-core-source-code-6"},{"tag":"vue","slug":"2021-01-10-vue3-core-source-code-7"},{"tag":"vue","slug":"2021-01-12-vue3-core-source-code-8"},{"tag":"vue","slug":"2021-01-13-vue3-core-source-code-9"},{"tag":"vue","slug":"2021-01-14-vue3-core-source-code-10"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-11"},{"tag":"vue","slug":"2021-01-15-vue3-core-source-code-12"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-13"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-14"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-15"},{"tag":"vue","slug":"2021-01-16-vue3-core-source-code-16"},{"tag":"vue","slug":"2021-01-17-vue3-core-source-code-17"},{"tag":"vue","slug":"2021-01-18-vue3-core-source-code-18"},{"tag":"vue","slug":"2021-01-19-vue3-core-source-code-19"},{"tag":"vue","slug":"2021-01-20-vue3-core-source-code-20"},{"tag":"vue","slug":"2021-01-21-vue3-core-source-code-21"},{"tag":"vue","slug":"2021-01-22-vue3-core-source-code-22"},{"tag":"vue","slug":"2021-01-23-vue3-core-source-code-23"},{"tag":"vue","slug":"2021-01-24-vue3-core-source-code-24"},{"tag":"vue","slug":"2021-01-25-vue3-core-source-code-25"},{"tag":"vue","slug":"2021-01-26-vue3-core-source-code-26"},{"tag":"vue","slug":"2021-01-27-vue3-core-source-code-27"}]},"小程序":{"value":1,"posts":[{"tag":"vue,小程序","slug":"2018-08-07-vue-and-wechat-small-program-differences"}]},"MySQL":{"value":1,"posts":[{"tag":"MySQL","slug":"2018-08-09-mysql-common-commands"}]},"ssr":{"value":1,"posts":[{"tag":"vue,ssr","slug":"2018-08-15-vue-server-side-render"}]},"VScode":{"value":1,"posts":[{"tag":"VScode","slug":"2020-08-01-vscode-code-annotation-keyword-analysis"}]},"webpack":{"value":1,"posts":[{"tag":"webpack,react","slug":"2020-12-17-webpack5-build-react-dev-env"}]},"typescript":{"value":1,"posts":[{"tag":"typescript","slug":"2021-05-24-typescript-actual-combat"}]}}},"__N_SSG":true}